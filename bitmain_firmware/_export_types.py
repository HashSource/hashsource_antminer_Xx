#!/usr/bin/env python3
# @category DataTypes
# @description Export user-defined data types to C header file

import os

from ghidra.program.model.data import (
    Array,
    Enum,
    FunctionDefinition,
    Structure,
    TypeDef,
    Union,
)

# Get output directory from environment or use default
output_dir = os.getenv("GHIDRA_OUTPUT_PATH", "_ghidra")
output_path = os.path.join(os.getcwd(), output_dir)

# Create output directory if it doesn't exist
if not os.path.exists(output_path):
    os.makedirs(output_path)

# Get current program
program = getCurrentProgram()
if program is None:
    print("ERROR: No program is currently open")
    exit(1)

program_name = program.getName()
print("Exporting types from: {}".format(program_name))

# Get data type manager
dtm = program.getDataTypeManager()

# Collect types to export (only user-defined, not built-ins)
structures = []
unions = []
enums = []
typedefs = []
function_defs = []

# Iterate through all data types
for dt in dtm.getAllDataTypes():
    # Skip built-in types from system libraries
    if dt.getSourceArchive().getName() in ["BuiltInTypes", "generic_clib_32"]:
        continue

    # Categorize by type
    if isinstance(dt, Structure):
        structures.append(dt)
    elif isinstance(dt, Union):
        unions.append(dt)
    elif isinstance(dt, Enum):
        enums.append(dt)
    elif isinstance(dt, TypeDef):
        typedefs.append(dt)
    elif isinstance(dt, FunctionDefinition):
        function_defs.append(dt)

# Create output file
header_file = os.path.join(output_path, program_name + ".h")
print("Writing to: {}".format(header_file))

with open(header_file, "w") as f:
    # Write header guard
    guard = program_name.upper().replace(".", "_").replace("-", "_") + "_TYPES_H"
    f.write("// Data types exported from: {}\n".format(program_name))
    f.write("// Generated by Ghidra\n\n")
    f.write("#ifndef {}\n".format(guard))
    f.write("#define {}\n\n".format(guard))

    # Standard includes
    f.write("#include <stdint.h>\n")
    f.write("#include <stdbool.h>\n\n")

    # Export enumerations
    if enums:
        f.write("/* ==================== Enumerations ==================== */\n\n")
        for enum_type in sorted(enums, key=lambda x: x.getName()):
            f.write("typedef enum {{\n".format(enum_type.getName()))
            for name in enum_type.getNames():
                value = enum_type.getValue(name)
                f.write("    {} = {},\n".format(name, value))
            f.write("}} {};\n\n".format(enum_type.getName()))

    # Export forward declarations for structures
    if structures:
        f.write(
            "/* ==================== Forward Declarations ==================== */\n\n"
        )
        for struct in sorted(structures, key=lambda x: x.getName()):
            f.write(
                "typedef struct {} {};\n".format(struct.getName(), struct.getName())
            )
        f.write("\n")

    # Export structures
    if structures:
        f.write("/* ==================== Structures ==================== */\n\n")
        for struct in sorted(structures, key=lambda x: x.getName()):
            f.write("struct {} {{\n".format(struct.getName()))

            if struct.getNumComponents() == 0:
                f.write("    // Empty structure\n")
            else:
                for component in struct.getComponents():
                    comp_dt = component.getDataType()
                    comp_name = (
                        component.getFieldName()
                        if component.getFieldName()
                        else "field_{}".format(component.getOffset())
                    )

                    # Handle arrays
                    if isinstance(comp_dt, Array):
                        base_type = comp_dt.getDataType()
                        count = comp_dt.getNumElements()
                        f.write(
                            "    {} {}[{}];".format(
                                base_type.getDisplayName(), comp_name, count
                            )
                        )
                    else:
                        f.write(
                            "    {} {};".format(comp_dt.getDisplayName(), comp_name)
                        )

                    # Add offset comment
                    f.write("  // offset: 0x{:x}\n".format(component.getOffset()))

            f.write("}}; // size: 0x{:x}\n\n".format(struct.getLength()))

    # Export unions
    if unions:
        f.write("/* ==================== Unions ==================== */\n\n")
        for union in sorted(unions, key=lambda x: x.getName()):
            f.write("union {} {{\n".format(union.getName()))

            for component in union.getComponents():
                comp_dt = component.getDataType()
                comp_name = (
                    component.getFieldName()
                    if component.getFieldName()
                    else "field_{}".format(component.getOrdinal())
                )
                f.write("    {} {};\n".format(comp_dt.getDisplayName(), comp_name))

            f.write("}}; // size: 0x{:x}\n\n".format(union.getLength()))

    # Export typedefs
    if typedefs:
        f.write("/* ==================== Type Definitions ==================== */\n\n")
        for typedef in sorted(typedefs, key=lambda x: x.getName()):
            base_type = typedef.getDataType()
            f.write(
                "typedef {} {};\n".format(base_type.getDisplayName(), typedef.getName())
            )
        f.write("\n")

    # Export function prototypes
    if function_defs:
        f.write(
            "/* ==================== Function Prototypes ==================== */\n\n"
        )
        for func_def in sorted(function_defs, key=lambda x: x.getName()):
            ret_type = func_def.getReturnType()
            f.write(
                "{} {}(".format(
                    ret_type.getDisplayName() if ret_type else "void",
                    func_def.getName(),
                )
            )

            args = func_def.getArguments()
            if len(args) == 0:
                f.write("void")
            else:
                arg_strs = []
                for i, arg in enumerate(args):
                    arg_name = arg.getName() if arg.getName() else "param{}".format(i)
                    arg_strs.append(
                        "{} {}".format(arg.getDataType().getDisplayName(), arg_name)
                    )
                f.write(", ".join(arg_strs))

            f.write(");\n")
        f.write("\n")

    # Close header guard
    f.write("#endif // {}\n".format(guard))

print("Type export complete!")
print("  Enums: {}".format(len(enums)))
print("  Structures: {}".format(len(structures)))
print("  Unions: {}".format(len(unions)))
print("  Typedefs: {}".format(len(typedefs)))
print("  Function defs: {}".format(len(function_defs)))
