//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <dirent.h>
#include <errno.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stropts.h>
#include <unistd.h>

// ---------------- Integer Types Definitions -----------------

typedef int8_t int4_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct __dirstream {
    int32_t e0;
};

struct dirent64 {
    int32_t e0;
    int32_t e1;
    int16_t e2;
    char e3;
    char e4[256];
};

// ------------------- Function Prototypes --------------------

int32_t entry_point(int32_t i_a1, int32_t i_a2);
int32_t function_10af0(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t *function_10b10(int32_t nmemb, int32_t size);
int32_t function_10b1c(char *s1, char *s2);
int32_t function_10b28(char *nptr, char **endptr, int32_t base);
int32_t function_10b34(char *format, ...);
int32_t function_10b40(struct _IO_FILE *stream);
void function_10b4c(int32_t *ptr);
char *function_10b58(char *s, int32_t n, struct _IO_FILE *stream);
int32_t function_10b64(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t *p_a4);
int32_t *function_10b70(int32_t *ptr, int32_t size);
int32_t function_10b7c(char *s1, char *s2);
int32_t function_10b88(int32_t *ptr, int32_t size, int32_t n,
                       struct _IO_FILE *s);
int32_t function_10b94(int32_t fd, int32_t request, ...);
char *function_10ba0(char *dest, char *src);
int32_t function_10bac(int32_t i_a1, int32_t i_a2);
struct __dirstream *function_10bb8(char *name);
int32_t function_10bc4(char *file, int32_t oflag, ...);
int32_t function_10bd0(char *s);
int32_t *function_10bdc(int32_t size);
int32_t function_10be8(int32_t main, int32_t argc, char **ubp_av,
                       void (*init)(), void (*fini)(), void (*rtld_fini)());
char *function_10bf4(int32_t errnum);
void function_10c00(void);
void function_10c0c(int32_t status);
int32_t function_10c18(char *nptr, char **endptr, int32_t base);
int32_t function_10c24(int32_t i_a1);
int32_t function_10c30(char *s);
char *function_10c3c(char *s, int32_t c);
int32_t function_10c48(struct _IO_FILE *stream, char *format, ...);
int32_t function_10c54(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t *function_10c60(void);
int32_t function_10c6c(char *s, int32_t maxlen, char *format, ...);
int32_t function_10c78(char *s, char *format, ...);
char *function_10c84(char *string);
int32_t *function_10c90(int32_t *s, int32_t c, int32_t n);
int32_t function_10c9c(struct _IO_FILE *stream);
int32_t function_10ca8(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_10cb4(struct _IO_FILE *stream);
int32_t function_10cc0(int32_t i_a1, int32_t i_a2);
char *function_10ccc(char *s, int32_t c);
int32_t function_10cd8(char *s, char *format, ...);
struct dirent64 *function_10ce4(struct __dirstream *dirp);
int32_t function_10cf0(int32_t i_a1, int32_t i_a2);
struct _IO_FILE *function_10cfc(char *filename, char *modes);
int32_t function_10d08(char *s1, char *s2, int32_t n);
void function_10d14(void);
int32_t function_10d20(int32_t fd);
int32_t function_10d2c(struct __dirstream *dirp);
int32_t function_10d38(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t *p_a4);
int32_t function_10d44(int32_t i_a1, int32_t i_a2);
int32_t function_11b10(int32_t i_a1);
int32_t function_11b1c(void);
int32_t function_11b40(int32_t i_a1, int32_t i_a2, int32_t i_a3, char i_a4);
int32_t function_11b94(int32_t i_a1);
int32_t function_11ba8(void);
int32_t function_11bac(void);
int32_t function_11bd8(int32_t i_a1);
int32_t function_11c48(int32_t i_a1);
int32_t function_11c80(int32_t i_a1, int32_t i_a2);
int32_t function_11cc8(int32_t i_a1, int32_t i_a2);
int32_t function_11d80(int32_t i_a1, int32_t *p_a2, int32_t i_a3, int32_t i_a4);
int32_t function_11eb0(void);
int32_t function_12498(int32_t i_a1);
int32_t function_125ec(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t function_12660(int32_t i_a1);
int32_t function_12700(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_1273c(void);
int32_t function_12740(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t unknown_240(void);

// --------------------- Global Variables ---------------------

int32_t i_g1 = -0x1cae0000; // 0x11b2c
int32_t i_g2 = 0x2a000030;  // 0x124d4
char *p_g3;                 // 0x1290c
char *x_g4[10] = {"dummy",   "Dummy bus",   "isa",   "ISA bus",
                  "i2c",     "I2C adapter", "smbus", "SMBus adapter",
                  "unknown", "N/A"}; // 0x12e54
int32_t i_g5 = 0x11ba9;       // 0x23f08
struct _IO_FILE *p_g6 = NULL; // 0x240d8
struct _IO_FILE *p_g7 = NULL; // 0x240e0
int32_t i_g8;
int32_t i_g9;
int32_t i_g10;
int32_t i_g11;

// ------- Dynamically Linked Functions Without Header --------

void __gmon_start__(void);
int32_t __libc_start_main(int32_t i_a1, int32_t i_a2, char **p_a3,
                          void (*p_a4)(), void (*p_a5)(), void (*p_a6)());
char *__strdup(char *p_a1);
struct _IO_FILE *fopen64(char *p_a1, char *p_a2);
int32_t i2c_smbus_read_byte(int32_t i_a1);
int32_t i2c_smbus_read_byte_data(int32_t i_a1, int32_t i_a2);
int32_t i2c_smbus_read_word_data(int32_t i_a1, int32_t i_a2);
int32_t i2c_smbus_write_block_data(int32_t i_a1, int32_t i_a2, int32_t i_a3,
                                   int32_t *p_a4);
int32_t i2c_smbus_write_byte(int32_t i_a1, int32_t i_a2);
int32_t i2c_smbus_write_byte_data(int32_t i_a1, int32_t i_a2, int32_t i_a3,
                                  int32_t i_a4);
int32_t i2c_smbus_write_i2c_block_data(int32_t i_a1, int32_t i_a2, int32_t i_a3,
                                       int32_t *p_a4);
int32_t i2c_smbus_write_word_data(int32_t i_a1, int32_t i_a2, int32_t i_a3,
                                  int32_t i_a4);
int32_t open64(char *p_a1, int32_t i_a2, ...);
struct dirent64 *readdir64(struct __dirstream *p_a1);

// ------------------------ Functions -------------------------

// Address range: 0x10af0 - 0x10afc
int32_t function_10af0(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x10af0
    return function_11b1c();
}

// Address range: 0x10b10 - 0x10b1c
int32_t *function_10b10(int32_t nmemb, int32_t size) {
    // 0x10b10
    return calloc(nmemb, size);
}

// Address range: 0x10b1c - 0x10b28
int32_t function_10b1c(char *s1, char *s2) {
    // 0x10b1c
    return strcmp(s1, s2);
}

// Address range: 0x10b28 - 0x10b34
int32_t function_10b28(char *nptr, char **endptr, int32_t base) {
    // 0x10b28
    return strtol(nptr, endptr, base);
}

// Address range: 0x10b34 - 0x10b40
int32_t function_10b34(char *format, ...) {
    // 0x10b34
    return printf(format);
}

// Address range: 0x10b40 - 0x10b4c
int32_t function_10b40(struct _IO_FILE *stream) {
    // 0x10b40
    return fflush(stream);
}

// Address range: 0x10b4c - 0x10b58
void function_10b4c(int32_t *ptr) {
    // 0x10b4c
    free(ptr);
}

// Address range: 0x10b58 - 0x10b64
char *function_10b58(char *s, int32_t n, struct _IO_FILE *stream) {
    // 0x10b58
    return fgets(s, n, stream);
}

// Address range: 0x10b64 - 0x10b70
int32_t function_10b64(int32_t i_a1, int32_t i_a2, int32_t i_a3,
                       int32_t *p_a4) {
    // 0x10b64
    return i2c_smbus_write_block_data(i_a1, i_a2, i_a3, p_a4);
}

// Address range: 0x10b70 - 0x10b7c
int32_t *function_10b70(int32_t *ptr, int32_t size) {
    // 0x10b70
    return realloc(ptr, size);
}

// Address range: 0x10b7c - 0x10b88
int32_t function_10b7c(char *s1, char *s2) {
    // 0x10b7c
    return strcasecmp(s1, s2);
}

// Address range: 0x10b88 - 0x10b94
int32_t function_10b88(int32_t *ptr, int32_t size, int32_t n,
                       struct _IO_FILE *s) {
    // 0x10b88
    return fwrite(ptr, size, n, s);
}

// Address range: 0x10b94 - 0x10ba0
int32_t function_10b94(int32_t fd, int32_t request, ...) {
    // 0x10b94
    return ioctl(fd, request);
}

// Address range: 0x10ba0 - 0x10bac
char *function_10ba0(char *dest, char *src) {
    // 0x10ba0
    return strcpy(dest, src);
}

// Address range: 0x10bac - 0x10bb8
int32_t function_10bac(int32_t i_a1, int32_t i_a2) {
    // 0x10bac
    return i2c_smbus_write_byte(i_a1, i_a2);
}

// Address range: 0x10bb8 - 0x10bc4
struct __dirstream *function_10bb8(char *name) {
    // 0x10bb8
    return opendir(name);
}

// Address range: 0x10bc4 - 0x10bd0
int32_t function_10bc4(char *file, int32_t oflag, ...) {
    // 0x10bc4
    return open64(file, oflag);
}

// Address range: 0x10bd0 - 0x10bdc
int32_t function_10bd0(char *s) {
    // 0x10bd0
    return puts(s);
}

// Address range: 0x10bdc - 0x10be8
int32_t *function_10bdc(int32_t size) {
    // 0x10bdc
    return malloc(size);
}

// Address range: 0x10be8 - 0x10bf4
int32_t function_10be8(int32_t main, int32_t argc, char **ubp_av,
                       void (*init)(), void (*fini)(), void (*rtld_fini)()) {
    // 0x10be8
    return __libc_start_main(main, argc, ubp_av, init, fini, rtld_fini);
}

// Address range: 0x10bf4 - 0x10c00
char *function_10bf4(int32_t errnum) {
    // 0x10bf4
    return strerror(errnum);
}

// Address range: 0x10c00 - 0x10c0c
void function_10c00(void) {
    // 0x10c00
    __gmon_start__();
}

// Address range: 0x10c0c - 0x10c18
void function_10c0c(int32_t status) {
    // 0x10c0c
    exit(status);
}

// Address range: 0x10c18 - 0x10c24
int32_t function_10c18(char *nptr, char **endptr, int32_t base) {
    // 0x10c18
    return strtoul(nptr, endptr, base);
}

// Address range: 0x10c24 - 0x10c30
int32_t function_10c24(int32_t i_a1) {
    // 0x10c24
    return i2c_smbus_read_byte(i_a1);
}

// Address range: 0x10c30 - 0x10c3c
int32_t function_10c30(char *s) {
    // 0x10c30
    return strlen(s);
}

// Address range: 0x10c3c - 0x10c48
char *function_10c3c(char *s, int32_t c) {
    // 0x10c3c
    return strchr(s, c);
}

// Address range: 0x10c48 - 0x10c54
int32_t function_10c48(struct _IO_FILE *stream, char *format, ...) {
    // 0x10c48
    return fprintf(stream, format);
}

// Address range: 0x10c54 - 0x10c60
int32_t function_10c54(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x10c54
    return i2c_smbus_write_byte_data(i_a1, i_a2, i_a3, i_a4);
}

// Address range: 0x10c60 - 0x10c6c
int32_t *function_10c60(void) {
    // 0x10c60
    return __errno_location();
}

// Address range: 0x10c6c - 0x10c78
int32_t function_10c6c(char *s, int32_t maxlen, char *format, ...) {
    // 0x10c6c
    return snprintf(s, maxlen, format);
}

// Address range: 0x10c78 - 0x10c84
int32_t function_10c78(char *s, char *format, ...) {
    // 0x10c78
    return sscanf(s, format);
}

// Address range: 0x10c84 - 0x10c90
char *function_10c84(char *string) {
    // 0x10c84
    return __strdup(string);
}

// Address range: 0x10c90 - 0x10c9c
int32_t *function_10c90(int32_t *s, int32_t c, int32_t n) {
    // 0x10c90
    return memset(s, c, n);
}

// Address range: 0x10c9c - 0x10ca8
int32_t function_10c9c(struct _IO_FILE *stream) {
    // 0x10c9c
    return fgetc(stream);
}

// Address range: 0x10ca8 - 0x10cb4
int32_t function_10ca8(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x10ca8
    return i2c_smbus_write_word_data(i_a1, i_a2, i_a3, i_a4);
}

// Address range: 0x10cb4 - 0x10cc0
int32_t function_10cb4(struct _IO_FILE *stream) {
    // 0x10cb4
    return fclose(stream);
}

// Address range: 0x10cc0 - 0x10ccc
int32_t function_10cc0(int32_t i_a1, int32_t i_a2) {
    // 0x10cc0
    return i2c_smbus_read_word_data(i_a1, i_a2);
}

// Address range: 0x10ccc - 0x10cd8
char *function_10ccc(char *s, int32_t c) {
    // 0x10ccc
    return strrchr(s, c);
}

// Address range: 0x10cd8 - 0x10ce4
int32_t function_10cd8(char *s, char *format, ...) {
    // 0x10cd8
    return sprintf(s, format);
}

// Address range: 0x10ce4 - 0x10cf0
struct dirent64 *function_10ce4(struct __dirstream *dirp) {
    // 0x10ce4
    return readdir64(dirp);
}

// Address range: 0x10cf0 - 0x10cfc
int32_t function_10cf0(int32_t i_a1, int32_t i_a2) {
    // 0x10cf0
    return i2c_smbus_read_byte_data(i_a1, i_a2);
}

// Address range: 0x10cfc - 0x10d08
struct _IO_FILE *function_10cfc(char *filename, char *modes) {
    // 0x10cfc
    return fopen64(filename, modes);
}

// Address range: 0x10d08 - 0x10d14
int32_t function_10d08(char *s1, char *s2, int32_t n) {
    // 0x10d08
    return strncmp(s1, s2, n);
}

// Address range: 0x10d14 - 0x10d20
void function_10d14(void) {
    // 0x10d14
    abort();
}

// Address range: 0x10d20 - 0x10d2c
int32_t function_10d20(int32_t fd) {
    // 0x10d20
    return close(fd);
}

// Address range: 0x10d2c - 0x10d38
int32_t function_10d2c(struct __dirstream *dirp) {
    // 0x10d2c
    return closedir(dirp);
}

// Address range: 0x10d38 - 0x10d44
int32_t function_10d38(int32_t i_a1, int32_t i_a2, int32_t i_a3,
                       int32_t *p_a4) {
    // 0x10d38
    return i2c_smbus_write_i2c_block_data(i_a1, i_a2, i_a3, p_a4);
}

// Address range: 0x10d44 - 0x11aec
int32_t function_10d44(int32_t i_a1, int32_t i_a2) {
    // 0x10d44
    if (i_a1 < 2) {
        // 0x11004
        function_11bac();
        // UNREACHABLE
    }
    int32_t i_v1 = i_a2 + 4;
    int32_t i_v2 = *(int32_t *)i_v1; // 0x10d54
    int32_t i_v3 = 0;                // 0x10d68
    int32_t i_v4 = 1;                // 0x10d68
    int32_t i_v5 = i_v2;             // 0x10d68
    int32_t i_v6 = 0;                // 0x10d68
    int32_t i_v7 = 0;                // 0x10d68
    int32_t i_v8 = 0;                // 0x10d68
    int32_t i_v9 = 0;                // 0x10d68
    int32_t i_v10 = 0;               // 0x10d68
    int32_t i_v11 = 0;               // 0x10d68
    if (*(char *)i_v2 == 45) {
        int32_t i_v12; // 0x10d44
        while (true) {
            int32_t i_v13 = i_v11;
            int32_t i_v14 = i_v10;
            int32_t i_v15 = i_v9;
            int32_t i_v16 = i_v8;
            int32_t i_v17 = i_v7;
            i_v12 = i_v5;
            int32_t i_v18 = i_v6;
            unsigned char i_v19 = *(char *)(i_v12 + 1); // 0x10d8c
            i_g8 = (int32_t)i_v19 - 86;
            int32_t i_v20 = i_v17; // 0x10d98
            int32_t i_v21 = i_v18; // 0x10d98
            int32_t i_v22 = 1;     // 0x10d98
            int32_t i_v23 = i_v15; // 0x10d98
            int32_t i_v24 = i_v14; // 0x10d98
            int32_t i_v25 = i_v13; // 0x10d98
            int32_t i_v26;         // 0x10e3c
            switch (i_v19) {
            case 86: {
                // branch -> 0x10e38
            }
            case 102: {
            lab_0x10e38:
                // 0x10e38
                i_v11 = i_v25;
                i_v10 = i_v24;
                i_v9 = i_v23;
                i_v8 = i_v22;
                i_v6 = i_v21;
                i_v7 = i_v20 + 1;
                i_v26 = i_v20 + 2;
                if (i_v26 >= i_a1) {
                    goto lab_0x10e58_2;
                }
                // break -> 0x10e48
                break;
            }
            case 121: {
                // 0x10fa0
                i_v20 = i_v17;
                i_v21 = i_v18;
                i_v22 = i_v16;
                i_v23 = 1;
                i_v24 = i_v14;
                i_v25 = i_v13;
                // branch (via goto) -> 0x10e38
                goto lab_0x10e38;
            }
            case 114: {
                // 0x10fac
                i_v20 = i_v17;
                i_v21 = i_v18;
                i_v22 = i_v16;
                i_v23 = i_v15;
                i_v24 = 1;
                i_v25 = i_v13;
                // branch (via goto) -> 0x10e38
                goto lab_0x10e38;
            }
            case 109: {
                int32_t i_v27 = i_v4;
                int32_t i_v28 = i_v17 + 2; // 0x10fb8
                i_v20 = i_v27;
                i_v21 = i_v18;
                i_v22 = i_v16;
                i_v23 = i_v15;
                i_v24 = i_v14;
                i_v25 = i_v13;
                if (i_v28 < i_a1) {
                    i_v20 = i_v27;
                    i_v21 = i_v18;
                    i_v22 = i_v16;
                    i_v23 = i_v15;
                    i_v24 = i_v14;
                    i_v25 = *(int32_t *)(4 * i_v28 + i_a2);
                }
                // branch (via goto) -> 0x10e38
                goto lab_0x10e38;
            }
            case 97: {
                // 0x10f88
                i_v20 = i_v17;
                i_v21 = 1;
                i_v22 = i_v16;
                i_v23 = i_v15;
                i_v24 = i_v14;
                i_v25 = i_v13;
                // branch (via goto) -> 0x10e38
                goto lab_0x10e38;
            }
            default: {
                // 0x10fc8
                fprintf(p_g6, "Error: Unsupported option \"%s\"!\n",
                        (char *)i_v12);
                function_11bac();
                // UNREACHABLE
            }
            }
            // 0x10e48
            i_v5 = *(int32_t *)(4 * i_v26 + i_a2);
            i_v4 = i_v26;
            if (*(char *)i_v5 != 45) {
                goto lab_0x10e58_2;
            }
        }
        // 0x10fc8
        fprintf(p_g6, "Error: Unsupported option \"%s\"!\n", (char *)i_v12);
        function_11bac();
        // UNREACHABLE
    }
    goto lab_0x10e60;
lab_0x10e58_2:
    // 0x10e58
    if (i_v3 != 0) {
        // 0x11008
        fprintf(p_g6, "i2cset version %s\n", "4.1");
        exit(0);
        // UNREACHABLE
    }
    goto lab_0x10e60;
lab_0x11144:;
    // 0x11144
    int32_t i_v59;                                        // bp-92, 0x10d44
    int32_t i_v31;                                        // 0x10e7c
    int32_t i_v60 = function_11d80(i_v31, &i_v59, 20, 0); // 0x11154
    if (i_v60 < 0) {
        // 0x11328
        exit(1);
        // UNREACHABLE
    }
    // 0x11160
    if (ioctl(i_v60, 1797) < 0) {
        int32_t i_v61 = *__errno_location(); // 0x11acc
        fprintf(p_g6,
                "Error: Could not get the adapter functionality matrix: %s\n",
                strerror(i_v61));
        // 0x11328
        exit(1);
        // UNREACHABLE
    }
    // 0x11174
    int32_t i_v55; // 0x10d44
    uint32_t i_v62 = i_v55;
    int32_t i_v54; // 0x10d44
    int32_t i_v63 = i_v54;
    int32_t i_v53; // 0x10d44
    int32_t i_v64 = i_v53;
    int32_t i_v52; // 0x10d44
    int32_t i_v65 = i_v52;
    int32_t i_v66 = i_v63 - 1; // 0x11174
    i_g9 = i_v66;
    int32_t i_v67; // 0x10d44
    switch (i_v63) {
    case 1: {
        if ((i_v67 & 0x40000) == 0) {
            // 0x113cc
            fprintf(p_g6, "Error: Adapter does not have %s capability\n",
                    "SMBus send byte");
            // 0x11328
            exit(1);
            // UNREACHABLE
        }
        // break -> 0x111e0
        break;
    }
    case 2: {
        if ((i_v67 & 0x100000) == 0) {
            // 0x1139c
            fprintf(p_g6, "Error: Adapter does not have %s capability\n",
                    "SMBus write byte");
            // 0x11328
            exit(1);
            // UNREACHABLE
        }
        // break -> 0x111e0
        break;
    }
    case 3: {
        if ((i_v67 & 0x400000) == 0) {
            // 0x1136c
            fprintf(p_g6, "Error: Adapter does not have %s capability\n",
                    "SMBus write word");
            // 0x11328
            exit(1);
            // UNREACHABLE
        }
        // break -> 0x111e0
        break;
    }
    case 8: {
        if ((i_v67 & 0x8000000) == 0) {
            // 0x11308
            fprintf(p_g6, "Error: Adapter does not have %s capability\n",
                    "I2C block write");
            // 0x11328
            exit(1);
            // UNREACHABLE
        }
        // break -> 0x111e0
        break;
    }
    case 5: {
        if ((i_v67 & 0x2000000) == 0) {
            // 0x1133c
            fprintf(p_g6, "Error: Adapter does not have %s capability\n",
                    "SMBus block write");
            // 0x11328
            exit(1);
            // UNREACHABLE
        }
        // break -> 0x111e0
        break;
    }
    }
    // 0x111e0
    int32_t i_v32; // 0x10e9c
    if (function_125ec(i_v60, i_v32, i_v8) != 0) {
        // 0x11328
        exit(1);
        // UNREACHABLE
    }
    int32_t i_v68;  // bp-72, 0x10d44
    uint32_t i_v35; // 0x10ec4
    if (i_v9 == 0) {
        // 0x11888
        fwrite((int32_t *)"WARNING! This program can confuse your I2C bus, "
                          "cause data loss and worse!\n",
               1, 75, p_g6);
        uint32_t i_v69 = i_v32 - 80; // 0x118ac
        int32_t i_v70 = 0;           // 0x118b8
        if (i_v69 >= 7 != i_v69 != 7) {
            // 0x118bc
            fwrite((int32_t *)"DANGEROUS! Writing to a serial EEPROM on a "
                              "memory DIMM\nmay render your memory USELESS and "
                              "make your system UNBOOTABLE!\n",
                   1, 119, p_g6);
            i_v70 = 1;
        }
        // 0x118d8
        fprintf(p_g6,
                "I will write to device file %s, chip address 0x%02x, data "
                "address\n0x%02x, ",
                &i_v59, i_v32, i_v35);
        if (i_v63 == 1) {
            // 0x11a70
            fwrite((int32_t *)"no data.\n", 1, 9, p_g6);
        } else {
            // 0x118fc
            switch (i_v63) {
            case 8: {
            }
            case 5: {
                // 0x119ec
                fwrite((int32_t *)"data", 1, 4, p_g6);
                struct _IO_FILE *p_v71 = p_g6; // 0x11a3c
                if (i_v62 != 0) {
                    int32_t i_v72 = 0; // 0x11a2c
                    unsigned char i_v73 =
                        *(char *)(i_v72 + (int32_t)&i_v68); // 0x11a28
                    i_v72++;
                    fprintf(p_g6, " 0x%02x", (int32_t)i_v73);
                    struct _IO_FILE *p_v74 = p_g6; // 0x11a38
                    p_v71 = p_v74;
                    while (i_v72 != i_v62) {
                        // 0x11a20
                        i_v73 = *(char *)(i_v72 + (int32_t)&i_v68);
                        i_v72++;
                        fprintf(p_v74, " 0x%02x", (int32_t)i_v73);
                        p_v74 = p_g6;
                        p_v71 = p_v74;
                    }
                }
                int32_t i_v75 = i_v63 == 5 ? (int32_t) "smbus block"
                                           : (int32_t) "i2c block";
                fprintf(p_v71, ", mode %s.\n", (char *)i_v75);
                // break -> 0x11980
                break;
            }
            default: {
                int32_t i_v76 =
                    i_v63 == 2 ? (int32_t) "byte" : (int32_t) "word";
                int32_t i_v77 =
                    i_v65 == 0 ? (int32_t)&p_g3 : (int32_t) " (masked)";
                fprintf(p_g6, "data 0x%02x%s, mode %s.\n", i_v64, (char *)i_v77,
                        (char *)i_v76);
                // break -> 0x11980
                break;
            }
            }
        }
        int32_t i_v78 = i_v70 == 0 ? (int32_t) "Y/n" : (int32_t) "y/N";
        fprintf(p_g6, "Continue? [%s] ", (char *)i_v78);
        fflush(p_g6);
        if (function_12660(i_v70 ^ 1) == 0) {
            // 0x119cc
            fwrite((int32_t *)"Aborting on user request.\n", 1, 26, p_g6);
            exit(0);
            // UNREACHABLE
        }
    }
    int32_t i_v79 = i_v64; // 0x11208
    if (i_v65 != 0) {
        int32_t i_v80; // 0x10d44
        if (i_v63 == 1) {
            // 0x1187c
            i_v80 = i2c_smbus_read_byte(i_v60);
        } else {
            uint32_t i_v81 = i_v35 % 256;
            if (i_v63 == 3) {
                // 0x1121c
                i_v80 = i2c_smbus_read_word_data(i_v60, i_v81);
            } else {
                // 0x1186c
                i_v80 = i2c_smbus_read_byte_data(i_v60, i_v81);
            }
        }
        int32_t i_v82 = i_v80;
        if (i_v82 < 0) {
            // 0x11844
            fwrite((int32_t *)"Error: Failed to read old value\n", 1, 32, p_g6);
            exit(1);
            // UNREACHABLE
        }
        int32_t i_v83 = (i_v82 ^ i_v64) & i_v65 ^ i_v82; // 0x11240
        i_v79 = i_v83;
        if (i_v9 == 0) {
            int32_t i_v84 = i_v63 == 3 ? 4 : 2;
            fprintf(p_g6,
                    "Old value 0x%0*x, write mask 0x%0*x: Will write 0x%0*x to "
                    "register 0x%02x\n",
                    i_v84, i_v82, i_v84, i_v65, i_v84, i_v83, i_v35);
            fwrite((int32_t *)"Continue? [Y/n] ", 1, 16, p_g6);
            fflush(p_g6);
            i_v79 = i_v83;
            if (function_12660(1) == 0) {
                // 0x11824
                fwrite((int32_t *)"Aborting on user request.\n", 1, 26, p_g6);
                exit(0);
                // UNREACHABLE
            }
        }
    }
    int32_t i_v85 = i_v79;
    uint32_t i_v86 = i_v35 % 256; // 0x112cc
    i_g10 = i_v66;
    int32_t i_v87; // 0x10d44
    switch (i_v63) {
    case 1: {
        // 0x116d4
        i_v87 = i2c_smbus_write_byte(i_v60, i_v86);
        // break -> 0x11654
        break;
    }
    case 8: {
        // 0x11a8c
        i_v87 =
            i2c_smbus_write_i2c_block_data(i_v60, i_v86, i_v62 % 256, &i_v68);
        // break -> 0x11654
        break;
    }
    case 3: {
        // 0x11644
        i_v87 = i2c_smbus_write_word_data(i_v60, i_v86, i_v85 % 0x10000, i_v66);
        // break -> 0x11654
        break;
    }
    case 5: {
        // 0x11aa4
        i_v87 = i2c_smbus_write_block_data(i_v60, i_v86, i_v62 % 256, &i_v68);
        // break -> 0x11654
        break;
    }
    default: {
        // 0x117cc
        i_v87 = i2c_smbus_write_byte_data(i_v60, i_v86, i_v85 % 256, i_v66);
        // break -> 0x11654
        break;
    }
    }
    // 0x11654
    if (i_v87 < 0) {
        // 0x1179c
        fwrite((int32_t *)"Error: Write failed\n", 1, 20, p_g6);
        close(i_v60);
        exit(1);
        // UNREACHABLE
    }
    if (i_v10 == 0) {
        // 0x1173c
        close(i_v60);
        exit(0);
        // UNREACHABLE
    }
    int32_t i_v88; // 0x10d44
    int32_t i_v89; // 0x10d44
    switch (i_v63) {
    case 1: {
        // 0x11728
        i_v88 = i_v35;
        i_v89 = i2c_smbus_read_byte(i_v60);
        // break -> 0x11690
        break;
    }
    case 3: {
        // 0x11680
        i_v88 = i_v85;
        i_v89 = i2c_smbus_read_word_data(i_v60, i_v86);
        // break -> 0x11690
        break;
    }
    default: {
        // 0x11714
        i_v88 = i_v85;
        i_v89 = i2c_smbus_read_byte_data(i_v60, i_v86);
        // break -> 0x11690
        break;
    }
    }
    int32_t i_v90 = i_v89;
    close(i_v60);
    if (i_v90 < 0) {
        // 0x11704
        puts("Warning - readback failed");
        // 0x116cc
        exit(0);
        // UNREACHABLE
    }
    int32_t i_v91 = i_v88;
    int32_t i_v92 = i_v63 == 3 ? 4 : 2;
    if (i_v90 == i_v91) {
        // 0x116e4
        printf("Value 0x%0*x written, readback matched\n", i_v92, i_v91);
    } else {
        // 0x116a8
        printf("Warning - data mismatch - wrote 0x%0*x, read back 0x%0*x\n",
               i_v92, i_v91, i_v92, i_v90);
    }
    // 0x116cc
    exit(0);
    // UNREACHABLE
lab_0x10e60:
    // 0x10e60
    if (i_v7 + 3 >= i_a1) {
        // 0x11004
        function_11bac();
        // UNREACHABLE
    }
    int32_t i_v29 = 4 * i_v7;     // 0x10e6c
    int32_t i_v30 = i_v29 + i_v1; // 0x10e74
    i_v31 = function_12498(*(int32_t *)i_v30);
    if (i_v31 < 0) {
        // 0x11004
        function_11bac();
        // UNREACHABLE
    }
    // 0x10e8c
    i_v32 = function_11cc8(*(int32_t *)(i_v30 + 4), i_v6);
    if (i_v32 < 0) {
        // 0x11004
        function_11bac();
        // UNREACHABLE
    }
    int32_t i_v33 = i_a2 + 12 + i_v29; // 0x10eb4
    char *p_v34;                       // bp-100, 0x10d44
    i_v35 = strtol((char *)*(int32_t *)i_v33, &p_v34, 0);
    if (*p_v34 != 0) {
        // 0x10fe4
        fwrite((int32_t *)"Error: Data address invalid!\n", 1, 29, p_g6);
        // 0x11004
        function_11bac();
        // UNREACHABLE
    }
    if (i_v35 >= 255 == (i_v35 != 255)) {
        // 0x10fe4
        fwrite((int32_t *)"Error: Data address invalid!\n", 1, 29, p_g6);
        // 0x11004
        function_11bac();
        // UNREACHABLE
    }
    int32_t i_v36 = -1; // 0x10eec
    int32_t i_v37 = 1;  // 0x10eec
    char *p_v38;        // 0x10d44
    int32_t i_v39;      // 0x10d44
    int32_t i_v40;      // 0x10d44
    int32_t i_v41;      // 0x10d44
    int32_t i_v42;      // 0x10ef0
    if (i_v7 + 4 == i_a1) {
        goto lab_0x11058;
    } else {
        // 0x10ef0
        i_v42 = i_v7 + 5;
        if (i_v42 == i_a1) {
            char *p_v43 = (char *)*(int32_t *)(i_v30 + 12);
            p_v38 = p_v43;
            i_v39 = 2;
            if (*p_v43 == 99) {
                // 0x11118
                i_v36 = -1;
                i_v37 = 1;
                p_v38 = p_v43;
                i_v39 = 2;
                int32_t i_v44; // 0x11108
                switch (*(char *)(i_v44 + 1)) {
                case 0: {
                    goto lab_0x11058;
                }
                case 112: {
                    // 0x114c4
                    i_v36 = -1;
                    i_v37 = 1;
                    p_v38 = p_v43;
                    i_v39 = 2;
                    if (*(char *)(i_v44 + 2) == 0) {
                        goto lab_0x11058;
                    } else {
                        goto lab_0x11430;
                    }
                }
                default: {
                    goto lab_0x11430;
                }
                }
            } else {
                goto lab_0x11430;
            }
        } else {
            int32_t i_v45 = *(int32_t *)(4 * i_a1 - 4 + i_a2); // 0x10f04
            char *p_v46 = (char *)i_v45;                       // 0x10f0c
            uint32_t i_v47 = strlen(p_v46);                    // 0x10f0c
            if (i_v47 >= 2 == (i_v47 != 2)) {
                // 0x110e4
                fprintf(p_g6, "Error: Invalid mode '%s'!\n", p_v46);
                function_11bac();
                // UNREACHABLE
            }
            if (i_v47 == 2) {
                // 0x110b8
                if (*(char *)(i_v45 + 1) != 112) {
                    // 0x110e4
                    fprintf(p_g6, "Error: Invalid mode '%s'!\n", p_v46);
                    function_11bac();
                    // UNREACHABLE
                }
                unsigned char i_v48 = *p_v46; // 0x110c4
                if (i_v48 == 105) {
                    // 0x1152c
                    fwrite((int32_t *)"Error: PEC not supported for I2C block "
                                      "writes!\n",
                           1, 47, p_g6);
                    function_11bac();
                    // UNREACHABLE
                }
                if (i_v48 < 105) {
                    // 0x11638
                    i_v40 = 2;
                    if (i_v48 != 98) {
                    lab_0x110e4:
                        // 0x110e4
                        fprintf(p_g6, "Error: Invalid mode '%s'!\n", p_v46);
                        function_11bac();
                        // UNREACHABLE
                    }
                    goto lab_0x10f58;
                } else {
                    // 0x110d4
                    i_v40 = 3;
                    i_v41 = 5;
                    switch (i_v48) {
                    case 115: {
                        goto lab_0x114f4;
                    }
                    case 119: {
                        goto lab_0x10f58;
                    }
                    default: {
                        goto lab_0x110e4;
                    }
                    }
                }
            } else {
                unsigned char i_v49 = *p_v46; // 0x10f1c
                if (i_v49 == 105) {
                    // 0x11520
                    i_v41 = 8;
                    if (*(char *)(i_v45 + 1) == 112) {
                        // 0x1152c
                        fwrite((int32_t *)"Error: PEC not supported for I2C "
                                          "block writes!\n",
                               1, 47, p_g6);
                        function_11bac();
                        // UNREACHABLE
                    }
                    goto lab_0x114f4;
                } else {
                    if (i_v49 < 105) {
                        // 0x11488
                        i_v40 = 2;
                        if (i_v49 != 98) {
                            // 0x110e4
                            fprintf(p_g6, "Error: Invalid mode '%s'!\n", p_v46);
                            function_11bac();
                            // UNREACHABLE
                        }
                        goto lab_0x10f58;
                    } else {
                        // 0x10f2c
                        i_v40 = 3;
                        i_v41 = 5;
                        switch (i_v49) {
                        case 115: {
                            goto lab_0x114f4;
                        }
                        case 119: {
                            goto lab_0x10f58;
                        }
                        default: {
                            goto lab_0x110e4;
                        }
                        }
                    }
                }
            }
        }
    }
lab_0x11058:;
    int32_t i_v50 = i_v37;
    int32_t i_v51 = i_v36;
    i_v52 = 0;
    i_v53 = i_v51;
    i_v54 = i_v50;
    i_v55 = 0;
    if (i_v11 != 0) {
        int32_t i_v56 = strtol((char *)i_v11, &p_v34, 0); // 0x1106c
        char i_v57 = *p_v34;                              // 0x11074
        if (i_v57 != 0) {
            // 0x11094
            fwrite((int32_t *)"Error: Data value mask invalid!\n", 1, 32, p_g6);
            function_11bac();
            // UNREACHABLE
        }
        int32_t i_v58 = i_v57 != 0;
        if (i_v50 == 3) {
            // 0x113fc
            i_v52 = i_v56;
            i_v53 = i_v51;
            i_v54 = 3;
            i_v55 = i_v58;
            if (i_v56 >= 0x10000) {
                // 0x11404
                fwrite((int32_t *)"Error: Data value mask out of range!\n", 1,
                       37, p_g6);
                function_11bac();
                // UNREACHABLE
            }
        } else {
            // 0x114ac
            i_v52 = i_v56;
            i_v53 = i_v51;
            i_v54 = i_v50;
            i_v55 = i_v58;
            if (i_v56 > 255) {
                // 0x11404
                fwrite((int32_t *)"Error: Data value mask out of range!\n", 1,
                       37, p_g6);
                function_11bac();
                // UNREACHABLE
            }
        }
    }
    goto lab_0x11144;
lab_0x11430:;
    int32_t i_v93 = strtol(p_v38, &p_v34, 0); // 0x11440
    char i_v94 = *p_v34;                      // 0x11448
    if (i_v94 == 0 ? i_v93 < 0 : i_v94 != 0) {
        // 0x11464
        fwrite((int32_t *)"Error: Data value invalid!\n", 1, 27, p_g6);
        function_11bac();
        // UNREACHABLE
    }
    // 0x11550
    i_v36 = i_v93;
    i_v37 = i_v39;
    if (i_v93 > 0xffff ? i_v39 == 3 : i_v93 == 0x10000) {
        // 0x11578
        fwrite((int32_t *)"Error: Data value out of range!\n", 1, 32, p_g6);
        function_11bac();
        // UNREACHABLE
    }
    goto lab_0x11058;
lab_0x10f58:
    if (i_v7 + 6 != i_a1) {
        // 0x10f64
        fwrite((int32_t *)"Error: Too many arguments!\n", 1, 27, p_g6);
        function_11bac();
        // UNREACHABLE
    }
    // 0x10f58
    p_v38 = (char *)*(int32_t *)(i_v30 + 12);
    i_v39 = i_v40;
    goto lab_0x11430;
lab_0x114f4:
    if (i_v11 != 0) {
        // 0x114fc
        fwrite((int32_t *)"Error: Mask not supported for block writes!\n", 1,
               44, p_g6);
        function_11bac();
        // UNREACHABLE
    }
    if (i_v7 + 37 < i_a1) {
        // 0x10f64
        fwrite((int32_t *)"Error: Too many arguments!\n", 1, 27, p_g6);
        function_11bac();
        // UNREACHABLE
    }
    int32_t i_v95 = i_v41;
    i_v52 = 0;
    i_v53 = -1;
    i_v54 = i_v95;
    i_v55 = 0;
    switch ((int4_t)i_v95) {
    case 5: {
    }
    case -8: {
        // 0x115bc
        i_v52 = 0;
        i_v53 = -1;
        i_v54 = i_v95;
        i_v55 = 0;
        if (i_v42 < i_a1) {
            int32_t i_v96 = 0;     // 0x11604
            int32_t i_v97 = i_v33; // 0x115d0
            i_v97 += 4;
            int32_t i_v98 =
                strtol((char *)*(int32_t *)i_v97, &p_v34, 0); // 0x115d4
            char i_v99 = *p_v34;                              // 0x115dc
            while (!((i_v99 == 0 ? i_v98 < 0 : i_v99 != 0))) {
                if (i_v98 > 255) {
                    // 0x11578
                    fwrite((int32_t *)"Error: Data value out of range!\n", 1,
                           32, p_g6);
                    function_11bac();
                    // UNREACHABLE
                }
                // 0x115fc
                *(char *)(i_v96 + (int32_t)&i_v68) = (char)i_v98;
                i_v96++;
                i_v52 = 0;
                i_v53 = -1;
                i_v54 = i_v95;
                i_v55 = i_v96;
                if (i_v96 + i_v42 >= i_a1) {
                    goto lab_0x11144;
                }
                i_v97 += 4;
                i_v98 = strtol((char *)*(int32_t *)i_v97, &p_v34, 0);
                i_v99 = *p_v34;
            }
            // 0x11464
            fwrite((int32_t *)"Error: Data value invalid!\n", 1, 27, p_g6);
            function_11bac();
            // UNREACHABLE
        }
        // break -> 0x11144
        break;
    }
    }
    goto lab_0x11144;
}

// Address range: 0x11aec - 0x11b10
int32_t entry_point(int32_t i_a1, int32_t i_a2) {
    // 0x11aec
    int32_t i_v1; // 0x11aec
    __libc_start_main(0x10d44, i_a2, (char **)&i_v1, (void (*)())0x12701,
                      (void (*)())0x10d44, (void (*)())i_a1);
    abort();
    // UNREACHABLE
}

// Address range: 0x11b10 - 0x11b14
int32_t function_11b10(int32_t i_a1) {
    // 0x11b10
    return i_a1;
}

// Address range: 0x11b1c - 0x11b38
int32_t function_11b1c(void) {
    int32_t i_v1 =
        *(int32_t *)((int32_t)&i_g1 + (int32_t)&i_g2 + 200); // 0x11b28
    if (i_v1 == 0) {
        int32_t i_v2; // 0x11b1c
        return i_v2;
    }
    // 0x11b34
    __gmon_start__();
    return &i_g11;
}

// Address range: 0x11b40 - 0x11b94
int32_t function_11b40(int32_t i_a1, int32_t i_a2, int32_t i_a3, char i_a4) {
    // 0x11b40
    int32_t i_v1; // 0x11b40
    int32_t i_v2 = i_v1;
    bool i_v3; // 0x11b40
    if (i_v3) {
        return i_a1;
    }
    bool i_v4; // 0x11b40
    if (!i_v3) {
        int32_t i_v5 = 0x100001 * i_v2 & -1 - 0x400000 * i_v2; // 0x11b78
        i_v4 = i_v5 < 0;
        if (i_v5 == 0) {
            return unknown_240();
        }
    }
    // 0x11b88
    if (i_v4 != i_v3) {
        __asm_svclt(0x4770);
    }
    float64_t f_v6; // 0x11b40
    __asm_vqrshl_s8(f_v6, f_v6);
    return i_a1;
}

// Address range: 0x11b94 - 0x11ba8
int32_t function_11b94(int32_t i_a1) {
    // 0x11b94
    int32_t i_v1;                                    // 0x11b94
    char *p_v2 = (char *)(0x80000 * i_v1 | 0x20000); // 0x11b9a
    int32_t i_v3;                                    // 0x11b94
    if (*p_v2 == 0) {
        int32_t i_v4 = function_11b40(i_v1, i_v1, i_v1, 0); // 0x11b9e
        *p_v2 = 1;
        i_v3 = i_v4;
    }
    // 0x11ba6
    return i_v3;
}

// Address range: 0x11ba8 - 0x11baa
int32_t function_11ba8(void) {
    // 0x11ba8
    int32_t i_v1; // 0x11ba8
    return i_v1;
}

// Address range: 0x11bac - 0x11bd8
int32_t function_11bac(void) {
    // 0x11bac
    fwrite(
        (int32_t *)"Usage: i2cset [-f] [-y] [-m MASK] [-r] [-a] I2CBUS "
                   "CHIP-ADDRESS DATA-ADDRESS [VALUE] ... [MODE]\n  I2CBUS is "
                   "an integer or an I2C bus name\n  ADDRESS is an integer "
                   "(0x03 - 0x77, or 0x00 - 0x7f if -a is given)\n  MODE is "
                   "one of:\n    c (byte, no value)\n    b (byte data, "
                   "default)\n    w (word data)\n    i (I2C block data)\n    s "
                   "(SMBus block data)\n    Append p for SMBus PEC\n",
        1, 368, p_g6);
    exit(1);
    // UNREACHABLE
}

// Address range: 0x11bd8 - 0x11c48
int32_t function_11bd8(int32_t i_a1) {
    int32_t i_v1 = strlen((char *)i_a1); // 0x11be0
    if (i_v1 == 0) {
        // 0x11c30
        return 1;
    }
    int32_t i_v2 = i_v1 - 1;
    int32_t i_v3 = i_v2 + i_a1;
    char *p_v4 = (char *)i_v3;
    char i_v5 = *p_v4; // 0x11bec
    int32_t i_v6;      // 0x11bd8
    int32_t i_v7;      // 0x11bd8
    int32_t i_v8;      // 0x11bd8
    char i_v9;         // 0x11bd8
    int32_t i_v10;     // 0x11c24
    char *p_v11;       // 0x11bd8
    switch (i_v5) {
    case 32: {
    }
    case 10: {
        // 0x11c20
        int32_t i_v12; // 0x11bd8
        i_v9 = i_v5 == 10 | i_v5 == 32 ? 0 : (char)i_v12;
        *p_v4 = i_v9;
        i_v6 = i_v3;
        if (i_v2 == 0) {
            // 0x11c30
            return 1;
        }
        i_v7 = i_v2;
        while (true) {
        lab_0x11c0c:
            // 0x11c0c
            i_v8 = i_v7;
            i_v10 = i_v6 - 1;
            p_v11 = (char *)i_v10;
            switch (*p_v11) {
            case 32: {
                goto lab_0x11c20;
            }
            case 10: {
                goto lab_0x11c20;
            }
            default: {
                return i_v8 + 1;
            }
            }
        }
    }
    default: {
        // 0x11c40
        return i_v1 + 1;
    }
    }
    // 0x11c38
    return i_v8 + 1;
lab_0x11c20:;
    int32_t i_v13 = i_v8 - 1; // 0x11c20
    *p_v11 = i_v9;
    i_v6 = i_v10;
    i_v7 = i_v13;
    if (i_v13 == 0) {
        // 0x11c30
        return 1;
    }
    goto lab_0x11c0c;
}

// Address range: 0x11c48 - 0x11c80
int32_t function_11c48(int32_t i_a1) {
    int32_t i_v1 = *(int32_t *)(i_a1 + 4); // 0x11c50
    int32_t i_v2 = i_a1;                   // 0x11c58
    if (i_v1 == 0) {
        // 0x11c74
        free((int32_t *)i_a1);
        return &i_g11;
    }
    free((int32_t *)i_v1);
    int32_t i_v3 = *(int32_t *)(i_v2 + 20); // 0x11c68
    i_v2 += 16;
    while (i_v3 != 0) {
        // 0x11c60
        free((int32_t *)i_v3);
        i_v3 = *(int32_t *)(i_v2 + 20);
        i_v2 += 16;
    }
    // 0x11c74
    free((int32_t *)i_a1);
    return &i_g11;
}

// Address range: 0x11c80 - 0x11cc8
int32_t function_11c80(int32_t i_a1, int32_t i_a2) {
    int32_t i_v1 = 16 * i_a2;                             // 0x11c80
    int32_t *p_v2 = realloc((int32_t *)i_a1, i_v1 + 128); // 0x11c94
    int32_t i_v3 = (int32_t)p_v2;                         // 0x11c94
    if (p_v2 == NULL) {
        // 0x11cbc
        function_11c48(i_a1);
    } else {
        // 0x11ca0
        memset((int32_t *)(i_v1 + i_v3), 0, 128);
    }
    // 0x11cb4
    return i_v3;
}

// Address range: 0x11cc8 - 0x11d80
int32_t function_11cc8(int32_t i_a1, int32_t i_a2) {
    // 0x11cc8
    char *p_v1;                                    // bp-20, 0x11cc8
    int32_t i_v2 = strtol((char *)i_a1, &p_v1, 0); // 0x11ce0
    if ((char)i_v2 == 0 | *p_v1 != 0) {
        // 0x11d38
        fwrite((int32_t *)"Error: Chip address is not a number!\n", 1, 37,
               p_g6);
        // 0x11d30
        return -1;
    }
    int32_t i_v3 = i_a2 == 0 ? 3 : 0;
    int32_t i_v4 = i_a2 == 0 ? 119 : 127;
    int32_t i_v5 = i_v2; // 0x11d2c
    if (i_v3 > i_v2 || i_v4 < i_v2) {
        // 0x11d60
        fprintf(p_g6, "Error: Chip address out of range (0x%02lx-0x%02lx)!\n",
                i_v3, i_v4);
        i_v5 = -2;
    }
    // 0x11d30
    return i_v5;
}

// Address range: 0x11d80 - 0x11eb0
int32_t function_11d80(int32_t i_a1, int32_t *p_a2, int32_t i_a3,
                       int32_t i_a4) {
    // 0x11d80
    snprintf((char *)p_a2, i_a3, "/dev/i2c/%d", i_a1);
    *(char *)(i_a3 - 1 + (int32_t)p_a2) = 0;
    int32_t i_v1 = open64((char *)p_a2, 2); // 0x11dc4
    if (i_v1 >= 0) {
        // 0x11dd0
        return i_v1;
    }
    int32_t i_v2 = *__errno_location(); // 0x11de0
    int32_t i_v3 = i_v1;                // 0x11d80
    switch (i_v2) {
    case 20: {
    }
    case 2: {
        // 0x11e88
        sprintf((char *)p_a2, "/dev/i2c-%d", i_a1);
        i_v3 = open64((char *)p_a2, 2);
        // break -> 0x11dd0
        break;
    }
    }
    // 0x11dd0
    return i_v3;
}

// Address range: 0x11eb0 - 0x12498
int32_t function_11eb0(void) {
    // 0x11eb0
    int32_t i_v1; // 0x11eb0
    uint32_t i_v2 = i_v1;
    int32_t *p_v3 = calloc(8, 16); // 0x11ec0
    int32_t i_v4 = (int32_t)p_v3;  // 0x11ec0
    if (p_v3 == NULL) {
        // 0x1201c
        return i_v4;
    }
    struct _IO_FILE *p_v5 = fopen64("/proc/bus/i2c", "r"); // 0x11edc
    struct dirent64 *p_v6;                                 // 0x11eb0
    int32_t i_v7;                                          // 0x11eb0
    int32_t i_v8;                                          // 0x11eb0
    int32_t i_v9;                                          // 0x11eb0
    int32_t i_v10;                                         // 0x11eb0
    int32_t i_v11;                                         // bp-296, 0x11eb0
    int32_t i_v12;                                         // bp-552, 0x11eb0
    struct __dirstream *p_v13;                             // 0x1210c
    if (p_v5 == NULL) {
        struct _IO_FILE *p_v14 = fopen64("/proc/mounts", "r"); // 0x12050
        if (p_v14 == NULL) {
            // 0x1201c
            return i_v4;
        }
        while (fgets((char *)&i_v11, 255, p_v14) != NULL) {
            // 0x12070
            int32_t i_v15; // bp-808, 0x11eb0
            sscanf((char *)&i_v11, "%*[^ ] %[^ ] %[^ ] %*s\n", &i_v12, &i_v15);
            if (strcasecmp((char *)&i_v15, "sysfs") == 0) {
                // 0x120bc
                fclose(p_v14);
                int32_t i_v16 =
                    strlen((char *)&i_v12) + (int32_t)&i_v12; // 0x120e0
                *(int32_t *)i_v16 = 0x616c632f;
                *(int32_t *)(i_v16 + 4) = 0x692f7373;
                *(int32_t *)(i_v16 + 8) = 0x642d6332;
                *(int16_t *)(i_v16 + 12) = 0x7665;
                *(char *)(i_v16 + 14) = 0;
                p_v13 = opendir((char *)&i_v12);
                i_v7 = i_v4;
                if (p_v13 == NULL) {
                    return i_v7;
                } else {
                    struct dirent64 *p_v17 = readdir64(p_v13); // 0x12138
                    i_v9 = i_v4;
                    if (p_v17 == NULL) {
                        goto lab_0x12284;
                    } else {
                        // 0x12144
                        p_v6 = p_v17;
                        i_v8 = i_v4;
                        i_v10 = 0;
                        goto lab_0x12144_2;
                    }
                }
            }
        }
        // 0x120b0
        fclose(p_v14);
        // 0x1201c
        return i_v4;
    }
    // 0x11fec
    int32_t i_v18;                                  // bp-928, 0x11eb0
    char *p_v19 = fgets((char *)&i_v18, 120, p_v5); // 0x11ffc
    int32_t i_v20 = 1;                              // 0x12010
    int32_t i_v21 = i_v4;                           // 0x12010
    int32_t i_v22 = 0;                              // 0x12010
    if (p_v19 == NULL) {
        // 0x12014
        fclose(p_v5);
        // 0x1201c
        return i_v4;
    }
    int32_t i_v23; // 0x11eb0
    while (true) {
        int32_t i_v24 = i_v21;
        uint32_t i_v25 = i_v20;
        char *p_v26 = strrchr((char *)&i_v18, 9); // 0x11f08
        *p_v26 = 0;
        char *p_v27 = strrchr((char *)&i_v18, 9); // 0x11f28
        *p_v27 = 0;
        char *p_v28 = strrchr((char *)&i_v18, 9); // 0x11f48
        *p_v28 = 0;
        sscanf((char *)&i_v18, "i2c-%d", &i_v11);
        int32_t i_v29 = i_v24; // 0x11f84
        if (i_v25 % 8 == 0) {
            // 0x11f88
            i_v29 = function_11c80(i_v24, i_v25);
            i_v7 = 0;
            if (i_v29 == 0) {
                // break -> 0x1201c
                break;
            }
        }
        int32_t i_v30 = (int32_t)p_v27 + 1; // 0x11f2c
        int32_t i_v31 = (int32_t)p_v28 + 1; // 0x11f4c
        int32_t i_v32 = i_v31 + i_v30;      // 0x11f68
        i_v21 = i_v29;
        int32_t *p_v33 = malloc((i_v32 >> 31) + i_v32); // 0x11fa0
        i_v23 = i_v21;
        if (p_v33 == NULL) {
            goto lab_0x12028;
        }
        int32_t i_v34 = i_v21 + i_v22;  // 0x11f98
        int32_t i_v35 = (int32_t)p_v33; // 0x11fa0
        *(int32_t *)i_v34 = i_v11;
        char *p_v36 = strcpy((char *)p_v33, (char *)i_v30); // 0x11fbc
        *(int32_t *)(i_v34 + 4) = (int32_t)p_v36;
        char *p_v37 = strcpy((char *)(i_v30 + i_v35), (char *)i_v31); // 0x11fd0
        *(int32_t *)(i_v34 + 8) = (int32_t)p_v37;
        char *p_v38 = strcpy((char *)(i_v32 + i_v35),
                             (char *)((int32_t)p_v26 + 1)); // 0x11fe4
        *(int32_t *)(i_v34 + 12) = (int32_t)p_v38;
        char *p_v39 = fgets((char *)&i_v18, 120, p_v5); // 0x11ffc
        i_v20 = i_v25 + 1;
        i_v22 += 16;
        int32_t i_v40 = i_v21; // 0x12010
        if (p_v39 == NULL) {
            // 0x12014
            fclose(p_v5);
            // 0x1201c
            return i_v40;
        }
    }
lab_0x1201c:
    // 0x1201c
    return i_v7;
lab_0x12028:
    // 0x12028
    function_11c48(i_v23);
    i_v7 = 0;
    return i_v7;
lab_0x12284:
    // 0x12284
    closedir(p_v13);
    i_v7 = i_v9;
    goto lab_0x1201c;
lab_0x12144_2:;
    struct dirent64 *p_v41 = p_v6; // 0x11eb0
    int32_t i_v42 = i_v10;         // 0x11eb0
    int32_t i_v43 = i_v8;          // 0x11eb0
    goto lab_0x12144_3;
lab_0x12144_3:;
    int32_t i_v44 = i_v43;
    int32_t i_v45 = i_v42;
    int32_t i_v46 = (int32_t)p_v41;
    char *p_v47 = (char *)(i_v46 + 19); // 0x12144
    if (*p_v47 == 46) {
        // 0x12290
        switch (*(char *)(i_v46 + 20)) {
        case 0: {
            goto lab_0x12134_2;
        }
        case 46: {
            // 0x122a4
            if (*(char *)(i_v46 + 21) == 0) {
                goto lab_0x12134_2;
            } else {
                goto lab_0x12150;
            }
        }
        default: {
            goto lab_0x12150;
        }
        }
    } else {
        goto lab_0x12150;
    }
lab_0x12150:;
    // 0x12150
    struct dirent64 *p_v48;    // 0x11eb0
    struct _IO_FILE *p_v49;    // 0x11eb0
    struct __dirstream *p_v50; // 0x12334
    if (snprintf((char *)&i_v11, 255, "%s/%s/name", &i_v12, p_v47) > 254) {
        // 0x122b4
        fprintf(p_g6, "%s: path truncated\n", &i_v11);
        goto lab_0x12134_2;
    } else {
        struct _IO_FILE *p_v51 = fopen64((char *)&i_v11, "r"); // 0x1217c
        p_v49 = p_v51;
        if (p_v51 == NULL) {
            int32_t i_v52 = snprintf((char *)&i_v11, 255, "%s/%s/device/name",
                                     &i_v12, p_v47); // 0x122ec
            if (i_v52 > 254) {
                // 0x122b4
                fprintf(p_g6, "%s: path truncated\n", &i_v11);
                goto lab_0x12134_2;
            } else {
                struct _IO_FILE *p_v53 =
                    fopen64((char *)&i_v11, "r"); // 0x12300
                p_v49 = p_v53;
                if (p_v53 == NULL) {
                    // 0x1230c
                    if (snprintf((char *)&i_v11, 255, "%s/%s/device", &i_v12,
                                 p_v47) > 254) {
                        // 0x122b4
                        fprintf(p_g6, "%s: path truncated\n", &i_v11);
                        goto lab_0x12134_2;
                    } else {
                        // 0x12330
                        p_v50 = opendir((char *)&i_v11);
                        if (p_v50 == NULL) {
                            goto lab_0x12134_2;
                        } else {
                            struct dirent64 *p_v54 =
                                readdir64(p_v50); // 0x12358
                            p_v48 = p_v54;
                            if (p_v54 == NULL) {
                                goto lab_0x12134_2;
                            } else {
                                goto lab_0x12370;
                            }
                        }
                    }
                } else {
                    goto lab_0x12188;
                }
            }
        } else {
            goto lab_0x12188;
        }
    }
lab_0x12134_2:;
    struct dirent64 *p_v55 = readdir64(p_v13); // 0x12138
    p_v6 = p_v55;
    i_v8 = i_v44;
    i_v10 = i_v45;
    i_v9 = i_v44;
    if (p_v55 == NULL) {
        goto lab_0x12284;
    } else {
        goto lab_0x12144_2;
    }
lab_0x12188:;
    char *p_v56 = fgets((char *)&i_v18, 120, p_v49); // 0x1219c
    fclose(p_v49);
    if (p_v56 == NULL) {
        // 0x12478
        fprintf(p_g6, "%s: read error\n", &i_v11);
        goto lab_0x12134_2;
    } else {
        char *p_v57 = strchr((char *)&i_v18, 10); // 0x121c0
        if (p_v57 == NULL) {
            goto lab_dec_label_pc_0x121dc;
        } else {
            *p_v57 = 0;
            goto lab_dec_label_pc_0x121dc;
        }
    }
lab_dec_label_pc_0x121dc:;
    int32_t i_v58; // 0x11eb0
    int32_t i_v59; // bp-956, 0x11eb0
    if (sscanf(p_v47, "i2c-%d", &i_v59) == 0) {
        goto lab_0x12134_2;
    } else {
        int32_t i_v60 = strncmp((char *)&i_v18, "ISA ", 4); // 0x121f8
        i_v58 = 8;
        if (i_v60 == 0) {
            goto lab_0x12208;
        } else {
            // 0x123f8
            int32_t i_v61; // bp-948, 0x11eb0
            int32_t i_v62 = function_11d80(i_v59, &i_v61, 20, 1); // 0x12408
            i_v58 = 32;
            if (i_v62 >= 0) {
                int32_t i_v63 =
                    ioctl(i_v62, 1797) >= 0
                        ? i_v2 % 2 == 0 ? (i_v2 & 0x7e0000) == 0 ? 0 : 24 : 16
                        : 32;
                close(i_v62);
                i_v58 = i_v63;
                goto lab_0x12208;
            } else {
                goto lab_0x12208;
            }
        }
    }
lab_0x12208:;
    int32_t i_v64 = i_v45 + 1; // 0x12208
    int32_t i_v65 = i_v44;     // 0x12210
    if (i_v64 % 8 == 0) {
        int32_t i_v66 = function_11c80(i_v44, i_v64); // 0x12220
        i_v7 = 0;
        i_v65 = i_v66;
        if (i_v66 == 0) {
            goto lab_0x1201c;
        } else {
            goto lab_0x12230;
        }
    } else {
        goto lab_0x12230;
    }
lab_0x12370:;
    int32_t i_v67 = (int32_t)p_v48;
    char *p_v68 = (char *)(i_v67 + 19); // 0x12370
    if (*p_v68 == 46) {
        // 0x123d4
        switch (*(char *)(i_v67 + 20)) {
        case 0: {
            goto lab_0x12354_2;
        }
        case 46: {
            // 0x123e8
            if (*(char *)(i_v67 + 21) == 0) {
                goto lab_0x12354_2;
            } else {
                goto lab_0x12380;
            }
        }
        default: {
            goto lab_0x12380;
        }
        }
    } else {
        goto lab_0x12380;
    }
lab_0x12230:;
    int32_t i_v69 = i_v65 + 16 * i_v45; // 0x1223c
    *(int32_t *)i_v69 = i_v59;
    char *p_v70 = __strdup((char *)&i_v18); // 0x12244
    *(int32_t *)(i_v69 + 4) = (int32_t)p_v70;
    i_v23 = i_v65;
    if (p_v70 == NULL) {
        goto lab_0x12028;
    } else {
        int32_t i_v71 = *(int32_t *)(i_v58 + (int32_t)&x_g4);     // 0x12268
        int32_t i_v72 = *(int32_t *)(i_v58 + (int32_t)&x_g4 + 4); // 0x12270
        *(int32_t *)(i_v69 + 8) = i_v71;
        *(int32_t *)(i_v69 + 12) = i_v72;
        struct dirent64 *p_v73 = readdir64(p_v13); // 0x12278
        p_v41 = p_v73;
        i_v42 = i_v64;
        i_v43 = i_v65;
        i_v9 = i_v65;
        if (p_v73 == NULL) {
            goto lab_0x12284;
        } else {
            goto lab_0x12144_3;
        }
    }
lab_0x12380:
    // 0x12380
    if (strncmp(p_v68, "i2c-", 4) == 0) {
        int32_t i_v74 = snprintf((char *)&i_v11, 255, "%s/%s/device/%s/name",
                                 &i_v12, p_v47, p_v68); // 0x123ac
        if (i_v74 > 254) {
            // 0x12458
            fprintf(p_g6, "%s: path truncated\n", &i_v11);
            goto lab_0x12354_2;
        } else {
            struct _IO_FILE *p_v75 = fopen64((char *)&i_v11, "r"); // 0x123c0
            p_v49 = p_v75;
            if (p_v75 == NULL) {
                goto lab_0x12354_2;
            } else {
                goto lab_0x12188;
            }
        }
    } else {
        goto lab_0x12354_2;
    }
lab_0x12354_2:;
    struct dirent64 *p_v76 = readdir64(p_v50); // 0x12358
    p_v48 = p_v76;
    if (p_v76 == NULL) {
        goto lab_0x12134_2;
    } else {
        goto lab_0x12370;
    }
}

// Address range: 0x12498 - 0x125ec
int32_t function_12498(int32_t i_a1) {
    char *p_v1 = (char *)i_a1;              // 0x124ac
    char *p_v2;                             // bp-28, 0x12498
    int32_t i_v3 = strtoul(p_v1, &p_v2, 0); // 0x124ac
    if (!(((char)i_v3 == 0 | *p_v2 != 0))) {
        int32_t i_v4 = i_v3; // 0x124d4
        if (i_v3 >= 0x100000) {
            // 0x1259c
            fwrite((int32_t *)"Error: I2C bus out of range!\n", 1, 29, p_g6);
            i_v4 = -2;
        }
        // 0x124d8
        return i_v4;
    }
    int32_t i_v5 = function_11eb0(); // 0x124e4
    if (i_v5 == 0) {
        // 0x125c4
        fwrite((int32_t *)"Error: Out of memory!\n", 1, 22, p_g6);
        // 0x124d8
        return -3;
    }
    int32_t i_v6 = *(int32_t *)(i_v5 + 4); // 0x124f0
    int32_t i_v7 = i_v6;                   // 0x12500
    int32_t i_v8 = i_v5;                   // 0x12500
    int32_t i_v9 = -1;                     // 0x12500
    if (i_v6 == 0) {
        goto lab_0x12574;
    lab_0x12574:
        // 0x12574
        fwrite(
            (int32_t *)"Error: I2C bus name doesn't match any bus present!\n",
            1, 51, p_g6);
        // 0x12538
        function_11c48(i_v5);
        return -1;
    }
    while (true) {
        int32_t i_v10 = i_v9;
        int32_t i_v11 = i_v8;
        int32_t i_v12 = i_v10; // 0x12510
        if (strcmp((char *)i_v7, p_v1) == 0) {
            if (i_v10 >= 0) {
                // break -> 0x1254c
                break;
            }
            // 0x1251c
            i_v12 = *(int32_t *)i_v11;
        }
        // 0x12520
        i_v9 = i_v12;
        i_v7 = *(int32_t *)(i_v11 + 20);
        i_v8 = i_v11 + 16;
        if (i_v7 == 0) {
            // 0x12530
            if (i_v9 == -1) {
                goto lab_0x12574;
            } else {
                goto lab_0x12538;
            }
        }
    }
    // 0x1254c
    fwrite((int32_t *)"Error: I2C bus name is not unique!\n", 1, 35, p_g6);
    i_v9 = -4;
lab_0x12538:
    // 0x12538
    function_11c48(i_v5);
    return i_v9;
}

// Address range: 0x125ec - 0x12660
int32_t function_125ec(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    // 0x125ec
    if (ioctl(i_a1, i_a3 == 0 ? 1795 : 1798) >= 0) {
        // 0x12618
        return 0;
    }
    int32_t *p_v1 = __errno_location(); // 0x1262c
    fprintf(p_g6, "Error: Could not set address to 0x%02x: %s\n", i_a2,
            strerror(*p_v1));
    return -*p_v1;
}

// Address range: 0x12660 - 0x12700
int32_t function_12660(int32_t i_a1) {
    // 0x12660
    int32_t i_v1; // bp-20, 0x12660
    if (fgets((char *)&i_v1, 2, p_g7) == NULL) {
        // 0x126dc
        return 0;
    }
    uint32_t i_v2 = i_v1;       // 0x1268c
    uint32_t i_v3 = i_v2 % 256; // 0x1268c
    int32_t i_v4;               // 0x12660
    int32_t i_v5;               // 0x12660
    if (i_v3 == 89) {
        // 0x126f8
        i_v4 = 1;
        goto lab_0x126c4;
    } else {
        char i_v6 = i_v2;
        if (i_v3 < 89) {
            // 0x126e8
            i_v4 = i_a1;
            i_v5 = i_a1;
            switch (i_v6) {
            case 78: {
                // 0x126f0
                i_v4 = 0;
                goto lab_0x126c4;
            }
            case 10: {
                return i_v5;
            }
            default: {
                goto lab_0x126c4;
            }
            }
        } else {
            // 0x1269c
            i_v4 = i_a1;
            switch (i_v6) {
            case 110: {
                // 0x126f0
                i_v4 = 0;
                goto lab_0x126c4;
            }
            case 121: {
                // 0x126f8
                i_v4 = 1;
                goto lab_0x126c4;
            }
            default: {
                goto lab_0x126c4;
            }
            }
        }
    }
lab_0x126c4:
    // 0x126c4
    while (true) {
        uint32_t i_v7 = fgetc(p_g7); // 0x126c8
        i_v5 = 0;
        if (i_v7 == -1) {
            // break -> 0x126dc
            break;
        }
        // 0x126b8
        i_v1 = 0x1000000 * i_v7 / 0x1000000;
        i_v5 = i_v4;
        if (i_v7 % 256 == 10) {
            // break -> 0x126dc
            break;
        }
    }
    // 0x126dc
    return i_v5;
}

// Address range: 0x12700 - 0x12734
int32_t function_12700(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    int32_t i_v1 = function_10af0(i_a1, i_a2, i_a3, i_a4); // 0x12710
    return 0x23f0a - (int32_t)&i_g5 >> 2 == 0 ? i_v1 : i_a1;
}

// Address range: 0x1273c - 0x1273e
int32_t function_1273c(void) {
    // 0x1273c
    int32_t i_v1; // 0x1273c
    return i_v1;
}

// Address range: 0x12740 - 0x12748
int32_t function_12740(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x12740
    return i_a1;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.4.3)
// Detected functions: 68
