//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <errno.h>
#include <fcntl.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stropts.h>
#include <time.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct tm {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    char *e10;
};

// ------------------- Function Prototypes --------------------

int32_t *__errno_location2(void);
int32_t __libc_start_main2(int32_t main, int32_t argc, char **ubp_av,
                           void (*init)(), void (*fini)(), void (*rtld_fini)());
int32_t _IO_getc2(struct _IO_FILE *fp);
int32_t _IO_putc2(int32_t c, struct _IO_FILE *fp);
void abort2(void);
int32_t close2(int32_t fd);
int32_t entry_point(int32_t i_a1, int32_t i_a2);
void exit2(int32_t status);
int32_t fclose2(struct _IO_FILE *stream);
int32_t fflush2(struct _IO_FILE *stream);
char *fgets2(char *s, int32_t n, struct _IO_FILE *stream);
struct _IO_FILE *fopen2(char *filename, char *modes);
int32_t fprintf2(struct _IO_FILE *stream, char *format, ...);
int32_t fread2(int32_t *ptr, int32_t size, int32_t n, struct _IO_FILE *stream);
int32_t function_8744(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
void function_883c(void);
int32_t function_889c(int32_t i_a1, int32_t i_a2);
int32_t function_8b5c(void);
int32_t function_8b80(int32_t i_a1, int32_t i_a2, int32_t i_a3, char i_a4);
int32_t function_8bb8(int32_t *p_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_8bf8(void);
int32_t function_8c20(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_8c54(void);
int32_t function_8d08(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t *p_a4,
                      int32_t i_a5);
int32_t function_8df0(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t *p_a4);
int32_t function_8e8c(int32_t i_a1, int32_t i_a2);
int32_t function_8e9c(int32_t *p_a1, int32_t i_a2);
int32_t function_8f88(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t function_9024(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_91cc(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t function_92a0(int32_t i_a1, int32_t i_a2);
int32_t function_93dc(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t function_9470(int32_t i_a1, int32_t i_a2);
int32_t function_9564(void);
int32_t function_9654(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_96b8(void);
int32_t function_96bc(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t fwrite2(int32_t *ptr, int32_t size, int32_t n, struct _IO_FILE *s);
int32_t ioctl2(int32_t fd, int32_t request, ...);
struct tm *localtime2(int32_t *timer);
int32_t open2(char *file, int32_t oflag, ...);
int32_t printf2(char *format, ...);
void rewind2(struct _IO_FILE *stream);
int32_t strcmp2(char *s1, char *s2);
char *strcpy2(char *dest, char *src);
char *strerror2(int32_t errnum);
int32_t strftime2(char *s, int32_t maxsize, char *format, struct tm *tp);
int32_t strtol2(char *nptr, char **endptr, int32_t base);
int32_t time2(int32_t *timer);
int32_t warn(void);

// --------------------- Global Variables ---------------------

int32_t i_g1 = 0;                            // 0x11b30
struct _IO_FILE *p_g2 = NULL;                // 0x11ca0
struct _IO_FILE *p_g3 = NULL;                // 0x11ca8
struct _IO_FILE *p_g4 = NULL;                // 0x11cac
char *p_g5;                                  // 0x11cb0
int32_t i_g6 = 0;                            // 0x11cb4
int32_t i_g7 = 0;                            // 0x11cb8
int32_t i_g8 = 0;                            // 0x11cbc
int32_t i_g9 = 0;                            // 0x11cf8
int32_t i_g10 = 157;                         // 0x84ac
int32_t i_g11 = 18;                          // 0x84b8
int32_t i_g12 = -0x1cae0000;                 // 0x8b6c
int32_t i_g13 = 0x916c;                      // 0x90b0
int32_t i_g14 = -0x1e4f9eba;                 // 0x967c
void (*p_g15)() = (void (*)()) - 0x1ed000e2; // 0x96b8
int32_t i_g16 = 92;                          // 0x985c
int32_t i_g17 = 124;                         // 0x9860
int32_t i_g18 = 47;                          // 0x9864
int32_t i_g19 = 45;                          // 0x9868
int32_t i_g20;
int32_t i_g21;

// ------- Dynamically Linked Functions Without Header --------

void __gmon_start__(void);
int32_t __libc_start_main(int32_t i_a1, int32_t i_a2, char **p_a3,
                          void (*p_a4)(), void (*p_a5)(), void (*p_a6)());

// ------------------------ Functions -------------------------

// Address range: 0x8744 - 0x8750
int32_t function_8744(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x8744
    return function_8b5c();
}

// Address range: 0x8764 - 0x8770
int32_t strcmp2(char *s1, char *s2) {
    // 0x8764
    return strcmp(s1, s2);
}

// Address range: 0x8770 - 0x877c
int32_t strtol2(char *nptr, char **endptr, int32_t base) {
    // 0x8770
    return strtol(nptr, endptr, base);
}

// Address range: 0x877c - 0x8788
int32_t printf2(char *format, ...) {
    // 0x877c
    return printf(format);
}

// Address range: 0x8788 - 0x8794
struct _IO_FILE *fopen2(char *filename, char *modes) {
    // 0x8788
    return fopen(filename, modes);
}

// Address range: 0x8794 - 0x87a0
int32_t fflush2(struct _IO_FILE *stream) {
    // 0x8794
    return fflush(stream);
}

// Address range: 0x87a0 - 0x87ac
char *fgets2(char *s, int32_t n, struct _IO_FILE *stream) {
    // 0x87a0
    return fgets(s, n, stream);
}

// Address range: 0x87ac - 0x87b8
int32_t time2(int32_t *timer) {
    // 0x87ac
    return time(timer);
}

// Address range: 0x87b8 - 0x87c4
int32_t _IO_getc2(struct _IO_FILE *fp) {
    // 0x87b8
    return _IO_getc(fp);
}

// Address range: 0x87c4 - 0x87d0
void rewind2(struct _IO_FILE *stream) {
    // 0x87c4
    rewind(stream);
}

// Address range: 0x87d0 - 0x87dc
int32_t _IO_putc2(int32_t c, struct _IO_FILE *fp) {
    // 0x87d0
    return _IO_putc(c, fp);
}

// Address range: 0x87dc - 0x87e8
int32_t fwrite2(int32_t *ptr, int32_t size, int32_t n, struct _IO_FILE *s) {
    // 0x87dc
    return fwrite(ptr, size, n, s);
}

// Address range: 0x87e8 - 0x87f4
int32_t ioctl2(int32_t fd, int32_t request, ...) {
    // 0x87e8
    return ioctl(fd, request);
}

// Address range: 0x87f4 - 0x8800
char *strcpy2(char *dest, char *src) {
    // 0x87f4
    return strcpy(dest, src);
}

// Address range: 0x8800 - 0x880c
int32_t fread2(int32_t *ptr, int32_t size, int32_t n, struct _IO_FILE *stream) {
    // 0x8800
    return fread(ptr, size, n, stream);
}

// Address range: 0x880c - 0x8818
int32_t __libc_start_main2(int32_t main, int32_t argc, char **ubp_av,
                           void (*init)(), void (*fini)(),
                           void (*rtld_fini)()) {
    // 0x880c
    return __libc_start_main(main, argc, ubp_av, init, fini, rtld_fini);
}

// Address range: 0x8818 - 0x8824
char *strerror2(int32_t errnum) {
    // 0x8818
    return strerror(errnum);
}

// Address range: 0x8824 - 0x8830
int32_t strftime2(char *s, int32_t maxsize, char *format, struct tm *tp) {
    // 0x8824
    return strftime(s, maxsize, format, tp);
}

// Address range: 0x8830 - 0x883c
struct tm *localtime2(int32_t *timer) {
    // 0x8830
    return localtime(timer);
}

// Address range: 0x883c - 0x8848
void function_883c(void) {
    // 0x883c
    __gmon_start__();
}

// Address range: 0x8848 - 0x8854
int32_t open2(char *file, int32_t oflag, ...) {
    // 0x8848
    return open(file, oflag);
}

// Address range: 0x8854 - 0x8860
void exit2(int32_t status) {
    // 0x8854
    exit(status);
}

// Address range: 0x8860 - 0x886c
int32_t fprintf2(struct _IO_FILE *stream, char *format, ...) {
    // 0x8860
    return fprintf(stream, format);
}

// Address range: 0x886c - 0x8878
int32_t *__errno_location2(void) {
    // 0x886c
    return __errno_location();
}

// Address range: 0x8878 - 0x8884
int32_t fclose2(struct _IO_FILE *stream) {
    // 0x8878
    return fclose(stream);
}

// Address range: 0x8884 - 0x8890
void abort2(void) {
    // 0x8884
    abort();
}

// Address range: 0x8890 - 0x889c
int32_t close2(int32_t fd) {
    // 0x8890
    return close(fd);
}

// Address range: 0x889c - 0x8afc
int32_t function_889c(int32_t i_a1, int32_t i_a2) {
    // 0x889c
    i_g9 = &i_g7;
    int32_t i_v1; // 0x889c
    int32_t i_v2; // 0x889c
    int32_t i_v3; // 0x889c
    int32_t i_v4; // 0x88c0
    char *p_v5;   // 0x88c4
    char i_v6;    // 0x8988
    if (i_a1 < 2) {
        goto lab_0x8910;
    } else {
        // 0x88c0
        i_v4 = *(int32_t *)(i_a2 + 4);
        p_v5 = (char *)i_v4;
        if (*p_v5 == 45) {
            // 0x8988
            i_v6 = *(char *)(i_v4 + 1);
            switch (i_v6) {
            case 114: {
                // 0x8994
                i_v3 = 1;
                if (*(char *)(i_v4 + 2) == 0) {
                    goto lab_0x8910;
                } else {
                    goto lab_0x89a0;
                }
            }
            case 101: {
                // 0x8a74
                i_v3 = 2;
                if (*(char *)(i_v4 + 2) == 0) {
                    goto lab_0x8910;
                } else {
                    goto lab_0x89a0;
                }
            }
            case 119: {
                // 0x8900
                i_v3 = 0;
                if (*(char *)(i_v4 + 2) == 0) {
                    goto lab_0x8910;
                } else {
                    goto lab_0x89a0;
                }
            }
            case 112: {
                // 0x8ae8
                i_v3 = 3;
                if (*(char *)(i_v4 + 2) == 0) {
                    goto lab_0x8910;
                } else {
                    goto lab_0x89a0;
                }
            }
            default: {
                goto lab_0x89a0;
            }
            }
        } else {
            // 0x88d0
            i_v1 = (int32_t) "Error: No action specified !\n";
            i_v2 = 29;
            if (strcmp("-force", p_v5) == 0) {
                goto lab_0x8914;
            } else {
                goto lab_0x8974;
            }
        }
    }
lab_0x8910:
    // 0x8910
    warn();
    int32_t i_v7 = i_v3; // 0x8910
    goto lab_0x8914;
lab_0x8914:
    // 0x8914
    i_v1 = (int32_t) "Error: No i2c address specified !\n";
    i_v2 = 34;
    int32_t i_v8; // bp-72, 0x889c
    if (i_a1 > 4) {
        int32_t i_v9 = 1;
        int32_t i_v10 = i_a2 + 4;          // 0x8924
        int32_t i_v11 = *(int32_t *)i_v10; // 0x8924
        int32_t i_v12;                     // 0x8a4c
        if (*(char *)i_v11 == 45) {
            // 0x8934
            if (*(char *)(i_v11 + 1) == 102) {
                // 0x8940
                if (*(char *)(i_v11 + 2) == 0) {
                    // 0x8a44
                    i_v12 = *(int32_t *)(i_a2 + 4 + 4 * i_v9);
                    strcpy((char *)&i_v8, (char *)i_v12);
                    goto lab_0x8958;
                }
            }
        }
        int32_t i_v13 = i_v9 + 1; // 0x894c
        int32_t i_v14 = i_v10;    // 0x8954
        while (i_v13 != i_a1) {
            // 0x8924
            i_v9 = i_v13;
            i_v10 = i_v14 + 4;
            i_v11 = *(int32_t *)i_v10;
            if (*(char *)i_v11 == 45) {
                // 0x8934
                if (*(char *)(i_v11 + 1) == 102) {
                    // 0x8940
                    if (*(char *)(i_v11 + 2) == 0) {
                        // 0x8a44
                        i_v12 = *(int32_t *)(i_a2 + 4 + 4 * i_v9);
                        strcpy((char *)&i_v8, (char *)i_v12);
                        goto lab_0x8958;
                    }
                }
            }
            // 0x894c
            i_v13 = i_v9 + 1;
            i_v14 = i_v10;
        }
        goto lab_0x8958;
    } else {
        goto lab_0x8974;
    }
lab_0x8974:
    // 0x8974
    fwrite((int32_t *)i_v1, 1, i_v2, p_g2);
    function_8c54();
    exit(1);
    // UNREACHABLE
lab_0x89a0:
    // 0x89a0
    if (strcmp("-force", p_v5) == 0) {
        goto lab_0x8914;
    } else {
        // 0x89b4
        i_v1 = (int32_t) "Error: No action specified !\n";
        i_v2 = 29;
        if (i_v6 == 118) {
            // 0x89bc
            i_v1 = (int32_t) "Error: No action specified !\n";
            i_v2 = 29;
            if (*(char *)(i_v4 + 2) == 0) {
                // 0x89c8
                fwrite((int32_t *)"eepromer v 0.4 (c) Daniel Smolik 2001\n", 1,
                       38, p_g2);
                exit(0);
                // UNREACHABLE
            }
        }
        goto lab_0x8974;
    }
lab_0x8958:
    // 0x8958
    i_v1 = (int32_t) "Error: No device specified !\n";
    i_v2 = 29;
    if (i_v8 % 256 != 0) {
        int32_t i_v15 =
            strtol((char *)*(int32_t *)(i_a2 + 16), NULL, 16); // 0x89f4
        i_v1 = (int32_t) "Error: Bad device address !\n";
        i_v2 = 28;
        if (i_v15 != 0) {
            int32_t i_v16 = function_8e9c(&i_v8, i_v15); // 0x8a08
            if (i_v16 == 0) {
                // 0x8aa4
                fwrite((int32_t *)"Error: Init failed !\n", 1, 21, p_g2);
                exit(1);
                // UNREACHABLE
            }
            switch (i_v7) {
            case 2: {
                // 0x8acc
                function_8f88(i_v16, i_v15, 0x8000);
                // break -> 0x8a34
                break;
            }
            case 3: {
                // 0x8ad8
                function_9564();
                // break -> 0x8a34
                break;
            }
            case 1: {
                // 0x8ac4
                function_9470(i_v16, i_v15);
                // break -> 0x8a34
                break;
            }
            default: {
                // 0x8a30
                function_92a0(i_v16, i_v15);
                // break -> 0x8a34
                break;
            }
            }
            // 0x8a34
            close(i_v16);
            exit(0);
            // UNREACHABLE
        }
    }
    goto lab_0x8974;
}

// Address range: 0x8b20 - 0x8b50
int32_t entry_point(int32_t i_a1, int32_t i_a2) {
    // 0x8b20
    int32_t i_v1; // 0x8b20
    __libc_start_main(0x889c, i_a2, (char **)&i_v1, (void (*)())0x9654,
                      (void (*)()) & p_g15, (void (*)())i_a1);
    abort();
    return &i_g21;
}

// Address range: 0x8b5c - 0x8b78
int32_t function_8b5c(void) {
    int32_t i_v1 =
        *(int32_t *)((int32_t)&i_g12 + (int32_t)&i_g13 + 116); // 0x8b68
    if (i_v1 == 0) {
        int32_t i_v2; // 0x8b5c
        return i_v2;
    }
    // 0x8b74
    __gmon_start__();
    return &i_g21;
}

// Address range: 0x8b80 - 0x8bac
int32_t function_8b80(int32_t i_a1, int32_t i_a2, int32_t i_a3, char i_a4) {
    // 0x8b80
    return 0x11c9c;
}

// Address range: 0x8bb8 - 0x8bec
int32_t function_8bb8(int32_t *p_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x8bb8
    return 0x11c9c;
}

// Address range: 0x8bf8 - 0x8c1c
int32_t function_8bf8(void) {
    // 0x8bf8
    int32_t i_v1; // 0x8bf8
    if (*(char *)&p_g5 != 0) {
        return i_v1;
    }
    int32_t i_v2 = function_8b80(i_v1, i_v1, i_v1, 0); // 0x8c0c
    *(char *)&p_g5 = 1;
    return i_v2;
}

// Address range: 0x8c20 - 0x8c4c
int32_t function_8c20(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x8c20
    return function_8bb8(&i_g1, i_a2, i_a3, i_a4);
}

// Address range: 0x8c54 - 0x8cec
int32_t function_8c54(void) {
    // 0x8c54
    fwrite((int32_t
                *)"Syntax: eepromer [-r|-w|-e|-p]  -f /dev/i2c-X  ADDRESS \n\n",
           1, 57, p_g2);
    fwrite((int32_t *)"  ADDRESS is address of i2c device eg. 0x51\n", 1, 44,
           p_g2);
    struct _IO_FILE *p_v1 = fopen("/proc/bus/i2c", "r"); // 0x8c90
    if (p_v1 == NULL) {
        // 0x8ce4
        return (int32_t)p_v1;
    }
    // 0x8c9c
    fwrite((int32_t *)"  Installed I2C busses:\n", 1, 24, p_g2);
    int32_t i_v2; // bp-116, 0x8c54
    if (fgets((char *)&i_v2, 100, p_v1) == NULL) {
        // 0x8ce4
        return fclose(p_v1);
    }
    fprintf(p_g2, "    %s", &i_v2);
    while (fgets((char *)&i_v2, 100, p_v1) != NULL) {
        // 0x8cb4
        fprintf(p_g2, "    %s", &i_v2);
    }
    // 0x8ce4
    return fclose(p_v1);
}

// Address range: 0x8d08 - 0x8de4
int32_t function_8d08(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t *p_a4,
                      int32_t i_a5) {
    if (i_a5 > 64) {
        // 0x8d9c
        fwrite((int32_t *)"Error: Block too large:\n", 1, 24, p_g2);
    }
    // 0x8d2c
    __asm_ubfx(i_a3, 8, 7);
    int32_t i_v1 = 0; // 0x8d90
    if (ioctl(i_a1, 1799) < 0) {
        // 0x8db8
        fprintf(p_g2, "Error: Transaction failed: %s\n",
                strerror(*__errno_location()));
        i_v1 = 1;
    }
    // 0x8d94
    return i_v1;
}

// Address range: 0x8df0 - 0x8e84
int32_t function_8df0(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t *p_a4) {
    // 0x8df0
    __asm_ubfx(i_a3, 8, 7);
    int32_t i_v1 = ioctl(i_a1, 1799); // 0x8e54
    if (i_v1 < 0) {
        // 0x8e6c
        fprintf(p_g2, "Error: Read error:%d\n", i_v1);
    }
    // 0x8e60
    return i_v1;
}

// Address range: 0x8e8c - 0x8e9c
int32_t function_8e8c(int32_t i_a1, int32_t i_a2) {
    // 0x8e8c
    *(char *)(i_a2 + 1) = (char)i_a1;
    int32_t i_v1 = __asm_ubfx(i_a1, 8, 7); // 0x8e90
    *(char *)i_a2 = (char)i_v1;
    return i_v1;
}

// Address range: 0x8e9c - 0x8f78
int32_t function_8e9c(int32_t *p_a1, int32_t i_a2) {
    int32_t i_v1 = open((char *)p_a1, O_RDWR); // 0x8eb0
    if (i_v1 < 0) {
        // 0x8ef4
        fprintf(p_g2, "Error: Could not open file %s\n", p_a1);
        // 0x8ee8
        return 0;
    }
    // 0x8ebc
    if (ioctl(i_v1, 1797) < 0) {
        int32_t i_v2 = *__errno_location(); // 0x8f1c
        fprintf(p_g2,
                "Error: Could not get the adapter functionality matrix: %s\n",
                strerror(i_v2));
        close(i_v1);
        // 0x8ee8
        return 0;
    }
    int32_t i_v3 = ioctl(i_v1, 1795); // 0x8edc
    int32_t i_v4 = i_v1;              // 0x8ee4
    if (i_v3 < 0) {
        // 0x8f44
        fprintf(p_g2, "Error: Cannot communicate with slave: %s\n",
                strerror(*__errno_location()));
        close(i_v1);
        i_v4 = 0;
    }
    // 0x8ee8
    return i_v4;
}

// Address range: 0x8f88 - 0x901c
int32_t function_8f88(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    // 0x8f88
    int32_t i_v1;         // bp-89, 0x8f88
    int32_t i_v2 = &i_v1; // 0x8fa0
    i_v2++;
    *(char *)i_v2 = 0;
    int32_t i_v3; // bp-25, 0x8f88
    while (i_v2 != (int32_t)&i_v3) {
        // 0x8fa4
        i_v2++;
        *(char *)i_v2 = 0;
    }
    // 0x8fb0
    if (i_a3 < 1) {
        // 0x9014
        return i_a1;
    }
    int32_t i_v4 = 0; // 0x8fcc
    int32_t i_v5;     // bp-88, 0x8f88
    while (function_8d08(i_a1, i_a2, i_v4, &i_v5, 64) == 0) {
        // 0x8fd0
        i_v4 += 64;
        if (i_v4 == (i_a3 + 63 & -64)) {
            // 0x9014
            return 0;
        }
    }
    // 0x9014
    return fwrite((int32_t *)"Block write failed\n", 1, 19, p_g2);
}

// Address range: 0x9024 - 0x91b4
int32_t function_9024(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    int32_t i_v1 = i_g6; // 0x902c
    if (i_v1 > 70) {
        // 0x9170
        i_g6 = 1;
        return i_a1;
    }
    int32_t i_v2 = i_v1 > 70 ? 1 : i_v1;
    i_g20 = i_v2 - 10;
    int32_t i_v3 = &i_g18; // 0x9044
    int32_t i_v4 = i_a1;   // 0x9044
    int32_t i_v5 = i_v1;   // 0x9044
    switch (i_v2) {
    case 10: {
    }
    case 50: {
        // 0x9178
        i_v3 = &i_g16;
    }
    case 70: {
    }
    case 30: {
    lab_0x9150:
        // 0x9150
        fwrite((int32_t *)i_v3, 1, 1, p_g2);
        fflush(p_g2);
        rewind(p_g2);
        i_v5 = i_g6;
        i_v4 = &i_g21;
        // break -> 0x916c
        break;
    }
    case 60: {
    }
    case 20: {
        // 0x918c
        i_v3 = &i_g17;
        // branch (via goto) -> 0x9150
        goto lab_0x9150;
    }
    case 40: {
        // 0x91a0
        i_v3 = &i_g19;
        // branch (via goto) -> 0x9150
        goto lab_0x9150;
    }
    }
    // 0x9170
    i_g6 = i_v5 + 1;
    return i_v4;
}

// Address range: 0x91cc - 0x9294
int32_t function_91cc(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    // 0x91cc
    i_g8 = i_a3;
    i_g7 = time(NULL);
    int32_t i_v1 = 0; // 0x925c
    if (ioctl(i_a1, 1799) < 0) {
        // 0x9268
        fprintf(p_g2, "Error: Transaction failed: %s\n",
                strerror(*__errno_location()));
        i_v1 = 1;
    }
    // 0x9260
    return i_v1;
}

// Address range: 0x92a0 - 0x93cc
int32_t function_92a0(int32_t i_a1, int32_t i_a2) {
    // 0x92a0
    int32_t i_v1;         // bp-41, 0x92a0
    int32_t i_v2 = &i_v1; // 0x92a8
    int32_t i_v3;         // bp-105, 0x92a0
    int32_t i_v4 = &i_v3; // 0x92ac
    int32_t i_v5 = i_v4;  // 0x92b8
    i_v5++;
    *(char *)i_v5 = 0;
    while (i_v5 != i_v2) {
        // 0x92bc
        i_v5++;
        *(char *)i_v5 = 0;
    }
    // 0x92d8
    int32_t i_v6; // bp-40, 0x92a0
    int32_t i_v7 = (int32_t)&i_v6 - 64;
    int32_t i_v8 = 64;
    int32_t i_v9 = fread(&i_v3, 1, 1, p_g3); // 0x92e8
    int32_t i_v10 = 0;                       // 0x92f0
    int32_t i_v11 = i_v9;                    // 0x92f0
    int32_t i_v12 = 0;                       // 0x92f0
    int32_t i_v13 = 1;                       // 0x92f0
    int32_t i_v14;                           // 0x9314
    int32_t i_v15;                           // 0x92e8
    if (i_v9 >= 1) {
        // 0x92f4
        *(char *)i_v7 = (char)i_v3;
        i_v14 = 0;
        i_v14++;
        i_v15 = fread(&i_v3, 1, 1, p_g3);
        i_v10 = i_v14;
        i_v11 = i_v15;
        i_v12 = i_v14;
        i_v13 = 1;
        while (i_v15 >= 1) {
            // 0x92f4
            *(char *)(i_v7 + i_v14) = (char)i_v3;
            i_v10 = 63;
            i_v11 = i_v15;
            i_v12 = 64;
            i_v13 = 0;
            if (i_v14 == 63) {
                // break -> 0x9324
                break;
            }
            i_v14++;
            i_v15 = fread(&i_v3, 1, 1, p_g3);
            i_v10 = i_v14;
            i_v11 = i_v15;
            i_v12 = i_v14;
            i_v13 = 1;
        }
    }
    int32_t i_v16; // 0x92a0
    int32_t i_v17; // bp-104, 0x92a0
    while (function_8d08(i_a1, i_a2, i_v8, &i_v17, i_v12) == 0) {
        int32_t i_v18 = i_v4; // 0x9354
        i_v18++;
        *(char *)i_v18 = 0;
        while (i_v18 != i_v2) {
            // 0x9354
            i_v18++;
            *(char *)i_v18 = 0;
        }
        // 0x9360
        i_v8 = i_v10 + i_v8 + (int32_t)(i_v11 == 1);
        if (i_v13 != 0) {
            // 0x9394
            i_v16 = 0;
            if (function_91cc(i_a1, i_a2, i_v8 - 64) == 0) {
                return i_v16;
            } else {
                // 0x93ac
                fwrite((int32_t *)"Inode write failed\n", 1, 19, p_g2);
                i_v16 = 1;
                return i_v16;
            }
        }
        i_v9 = fread(&i_v3, 1, 1, p_g3);
        i_v10 = 0;
        i_v11 = i_v9;
        i_v12 = 0;
        i_v13 = 1;
        if (i_v9 >= 1) {
            // 0x92f4
            *(char *)i_v7 = (char)i_v3;
            i_v14 = 0;
            i_v14++;
            i_v15 = fread(&i_v3, 1, 1, p_g3);
            i_v10 = i_v14;
            i_v11 = i_v15;
            i_v12 = i_v14;
            i_v13 = 1;
            while (i_v15 >= 1) {
                // 0x92f4
                *(char *)(i_v7 + i_v14) = (char)i_v3;
                i_v10 = 63;
                i_v11 = i_v15;
                i_v12 = 64;
                i_v13 = 0;
                if (i_v14 == 63) {
                    // break -> 0x9324
                    break;
                }
                i_v14++;
                i_v15 = fread(&i_v3, 1, 1, p_g3);
                i_v10 = i_v14;
                i_v11 = i_v15;
                i_v12 = i_v14;
                i_v13 = 1;
            }
        }
    }
    // 0x9370
    fwrite((int32_t *)"Block write failed\n", 1, 19, p_g2);
    i_v16 = 1;
lab_0x938c:
    // 0x938c
    return i_v16;
}

// Address range: 0x93dc - 0x9468
int32_t function_93dc(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    int32_t i_v1 = ioctl(i_a1, 1799); // 0x9438
    if (i_v1 < 0) {
        // 0x9450
        fprintf(p_g2, "Error: Read error:%d\n", i_v1);
    }
    // 0x9444
    return i_v1;
}

// Address range: 0x9470 - 0x9554
int32_t function_9470(int32_t i_a1, int32_t i_a2) {
    // 0x9470
    function_93dc(i_a1, i_a2, i_g9);
    uint32_t i_v1 = *(int32_t *)(i_g9 + 4) + 64; // 0x9494
    if (i_v1 == 63 || i_v1 < 63) {
        // 0x9520
        return 0;
    }
    int32_t i_v2 = 64; // 0x949c
    int32_t i_v3;      // 0x9470
    int32_t i_v4;      // 0x9470
    int32_t i_v5;      // bp-96, 0x9470
    while (true) {
    lab_0x94ac:
        // 0x94ac
        if (function_8df0(i_a1, i_a2, i_v2, &i_v5) != 0) {
            // break -> 0x9534
            break;
        }
        int32_t i_v6 = *(int32_t *)(i_g9 + 4) + 64; // 0x94d0
        int32_t i_v7 = i_v6 - i_v2;                 // 0x94d4
        i_v4 = 64;
        if (i_v7 == 63 || i_v7 < 63) {
            // 0x9528
            i_v4 = i_v7;
            i_v3 = i_v6;
            if (i_v7 == 0) {
                goto lab_0x950c;
            } else {
                goto lab_0x94e4;
            }
        } else {
            goto lab_0x94e4;
        }
    }
    // 0x9534
    fwrite((int32_t *)"Block read failed\n", 1, 18, p_g2);
    // 0x9520
    return 1;
lab_0x94e4:;
    int32_t i_v8 = 0;                                      // 0x94e4
    unsigned char i_v9 = *(char *)(i_v8 + (int32_t)&i_v5); // 0x94e8
    int32_t i_v10 = i_v8 + 1;                              // 0x94ec
    _IO_putc((int32_t)i_v9, p_g4);
    i_v8 = i_v10;
    while (i_v10 < i_v4) {
        // 0x94e8
        i_v9 = *(char *)(i_v8 + (int32_t)&i_v5);
        i_v10 = i_v8 + 1;
        _IO_putc((int32_t)i_v9, p_g4);
        i_v8 = i_v10;
    }
    // 0x9500
    i_v3 = *(int32_t *)(i_g9 + 4) + 64;
    goto lab_0x950c;
lab_0x950c:;
    uint32_t i_v11 = i_v3;
    i_v2 += 64;
    if (i_v2 != i_v11 && i_v2 >= i_v11) {
        // 0x9520
        return 0;
    }
    goto lab_0x94ac;
}

// Address range: 0x9564 - 0x95bc
int32_t function_9564(void) {
    // 0x9564
    int32_t i_v1; // 0x9564
    function_93dc(i_v1, i_v1, i_g9);
    struct tm *p_v2 = localtime((int32_t *)i_g9); // 0x9584
    int32_t i_v3;                                 // bp-24, 0x9564
    strftime((char *)&i_v3, 15, (char *)((int32_t) "%Y%m%d%H%M%S" & 0xffff),
             p_v2);
    return printf((char *)((int32_t) "LEN=%d,TIME=%s\n" & 0xffff));
}

// Address range: 0x95bc - 0x9654
int32_t warn(void) {
    // 0x95bc
    fwrite((int32_t *)((int32_t) "\n\n!!!!!!!!!!!!!!!!!!!!!WARNING!!!!!!!!!!!!!"
                                 "!!!!!!!!\n" &
                       0xffff),
           1, 52, p_g2);
    fwrite(
        (int32_t
             *)((int32_t) "This program is intended for use on eeproms\nusing "
                          "external busses such as i2c-pport.\n" &
                0xffff),
        1, 85, p_g2);
    fwrite(
        (int32_t
             *)((int32_t) "Do not use this on your SDRAM DIMM EEPROMS\nunless "
                          "you REALLY REALLY know what you are\ndoing!!! Doing "
                          "so will render your SDRAM\nUSELESS and leave your "
                          "system UNBOOTABLE!!!\n" &
                0xffff),
        1, 171, p_g2);
    fwrite(
        (int32_t *)((int32_t) "To disable this warning use -force\n" & 0xffff),
        1, 35, p_g2);
    fwrite((int32_t *)((int32_t) "\n\nPress  ENTER  to continue or hit "
                                 "Control-C NOW !!!!\n\n\n" &
                       0xffff),
           1, 56, p_g2);
    return _IO_getc(p_g3);
}

// Address range: 0x9654 - 0x96b0
int32_t function_9654(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    int32_t i_v1 = function_8744(i_a1, i_a2, i_a3, i_a4); // 0x9670
    int32_t i_v2 =
        (int32_t)&i_g11 + 0x9674 - ((int32_t)&i_g14 + (int32_t)&i_g10) >> 2 == 0
            ? i_v1
            : i_a1;
    return i_v2;
}

// Address range: 0x96b8 - 0x96bc
int32_t function_96b8(void) {
    // 0x96b8
    int32_t i_v1; // 0x96b8
    return i_v1;
}

// Address range: 0x96bc - 0x96c4
int32_t function_96bc(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x96bc
    return i_a1;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.8.x)
// Detected functions: 50
