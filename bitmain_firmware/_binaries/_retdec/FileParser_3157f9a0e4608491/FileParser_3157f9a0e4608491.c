//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ----------------- Float Types Definitions ------------------

typedef double float64_t;
typedef long double float128_t;

// ------------------- Function Prototypes --------------------

int32_t entry_point(int32_t i_a1, int32_t i_a2);
int32_t function_106e8(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_10708(int32_t i_a1);
int32_t function_10714(int32_t i_a1);
int32_t function_10720(int32_t i_a1, int32_t i_a2, int32_t *p_a3, int32_t i_a4,
                       int32_t i_a5, int32_t i_a6, int32_t *p_a7);
int32_t function_1072c(void);
int32_t function_10738(int32_t i_a1);
int32_t function_10744(int32_t *p_a1, int32_t i_a2, int32_t i_a3,
                       int32_t *p_a4);
int32_t function_10750(int32_t i_a1, int32_t *p_a2, int32_t i_a3, int32_t i_a4,
                       int32_t i_a5, int32_t i_a6);
int32_t function_1075c(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t function_10768(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_10774(int32_t *p_a1, int32_t *p_a2, int32_t *p_a3,
                       int32_t *p_a4);
int32_t function_10780(int32_t *p_a1);
int32_t function_1078c(int32_t *p_a1, int32_t i_a2, int32_t i_a3,
                       int32_t *p_a4);
int32_t function_10798(int32_t i_a1, char *p_a2, int32_t i_a3, int32_t *p_a4);
int32_t function_107a4(int32_t i_a1, int32_t i_a2);
int32_t function_107b0(int32_t *p_a1, int32_t i_a2);
int32_t function_107bc(char *p_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_107c8(int32_t i_a1, int32_t i_a2);
int32_t function_107d4(int32_t *p_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_107e0(void);
int32_t function_107f0(char *p_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_107fc(int32_t i_a1);
int32_t function_10808(int32_t *p_a1, int32_t i_a2, int32_t i_a3,
                       int32_t *p_a4);
int32_t function_10814(int32_t i_a1);
int32_t function_10820(int32_t *p_a1);
int32_t function_1082c(int32_t *p_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_10868(void);
int32_t function_1088c(int32_t i_a1, int32_t i_a2, int32_t i_a3, char i_a4);
int32_t function_108dc(void);
int32_t function_108f4(int32_t i_a1);
int32_t function_109a8(int32_t *p_a1);
int32_t function_10b7c(void);
int32_t function_10c50(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t *p_a4);
int32_t function_10dc8(int32_t i_a1, uint32_t i_a2, int32_t i_a3, uint32_t i_a4,
                       uint32_t i_a5, uint32_t i_a6);
int32_t function_11430(int32_t i_a1);
int32_t function_11460(int32_t i_a1);
int32_t function_11498(uint32_t i_a1, int32_t i_a2);
int32_t function_114e4(int64_t i_a1, int32_t i_a2, uint32_t i_a3);
int32_t function_11550(int64_t i_a1, int32_t i_a2, int64_t i_a3, int32_t i_a4,
                       int32_t i_a5, int32_t i_a6);
int32_t function_11674(int32_t i_a1, uint32_t i_a2);
int32_t function_1196c(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t function_11984(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4,
                       int32_t i_a5, int32_t i_a6, int32_t i_a7);
int32_t function_11b4c(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t function_11d48(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_11ec8(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4,
                       uint64_t i_a5);
int32_t function_11fd4(int32_t *p_a1, int32_t i_a2, int64_t i_a3, int32_t i_a4,
                       int32_t i_a5);
int32_t function_12078(int32_t i_a1, uint32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_128a0(int32_t *p_a1, int32_t *p_a2, int32_t *p_a3,
                       int32_t *p_a4, uint32_t i_a5, uint32_t i_a6,
                       uint32_t i_a7);
int32_t function_133d0(uint32_t i_a1, int32_t i_a2);
int32_t function_137b4(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_137f0(void);
int32_t function_137f4(int32_t i_a1, int32_t *p_a2);
int32_t function_137f8(void);
int32_t function_13800(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_28623c(void);
int32_t function_e0832002(void);
int32_t function_e1a00003(void);
int32_t function_e1a02003(void);
int32_t function_e1a03000(void);
int32_t function_e1a0c002(void);
int32_t function_e1a0e003(void);
int32_t function_e2433004(void);
int32_t function_e243300c(void);
int32_t function_e24b3e51(void);
int32_t function_e3033bac(void);
int32_t function_e3033bbc(void);
int32_t function_e3403001(void);
int32_t function_e58c0000(void);
int32_t function_e58c1004(void);
int32_t function_e58c2008(void);
int32_t function_e58c300c(void);
int32_t function_e8be000f(void);
int32_t function_ea00004f(void);
int32_t function_ebfffdc5(void);
int32_t function_ff86c440(void);
int32_t function_ff86c7c0(void);
int32_t function_ff86ce08(void);
int32_t unknown_240(void);
int32_t unknown_411fb0(void);

// --------------------- Global Variables ---------------------

int32_t i_g1 = 0x108f5; // 0x24f08
int32_t i_g2 = 0;       // 0x25070
int32_t i_g3 = 256;     // 0x2507c
char *p_g4;             // 0x25838
uint32_t i_g5;
int32_t i_g6;
int32_t i_g7;

// ------------------------ Functions -------------------------

// Address range: 0x106e8 - 0x106f4
int32_t function_106e8(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x106e8
    return function_10868();
}

// Address range: 0x10708 - 0x10714
int32_t function_10708(int32_t i_a1) {
    // 0x10708
    return function_e2433004();
}

// Address range: 0x10714 - 0x10720
int32_t function_10714(int32_t i_a1) {
    // 0x10714
    return function_e243300c();
}

// Address range: 0x10720 - 0x1072c
int32_t function_10720(int32_t i_a1, int32_t i_a2, int32_t *p_a3, int32_t i_a4,
                       int32_t i_a5, int32_t i_a6, int32_t *p_a7) {
    // 0x10720
    return function_e0832002();
}

// Address range: 0x1072c - 0x10738
int32_t function_1072c(void) {
    // 0x1072c
    return function_e3033bac();
}

// Address range: 0x10738 - 0x10744
int32_t function_10738(int32_t i_a1) {
    // 0x10738
    return function_e3403001();
}

// Address range: 0x10744 - 0x10750
int32_t function_10744(int32_t *p_a1, int32_t i_a2, int32_t i_a3,
                       int32_t *p_a4) {
    // 0x10744
    return function_e1a0c002();
}

// Address range: 0x10750 - 0x1075c
int32_t function_10750(int32_t i_a1, int32_t *p_a2, int32_t i_a3, int32_t i_a4,
                       int32_t i_a5, int32_t i_a6) {
    // 0x10750
    return function_e1a0e003();
}

// Address range: 0x1075c - 0x10768
int32_t function_1075c(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    // 0x1075c
    return function_e8be000f();
}

// Address range: 0x10768 - 0x10774
int32_t function_10768(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x10768
    return function_e58c0000();
}

// Address range: 0x10774 - 0x10780
int32_t function_10774(int32_t *p_a1, int32_t *p_a2, int32_t *p_a3,
                       int32_t *p_a4) {
    // 0x10774
    return function_e58c1004();
}

// Address range: 0x10780 - 0x1078c
int32_t function_10780(int32_t *p_a1) {
    // 0x10780
    return function_e58c2008();
}

// Address range: 0x1078c - 0x10798
int32_t function_1078c(int32_t *p_a1, int32_t i_a2, int32_t i_a3,
                       int32_t *p_a4) {
    // 0x1078c
    return function_e58c300c();
}

// Address range: 0x10798 - 0x107a4
int32_t function_10798(int32_t i_a1, char *p_a2, int32_t i_a3, int32_t *p_a4) {
    // 0x10798
    return function_ea00004f();
}

// Address range: 0x107a4 - 0x107b0
int32_t function_107a4(int32_t i_a1, int32_t i_a2) {
    // 0x107a4
    return function_e24b3e51();
}

// Address range: 0x107b0 - 0x107bc
int32_t function_107b0(int32_t *p_a1, int32_t i_a2) {
    // 0x107b0
    return function_e2433004();
}

// Address range: 0x107bc - 0x107c8
int32_t function_107bc(char *p_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x107bc
    return function_e243300c();
}

// Address range: 0x107c8 - 0x107d4
int32_t function_107c8(int32_t i_a1, int32_t i_a2) {
    // 0x107c8
    return function_e1a00003();
}

// Address range: 0x107d4 - 0x107e0
int32_t function_107d4(int32_t *p_a1, int32_t i_a2, int32_t i_a3,
                       int32_t i_a4) {
    // 0x107d4
    return function_ebfffdc5();
}

// Address range: 0x107e0 - 0x107f0
int32_t function_107e0(void) {
    // 0x107e0
    return function_e1a03000();
}

// Address range: 0x107f0 - 0x107fc
int32_t function_107f0(char *p_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x107f0
    return function_e1a02003();
}

// Address range: 0x107fc - 0x10808
int32_t function_107fc(int32_t i_a1) {
    // 0x107fc
    return function_e24b3e51();
}

// Address range: 0x10808 - 0x10814
int32_t function_10808(int32_t *p_a1, int32_t i_a2, int32_t i_a3,
                       int32_t *p_a4) {
    // 0x10808
    return function_e2433004();
}

// Address range: 0x10814 - 0x10820
int32_t function_10814(int32_t i_a1) {
    // 0x10814
    return function_e243300c();
}

// Address range: 0x10820 - 0x1082c
int32_t function_10820(int32_t *p_a1) {
    // 0x10820
    return function_e0832002();
}

// Address range: 0x1082c - 0x10838
int32_t function_1082c(int32_t *p_a1, int32_t i_a2, int32_t i_a3,
                       int32_t i_a4) {
    // 0x1082c
    return function_e3033bbc();
}

// Address range: 0x10838 - 0x10860
int32_t entry_point(int32_t i_a1, int32_t i_a2) {
    // 0x10838
    int32_t i_v1; // 0x10838
    int32_t i_v2 = function_10720(0x133d0, i_a2, &i_v1, 0x137b5, 0x133d0, i_a1,
                                  &i_v1); // 0x10854
    return function_10708(i_v2);
}

// Address range: 0x10868 - 0x10884
int32_t function_10868(void) {
    // 0x10868
    if (i_g2 == 0) {
        int32_t i_v1; // 0x10868
        return i_v1;
    }
    // 0x10880
    return function_1072c();
}

// Address range: 0x1088c - 0x108dc
int32_t function_1088c(int32_t i_a1, int32_t i_a2, int32_t i_a3, char i_a4) {
    // 0x1088c
    int32_t i_v1; // 0x1088c
    int32_t i_v2 = i_v1;
    bool i_v3; // 0x1088c
    if (i_v3) {
        return i_a1;
    }
    bool i_v4; // 0x1088c
    if (!i_v3) {
        int32_t i_v5 = 0x100001 * i_v2 & -1 - 0x400000 * i_v2; // 0x108c4
        i_v4 = i_v5 < 0;
        if (i_v5 == 0) {
            return unknown_240();
        }
    }
    // 0x108d4
    if (i_v4 != i_v3) {
        __asm_svclt(0x4770);
    }
    return i_a1;
}

// Address range: 0x108dc - 0x108f4
int32_t function_108dc(void) {
    // 0x108dc
    int32_t i_v1; // 0x108dc
    if (*(char *)&p_g4 == 0) {
        // 0x108ea
        int32_t i_v2;                                       // 0x108dc
        int32_t i_v3 = function_1088c(i_v2, i_v2, i_v2, 0); // 0x108ea
        *(char *)&p_g4 = 1;
        i_v1 = i_v3;
    }
    // 0x108f2
    return i_v1;
}

// Address range: 0x108f4 - 0x109a8
int32_t function_108f4(int32_t i_a1) {
    int32_t i_v1; // 0x108f4
    function_107f0("Useage:\r", i_v1, i_v1, i_v1);
    function_107bc("\t%s [option] [paramaters]\n\n", i_a1, i_v1, i_v1);
    function_107f0("\tOption:{-f} {-s} {-p} {-n} {-x} {-q}\n", i_a1, i_v1,
                   i_v1);
    function_107f0("\t\t-f [minerType] [fileName] [rootPublicKeyFile]: "
                   "\n\t\t\tOnly Check If Filename was Valided.\n",
                   i_a1, i_v1, i_v1);
    function_107f0(
        "\t\t-s [minerType] [fileName] [rootPublicKeyFile]: \n\t\t\tCheck If "
        "Filename Was Valided, and Splite Bmu To \"/tmp/tmpfw/\"\n",
        i_a1, i_v1, i_v1);
    function_107f0(
        "\t\t-p [minerType] [fileName] [rootPublicKeyFile]: \n\t\t\tCheck If "
        "Filename Was Valided, and Dump BmuComments\n",
        i_a1, i_v1, i_v1);
    function_107f0("\t\t-x [minerType] [fileName] [rootPublicKeyFile]: "
                   "\n\t\t\tCheck If Filename Was FullSize BMU\n",
                   i_a1, i_v1, i_v1);
    function_107f0("\t\t-n [nandBinFile]: \n\t\t\tSplite SigImg To Single File "
                   "To \"/tmp/tmpNand/\"\n",
                   i_a1, i_v1, i_v1);
    function_107f0(
        "\t\t-q: \n\t\t\tGenerate A 256Bytes 0xff File To \"/tmp/256BFF\"\n",
        i_a1, i_v1, i_v1);
    function_107f0("\tReturns:", i_a1, i_v1, i_v1);
    function_107f0("\t\t0: \n\t\t\tWell Done!\n", i_a1, i_v1, i_v1);
    return __asm_nop(function_107f0("\t\tOthers: \n\t\t\tSomething Wrong!\n",
                                    i_a1, i_v1, i_v1));
}

// Address range: 0x109a8 - 0x10b7c
int32_t function_109a8(int32_t *p_a1) {
    int32_t i_v1 = 0; // bp-32788, 0x109d0
    int32_t i_v2;     // bp-32784, 0x109a8
    function_10744(&i_v2, 0, 0x7ffc, &i_v2);
    int32_t i_v3; // bp-32776, 0x109a8
    int32_t i_v4 =
        function_10798((int32_t)p_a1, "rb", 0x7ffc, &i_v3); // 0x109fc
    int32_t i_v5 = 0;                                       // 0x10a0c
    if (i_v4 == 0) {
        // 0x10a10
        function_107f0("Load Nand Image File Failed!", (int32_t) "rb", 0x7ffc,
                       0);
        // 0x10b70
        return 1;
    }
    int32_t i_v6 = 132 * i_v5;                          // 0x10a48
    int32_t *p_v7 = (int32_t *)(i_v6 + (int32_t)&i_g3); // 0x10a50
    function_1082c(&i_v1, *p_v7, 1, i_v4);
    int32_t i_v8 = i_v6 + (int32_t)&i_g3 + 4;                         // 0x10a84
    int32_t i_v9 = function_10798(i_v8, "wb", i_v6, (int32_t *)i_v8); // 0x10a94
    int32_t i_v10;                                                    // 0x109a8
    while (i_v9 != 0) {
        // 0x10af0
        function_107d4(&i_v1, *p_v7, 1, i_v9);
        function_10738(i_v9);
        i_v5++;
        if (i_v5 >= 15) {
            // 0x10b64
            function_10738(i_v4);
            i_v10 = 0;
            return i_v10;
        }
        i_v6 = 132 * i_v5;
        p_v7 = (int32_t *)(i_v6 + (int32_t)&i_g3);
        function_1082c(&i_v1, *p_v7, 1, i_v4);
        i_v8 = i_v6 + (int32_t)&i_g3 + 4;
        i_v9 = function_10798(i_v8, "wb", i_v6, (int32_t *)i_v8);
    }
    // 0x10ae0
    function_107bc("Try To Write To File '%s' Failed!\n", i_v8, i_v6, i_v8);
    function_10738(i_v4);
    i_v10 = 2;
lab_0x10b70:
    // 0x10b70
    return i_v10;
}

// Address range: 0x10b7c - 0x10c50
int32_t function_10b7c(void) {
    // 0x10b7c
    int32_t i_v1; // 0x10b7c
    int32_t i_v2 = function_10798((int32_t) "/tmp/256BFF", "wb", i_v1,
                                  (int32_t *)i_v1); // 0x10b98
    if (i_v2 == 0) {
        // 0x10bac
        function_107f0("GenFile Failed!", (int32_t) "wb", i_v1, 0);
        // 0x10c44
        return 1;
    }
    int32_t i_v3 = 0; // bp-272, 0x10bc4
    int32_t i_v4;     // bp-268, 0x10b7c
    function_10744(&i_v4, 0, 252, &i_v4);
    for (int32_t i_v5 = 0; i_v5 < 256; i_v5++) {
        // 0x10bf0
        *(char *)(i_v5 + (int32_t)&i_v3) = -1;
    }
    // 0x10c1c
    function_107d4(&i_v3, 256, 1, i_v2);
    function_10738(i_v2);
    // 0x10c44
    return 0;
}

// Address range: 0x10c50 - 0x10dc8
int32_t function_10c50(int32_t i_a1, int32_t i_a2, int32_t i_a3,
                       int32_t *p_a4) {
    int32_t i_v1 = function_107a4((int32_t)p_a4, 1024); // 0x10c84
    int32_t i_v2 = function_10768(i_v1, 0, 0, 0);       // 0x10c9c
    if (i_v2 == 0) {
        int32_t i_v3 = function_107c8(function_10714(0), 0); // 0x10cc0
        function_107bc("OpenSSL error: %s\n", i_v3, 0, i_v3);
        function_107f0("Read Root PubK Failed!", i_v3, 0, i_v3);
        // 0x10dbc
        return 12;
    }
    // 0x10cec
    int32_t i_v4; // bp-164, 0x10c50
    function_10820(&i_v4);
    function_10808(&i_v4, i_a1, i_a2, &i_v4);
    int32_t i_v5; // bp-52, 0x10c50
    function_10774(&i_v5, &i_v4, &i_v4, &i_v5);
    int32_t i_v6 = function_10750(672, &i_v5, 32, i_a3, 256, i_v2); // 0x10d40
    int32_t i_v7 = function_107fc(i_v2);                            // 0x10d64
    if (i_v1 != 0) {
        // 0x10d68
        i_v7 = function_10814(i_v1);
    }
    int32_t i_v8 = 0; // 0x10d78
    if (i_v6 != 1) {
        int32_t i_v9 = function_107c8(function_10714(i_v7), 0); // 0x10d94
        function_107bc("OpenSSL error: %s\n", i_v9, 32, i_v9);
        function_107f0("Check miner.pem Failed!", i_v9, 32, i_v9);
        i_v8 = 13;
    }
    // 0x10dbc
    return i_v8;
}

// Address range: 0x10dc8 - 0x11430
int32_t function_10dc8(int32_t i_a1, uint32_t i_a2, int32_t i_a3, uint32_t i_a4,
                       uint32_t i_a5, uint32_t i_a6) {
    int32_t i_v1 = 0; // bp-1044, 0x10de8
    int32_t i_v2;     // bp-1040, 0x10dc8
    function_10744(&i_v2, 0, 1020, &i_v2);
    int32_t i_v3; // bp-1156, 0x10dc8
    function_10820(&i_v3);
    int32_t i_v4 = 0; // 0x10e3c
    if (i_a6 % 256 != 0) {
        char *p_v5 = (char *)0x706d742f; // bp-1316, 0x10e58
        int32_t i_v6;                    // bp-1304, 0x10dc8
        function_10744(&i_v6, 0, 116, &i_v6);
        i_g5 = i_a4 % 256;
        switch ((char)i_a4) {
        case 0: {
            int32_t i_v7 =
                function_10780((int32_t *)&p_v5) + (int32_t)&p_v5; // 0x10ed4
            *(int32_t *)i_v7 = 0x544f4f42;
            *(int32_t *)(i_v7 + 4) = 0x6e69622e;
            *(char *)(i_v7 + 8) = 0;
            // break -> 0x11194
            break;
        }
        case 1: {
            int32_t i_v8 =
                function_10780((int32_t *)&p_v5) + (int32_t)&p_v5; // 0x10f20
            *(int32_t *)i_v8 = 0x69766564;
            *(int32_t *)(i_v8 + 4) = 0x72746563;
            *(int32_t *)(i_v8 + 8) = 0x642e6565;
            *(int16_t *)(i_v8 + 12) = 0x6274;
            *(char *)(i_v8 + 14) = 0;
            // break -> 0x11194
            break;
        }
        case 2: {
            int32_t i_v9 =
                function_10780((int32_t *)&p_v5) + (int32_t)&p_v5; // 0x10f7c
            *(int32_t *)i_v9 = 0x616d4975;
            *(int16_t *)(i_v9 + 4) = 0x6567;
            *(char *)(i_v9 + 6) = 0;
            // break -> 0x11194
            break;
        }
        case 3: {
            int32_t i_v10 =
                function_10780((int32_t *)&p_v5) + (int32_t)&p_v5; // 0x10fcc
            *(int32_t *)i_v10 = 0x656e696d;
            *(int32_t *)(i_v10 + 4) = 0x2e736672;
            *(int32_t *)(i_v10 + 8) = 0x67616d69;
            *(int32_t *)(i_v10 + 12) = 0x7a672e65;
            *(char *)(i_v10 + 16) = 0;
            // break -> 0x11194
            break;
        }
        case 4: {
            int32_t i_v11 =
                function_10780((int32_t *)&p_v5) + (int32_t)&p_v5; // 0x11028
            *(int32_t *)i_v11 = 0x61647075;
            *(int32_t *)(i_v11 + 4) = 0x692e6574;
            *(int32_t *)(i_v11 + 8) = 0x6567616d;
            *(int32_t *)(i_v11 + 12) = 0x7a672e;
            // break -> 0x11194
            break;
        }
        case 5: {
            int32_t i_v12 =
                function_10780((int32_t *)&p_v5) + (int32_t)&p_v5; // 0x1107c
            *(int32_t *)i_v12 = 0x2e6c7263;
            *(int32_t *)(i_v12 + 4) = 0x2e726174;
            *(int16_t *)(i_v12 + 8) = 0x7a67;
            *(char *)(i_v12 + 10) = 0;
            // break -> 0x11194
            break;
        }
        case 6: {
            int32_t i_v13 =
                function_10780((int32_t *)&p_v5) + (int32_t)&p_v5; // 0x110d0
            *(int32_t *)i_v13 = 0x656e696d;
            *(int32_t *)(i_v13 + 4) = 0x74622e72;
            *(int32_t *)(i_v13 + 8) = 0x61742e6d;
            *(int32_t *)(i_v13 + 12) = 0x7a672e72;
            *(char *)(i_v13 + 16) = 0;
            // break -> 0x11194
            break;
        }
        case 7: {
            int32_t i_v14 =
                function_10780((int32_t *)&p_v5) + (int32_t)&p_v5; // 0x1112c
            *(int32_t *)i_v14 = 0x65736572;
            *(int32_t *)(i_v14 + 4) = 0x657672;
            // break -> 0x11194
            break;
        }
        case 9: {
            int32_t i_v15 =
                function_10780((int32_t *)&p_v5) + (int32_t)&p_v5; // 0x11170
            *(int32_t *)i_v15 = 0x61746164;
            *(int32_t *)(i_v15 + 4) = 0x656c6966;
            *(char *)(i_v15 + 8) = 0;
            __asm_nop(0x61746164);
            // break -> 0x11194
            break;
        }
        }
        int32_t i_v16; // 0x10dc8
        if (i_a5 % 256 == 0) {
            // 0x11194
            i_v16 = (int32_t)&p_v5;
        } else {
            int32_t i_v17 = function_10780((int32_t *)&p_v5); // 0x111b0
            int32_t i_v18 = (int32_t)&p_v5;
            int32_t i_v19 = i_v17 + i_v18; // 0x111c8
            *(int32_t *)i_v19 = 0x6769732e;
            *(char *)(i_v19 + 4) = 0;
            i_v16 = i_v18;
        }
        int32_t i_v20 = i_v16;
        function_107bc("fileName:'%s', size:[%d]\r\n", i_v20, i_a2, i_v20);
        int32_t i_v21 =
            function_10798(i_v20, "wb", i_a2, (int32_t *)&p_v5); // 0x1121c
        i_v4 = i_v21;
        if (i_v21 == 0) {
            // 0x11230
            function_107bc("Create File '%s' Failed!\r\n", i_v20, i_a2, i_v20);
            i_v4 = 0;
        }
    }
    int32_t i_v22 = &i_v1;
    int32_t i_v23 = i_a2; // 0x112ec
    if (i_a2 >= 1024 == (i_a2 != 1024)) {
        int32_t i_v24 = 0;                                    // 0x1127c
        int32_t i_v25 = function_1082c(&i_v1, 1, 1024, i_a1); // 0x11268
        function_10808(&i_v3, i_v22, 1024, &i_v3);
        if (i_a6 % 256 != 0 && i_v4 != 0) {
            // 0x112c0
            function_107d4(&i_v1, 1, 1024, i_v4);
        }
        // 0x112dc
        i_v24 += i_v25;
        int32_t i_v26 = i_a2 - i_v24; // 0x112e4
        i_v23 = i_v26;
        while (i_v26 >= 1024 == (i_v26 != 1024)) {
            // 0x11250
            i_v25 = function_1082c(&i_v1, 1, 1024, i_a1);
            function_10808(&i_v3, i_v22, 1024, &i_v3);
            if (i_a6 % 256 != 0 && i_v4 != 0) {
                // 0x112c0
                function_107d4(&i_v1, 1, 1024, i_v4);
            }
            // 0x112dc
            i_v24 += i_v25;
            i_v26 = i_a2 - i_v24;
            i_v23 = i_v26;
        }
    }
    int32_t i_v27 = function_1082c(&i_v1, 1, i_v23, i_a1); // 0x11310
    function_10808(&i_v3, i_v22, i_v27, &i_v3);
    int32_t i_v28;   // bp-1188, 0x10dc8
    float64_t f_v29; // 0x10dc8
    int32_t i_v30;   // 0x10dc8
    if (i_a6 % 256 == 0 || i_v4 == 0) {
        // 0x113e4
        i_v28 = 0;
        __asm_vmov_i32(0);
        __asm_vst1_8(f_v29, f_v29, i_v30);
        __asm_vst1_8(f_v29, f_v29, i_v30);
        function_10774(&i_v28, &i_v3, &i_v3, &i_v28);
    } else {
        // 0x11358
        function_107d4(&i_v1, 1, i_v27, i_v4);
        i_v28 = 0;
        __asm_vmov_i32(0);
        __asm_vst1_8(f_v29, f_v29, i_v30);
        __asm_vst1_8(f_v29, f_v29, i_v30);
        function_10774(&i_v28, &i_v3, &i_v3, &i_v28);
        function_10738(i_v4);
    }
    // 0x113e4
    *(int32_t *)i_a3 = i_v28;
    __asm_nop(i_v30);
    return i_v30;
}

// Address range: 0x11430 - 0x11460
int32_t function_11430(int32_t i_a1) {
    // 0x11430
    return i_a1;
}

// Address range: 0x11460 - 0x11498
int32_t function_11460(int32_t i_a1) {
    // 0x11460
    int64_t i_v1; // bp-16, 0x11460
    function_1078c((int32_t *)&i_v1, i_a1, 8, (int32_t *)&i_v1);
    return (0x100000000 * i_v1 >> 32) / 0x100000000;
}

// Address range: 0x11498 - 0x114e4
int32_t function_11498(uint32_t i_a1, int32_t i_a2) {
    // 0x11498
    return (int32_t)i_a1 >> 31 ^ i_a1 / 0x8000;
}

// Address range: 0x114e4 - 0x11550
int32_t function_114e4(int64_t i_a1, int32_t i_a2, uint32_t i_a3) {
    float64_t f_v1 = __asm_vldr((int32_t)i_a1); // 0x114f8
    uint32_t i_v2 = __asm_vmov(f_v1);           // 0x11500
    float64_t f_v3;                             // 0x114e4
    float64_t f_v4 =
        __asm_vshl_u64(f_v1, __asm_vmov_32(f_v3, -i_a3 % 64)); // 0x1152c
    return i_v2 >> i_a3 | i_v2 << 32 - i_a3 | i_v2 >> i_a3 - 32 |
           __asm_vmov(f_v4);
}

// Address range: 0x11550 - 0x11674
int32_t function_11550(int64_t i_a1, int32_t i_a2, int64_t i_a3, int32_t i_a4,
                       int32_t i_a5, int32_t i_a6) {
    int64_t i_v1 = 0x100000000 * i_a3;
    int32_t i_v2 =
        ((int32_t)(((i_v1 ^ 0x100000000 * i_a1) >> 32) / 0x100000000) * i_a5 >>
             31 ^
         (int32_t)((i_v1 >> 32) / 0x100000000)) *
        i_a5; // 0x115ec
    return (i_v2 / 0x8000 ^ i_v2 >> 31) * i_a5 / 0x80000000;
}

// Address range: 0x11674 - 0x1196c
int32_t function_11674(int32_t i_a1, uint32_t i_a2) {
    // 0x11674
    int32_t i_v1; // 0x11674
    if (i_a2 != 7 && i_a2 >= 7) {
        int32_t i_v2 = 2 * i_a2 - 0x651e95c5;             // 0x116ac
        int32_t i_v3 = function_11460(i_a1) - 0x651e95c5; // 0x116c8
        int32_t i_v4 = function_11460(i_a2 + i_a1 - 8);   // 0x116e8
        int32_t i_v5 = i_v4 >> 31;
        int32_t i_v6 = i_v3 >> 31;
        int32_t i_v7 =
            function_114e4((int64_t)i_v5, i_v4, 37) * i_v2 + i_v6; // 0x1172c
        int32_t i_v8 =
            (function_114e4((int64_t)i_v6, i_v3, 25) + i_v5) * i_v2; // 0x11768
        i_v1 = function_11550((int64_t)(i_v7 >> 31), i_v7,
                              (int64_t)(i_v8 >> 31), i_v8, i_v2 >> 31, i_v2);
        // 0x1195c
        return i_v1;
    }
    if (i_a2 == 3 || i_a2 < 3) {
        // 0x11854
        i_v1 = -0x651e95c5;
        if (i_a2 != 0) {
            // 0x11860
            int32_t i_v9; // 0x11674
            uint32_t i_v10 = 256 * (int32_t) * (char *)(i_a2 / 2 + i_a1) |
                             (uint32_t)i_v9 % 256; // 0x118a8
            uint32_t i_v11 =
                4 * (int32_t) * (char *)(i_a2 + i_a1 - 1) + i_a2; // 0x118bc
            i_v1 = -0x651e95c5 *
                   function_11498(0, -0x6834ced9 * i_v11 + i_v11 / 2 ^
                                         0x2f90404f * i_v10 + i_v10 / 2);
        }
        // 0x1195c
        return i_v1;
    }
    int32_t i_v12 = 2 * i_a2 - 0x651e95c5; // 0x117c0
    uint32_t i_v13 = function_11430(i_a1); // 0x117d0
    uint32_t i_v14 = 8 * i_v13;            // 0x117fc
    int32_t i_v15 = i_v14 + i_a2;          // 0x11800
    i_v1 = function_11550(
        (int64_t)i_v15, i_v13 / 0x20000000 + (int32_t)(i_v15 < i_v14),
        (int64_t)function_11430(i_a2 + i_a1 - 4), 0, i_v12 >> 31, i_v12);
    // 0x1195c
    return i_v1;
}

// Address range: 0x1196c - 0x11982
int32_t function_1196c(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    int32_t i_v1 = unknown_411fb0();       // 0x1196c
    int32_t i_v2 = *(int32_t *)(i_v1 + 4); // 0x1197c
    *(int32_t *)i_v2 = i_v1 + 16;
    *(int32_t *)(i_v2 + 4) = *(int32_t *)i_v1;
    int32_t i_v3; // 0x1196c
    *(int32_t *)(i_v2 + 12) = i_v3 ^ i_a2;
    return -0x1e5fcfff;
}

// Address range: 0x11984 - 0x11b48
int32_t function_11984(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4,
                       int32_t i_a5, int32_t i_a6, int32_t i_a7) {
    int32_t i_v1 = 2 * i_a2 - 0x651e95c5;              // 0x119ac
    int32_t i_v2 = -0x4b6d4991 * function_11460(i_a1); // 0x119d4
    int32_t i_v3 = function_11460(i_a1 + 8);           // 0x119f4
    int32_t i_v4 = i_a2 + i_a1;
    int32_t i_v5 = function_11460(i_v4 - 8) * i_v1;         // 0x11a34
    int32_t i_v6 = -0x651e95c5 * function_11460(i_v4 - 16); // 0x11a74
    uint32_t i_v7 = i_v2 >> 31;
    int32_t i_v8 = i_v3 >> 31;
    int32_t i_v9 = i_v7 + i_v8;                                // 0x11a90
    int32_t i_v10 = i_v2 + i_v3 + (int32_t)(i_v9 < i_v7);      // 0x11a94
    uint32_t i_v11 = function_114e4((int64_t)i_v9, i_v10, 43); // 0x11aa4
    int32_t i_v12 = i_v5 >> 31;
    uint32_t i_v13 =
        function_114e4((int64_t)i_v12, i_v5, 30) + i_v11;       // 0x11ac4
    int32_t i_v14 = i_v13 + (i_v6 >> 31);                       // 0x11ad0
    uint32_t i_v15 = __asm_vmov(__asm_vldr(0x2f90404f));        // 0x11ae0
    int32_t i_v16 = i_v15 + i_v8;                               // 0x11ae4
    int32_t i_v17 = i_v15 + i_v3 + (int32_t)(i_v16 < i_v15);    // 0x11ae8
    uint32_t i_v18 = function_114e4((int64_t)i_v16, i_v17, 18); // 0x11af0
    uint32_t i_v19 = i_v18 + i_v7;                              // 0x11af8
    uint32_t i_v20 = __asm_vmov(__asm_vmov_2(
        i_v19, i_v17 + i_v2 + (int32_t)(i_v19 < i_v18))); // 0x11b08
    int32_t i_v21 = i_v20 + i_v12;                        // 0x11b0c
    return function_11550((int64_t)i_v14,
                          i_v6 + i_v5 + i_v10 + (int32_t)(i_v13 < i_v11) +
                              (int32_t)(i_v14 < i_v13),
                          (int64_t)i_v21,
                          i_v20 + i_v5 + (int32_t)(i_v21 < i_v20), i_v1 >> 31,
                          i_v1);
}

// Address range: 0x11b4c - 0x11d44
int32_t function_11b4c(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    int32_t i_v1 = i_a1; // 0x11b4c
    bool i_v2;           // 0x11b4c
    if (i_v2 || !i_v2) {
        i_v1 = function_ff86c440();
    }
    int32_t i_v3 = 2 * i_a2 - 0x651e95c5;              // 0x11b84
    int32_t i_v4 = -0x651e95c5 * function_11460(i_v1); // 0x11bac
    int32_t i_v5 = function_11460(i_v1 + 8);           // 0x11bcc
    int32_t i_v6 = i_v1 + i_a2;
    int32_t i_v7 = function_11460(i_v6 - 8) * i_v3; // 0x11c0c
    int32_t i_v8 = function_11460(i_v6 - 16);       // 0x11c34
    uint32_t i_v9 = i_v4 >> 31;
    int32_t i_v10 = i_v5 >> 31;
    int32_t i_v11 = i_v9 + i_v10;                              // 0x11c68
    int32_t i_v12 = i_v4 + i_v5 + (int32_t)(i_v11 < i_v9);     // 0x11c6c
    int32_t i_v13 = function_114e4((int64_t)i_v11, i_v12, 43); // 0x11c7c
    int32_t i_v14 = i_v7 >> 31;
    uint32_t i_v15 = function_114e4((int64_t)i_v14, i_v7, 30); // 0x11c90
    uint32_t i_v16 = i_v15 + i_v13;                            // 0x11c9c
    float64_t f_v17 =
        __asm_vmov_2(i_v16, i_v12 + i_v7 + (int32_t)(i_v16 < i_v15)); // 0x11ca4
    int32_t i_v18 = __asm_vmov(f_v17) + (-0x651e95c5 * i_v8 >> 31);   // 0x11cb0
    int32_t i_v19 = i_v10 - 0x651e95c5;                               // 0x11cc8
    int32_t i_v20 =
        i_v5 + 0x2f90404f + (int32_t)(i_v19 < 0x9ae16a3b);      // 0x11ccc
    uint32_t i_v21 = function_114e4((int64_t)i_v19, i_v20, 18); // 0x11cd4
    uint32_t i_v22 = i_v21 + i_v9;                              // 0x11cdc
    int32_t i_v23 = i_v22 + i_v14;                              // 0x11ce8
    function_11550((int64_t)(i_v18 >> 31), i_v18, (int64_t)i_v23,
                   i_v7 + i_v4 + i_v20 + (int32_t)(i_v22 < i_v21) +
                       (int32_t)(i_v23 < i_v22),
                   i_v3 >> 31, i_v3);
    function_11460(i_v1 + 16);
    return i_v3;
}

// Address range: 0x11d48 - 0x11ec8
int32_t function_11d48(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x11d48
    int32_t i_v1;             // 0x11d48
    int32_t i_v2 = i_v1 - 84; // 0x11d48
    *(int32_t *)i_v2 = i_a3;
    *(int32_t *)(i_v1 - 80) = i_a4;
    int32_t *p_v3 = (int32_t *)(i_v1 - 112);   // 0x11d50
    int32_t i_v4 = function_11460(*p_v3 + 24); // 0x11d5c
    int32_t i_v5 = i_v1 - 92;                  // 0x11d60
    *(int32_t *)i_v5 = i_v4;
    *(int32_t *)(i_v1 - 88) = i_a2;
    int32_t *p_v6 = (int32_t *)(i_v1 - 116);           // 0x11d64
    int32_t i_v7 = function_11460(*p_v6 - 32 + *p_v3); // 0x11d78
    uint64_t i_v8 = *(int64_t *)(i_v1 - 68);           // 0x11d7c
    uint32_t i_v9 = (int32_t)(i_v8 / 0x100000000);     // 0x11d7c
    uint32_t i_v10 = i_v7 + i_v9;                      // 0x11d80
    int32_t *p_v11 = (int32_t *)(i_v1 - 24);           // 0x11d88
    int32_t i_v12 = *p_v11;                            // 0x11d88
    int32_t i_v13 = i_v1 - 28;                         // 0x11d90
    int32_t *p_v14 = (int32_t *)i_v13;                 // 0x11d90
    uint32_t i_v15 = *p_v14;                           // 0x11d90
    uint64_t i_v16 = (int64_t)i_v10 * (int64_t)i_v15;  // 0x11da0
    int32_t i_v17 = ((int32_t)i_v8 + i_a2 + (int32_t)(i_v10 < i_v9)) * i_v15 +
                    i_v10 * i_v12 + (int32_t)(i_v16 / 0x100000000); // 0x11da4
    int32_t i_v18 = i_v1 - 100;                                     // 0x11dac
    *(int32_t *)i_v18 = (int32_t)i_v16;
    *(int32_t *)(i_v1 - 96) = i_v17;
    int32_t i_v19 = function_11460(*p_v6 - 24 + *p_v3); // 0x11dc8
    uint64_t i_v20 = *(int64_t *)(i_v1 - 76);           // 0x11dcc
    uint32_t i_v21 = (int32_t)(i_v20 / 0x100000000);    // 0x11dcc
    uint32_t i_v22 = i_v19 + i_v21;                     // 0x11dd0
    int32_t i_v23 = *p_v11;                             // 0x11dd8
    uint32_t i_v24 = *p_v14;                            // 0x11de0
    uint64_t i_v25 = (int64_t)i_v22 * (int64_t)i_v24;   // 0x11df0
    int32_t i_v26 = i_v1 - 108;                         // 0x11dfc
    *(int32_t *)i_v26 = (int32_t)i_v25;
    *(int32_t *)(i_v1 - 104) =
        (i_v17 + (int32_t)i_v20 + (int32_t)(i_v22 < i_v21)) * i_v24 +
        i_v22 * i_v23 + (int32_t)(i_v25 / 0x100000000);
    int64_t *p_v27 = (int64_t *)i_v2;                       // 0x11e04
    uint64_t i_v28 = *p_v27;                                // 0x11e04
    uint32_t i_v29 = (int32_t)(i_v28 / 0x100000000);        // 0x11e04
    int64_t *p_v30 = (int64_t *)i_v5;                       // 0x11e08
    uint64_t i_v31 = *p_v30;                                // 0x11e08
    int32_t i_v32 = (int32_t)(i_v31 / 0x100000000) + i_v29; // 0x11e0c
    int32_t i_v33 =
        (int32_t)i_v31 + (int32_t)i_v28 + (int32_t)(i_v32 < i_v29);  // 0x11e10
    uint32_t i_v34 = function_114e4((int64_t)i_v32, i_v33, 43);      // 0x11e20
    int64_t *p_v35 = (int64_t *)i_v18;                               // 0x11e30
    int64_t i_v36 = *p_v35;                                          // 0x11e30
    int32_t i_v37 = i_v36;                                           // 0x11e30
    uint32_t i_v38 = function_114e4(i_v36 >> 32, i_v37, 30) + i_v34; // 0x11e40
    uint64_t i_v39 = *(int64_t *)i_v26;                              // 0x11e48
    int32_t i_v40 = i_v38 + (int32_t)(i_v39 / 0x100000000);          // 0x11e4c
    uint64_t i_v41 = *p_v30;                                         // 0x11e54
    uint32_t i_v42 = (int32_t)(i_v41 / 0x100000000);                 // 0x11e54
    uint64_t i_v43 = *(int64_t *)(i_v1 - 36);                        // 0x11e58
    uint32_t i_v44 = (int32_t)(i_v43 / 0x100000000) + i_v42;         // 0x11e5c
    int32_t i_v45 = __asm_vmov(
        __asm_vmov_2(i_v44, (int32_t)i_v43 + (int32_t)i_v41 +
                                (int32_t)(i_v44 < i_v42)));     // 0x11e6c
    uint32_t i_v46 = function_114e4((int64_t)i_v45, i_v45, 18); // 0x11e70
    uint64_t i_v47 = *p_v27;                                    // 0x11e74
    uint32_t i_v48 = i_v46 + (int32_t)(i_v47 / 0x100000000);    // 0x11e78
    float64_t f_v49 = __asm_vmov_2(
        i_v48, i_v45 + (int32_t)i_v47 + (int32_t)(i_v48 < i_v46)); // 0x11e80
    uint64_t i_v50 = *p_v35;                                       // 0x11e84
    uint32_t i_v51 = __asm_vmov(f_v49);                            // 0x11e88
    int32_t i_v52 = i_v51 + (int32_t)(i_v50 / 0x100000000);        // 0x11e8c
    uint64_t i_v53 = *(int64_t *)i_v13;                            // 0x11e94
    return function_11550(
        (int64_t)i_v40,
        (int32_t)i_v39 + i_v37 + i_v33 + (int32_t)(i_v38 < i_v34) +
            (int32_t)(i_v40 < i_v38),
        (int64_t)i_v52, i_v51 + (int32_t)i_v50 + (int32_t)(i_v52 < i_v51),
        (int32_t)(i_v53 / 0x100000000), (int32_t)i_v53);
}

// Address range: 0x11ec8 - 0x11fd4
int32_t function_11ec8(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4,
                       uint64_t i_a5) {
    // 0x11ec8
    int32_t i_v1; // 0x11ec8
    bool i_v2;    // 0x11ec8
    if (i_v2) {
        __asm_svchs(0x90404f);
        i_v1 = i_a1;
        if (i_v2) {
            // .thread
            i_v1 = function_ff86c7c0();
            goto lab_0x11ed0;
        } else {
            goto lab_0x11ed0;
        }
    } else {
        // .thread
        i_v1 = function_ff86c7c0();
        goto lab_0x11ed0;
    }
lab_0x11ed0:;
    // 0x11ed0
    int64_t i_v3;                      // 0x11ec8
    int32_t i_v4 = i_v3;               // 0x11ee4
    int32_t i_v5 = i_v3 / 0x100000000; // 0x11ee4
    uint32_t i_v6 = i_a3 >> 31;
    uint32_t i_v7 = i_v6 + i_v5; // 0x11eec
    __asm_vstr(__asm_vmov_2(i_v7, i_v4 + i_a3 + (int32_t)(i_v7 < i_v6)), i_v4);
    uint32_t i_v8 = (int32_t)(i_v3 / 0x100000000);  // 0x11efc
    uint32_t i_v9 = i_v5 + i_v8;                    // 0x11f04
    int32_t i_v10 = i_v3;                           // 0x11f10
    uint32_t i_v11 = (int32_t)(i_v3 / 0x100000000); // 0x11f10
    uint32_t i_v12 = __asm_vmov(__asm_vmov_2(
        i_v9, i_v4 + (int32_t)i_v3 + (int32_t)(i_v9 < i_v8))); // 0x11f14
    int32_t i_v13 = i_v12 + i_v11;                             // 0x11f18
    int32_t i_v14 =
        function_114e4((int64_t)i_v13, i_v12 + i_v10 + (int32_t)(i_v13 < i_v12),
                       21);                         // 0x11f24
    uint32_t i_v15 = (int32_t)(i_a5 / 0x100000000); // 0x11f38
    uint32_t i_v16 = i_v5 + i_v15;                  // 0x11f3c
    __asm_vstr(
        __asm_vmov_2(i_v16, i_v4 + (int32_t)i_a5 + (int32_t)(i_v16 < i_v15)),
        i_v4);
    uint32_t i_v17 = (int32_t)(i_v3 / 0x100000000); // 0x11f50
    uint32_t i_v18 = i_v5 + i_v17;                  // 0x11f54
    __asm_vstr(
        __asm_vmov_2(i_v18, i_v4 + (int32_t)i_v3 + (int32_t)(i_v18 < i_v17)),
        i_v4);
    uint64_t i_v19 = i_v3 >> 32;                              // 0x11f6c
    uint32_t i_v20 = i_v14 >> 31;                             // 0x11f70
    uint32_t i_v21 = function_114e4(i_v19, i_v4, 44) + i_v20; // 0x11f74
    __asm_vstr(__asm_vmov_2(i_v21, i_v14 + i_v4 + (int32_t)(i_v21 < i_v20)),
               i_v14);
    uint32_t i_v22 = i_v5 + i_v11; // 0x11f8c
    int32_t i_v23;                 // 0x11ec8
    __asm_vstr(__asm_vmov_2(i_v22, i_v4 + i_v10 + (int32_t)(i_v22 < i_v11)),
               i_v23);
    uint32_t i_v24 = (int32_t)(i_v19 / 0x100000000); // 0x11fa0
    uint32_t i_v25 = i_v20 + i_v24;                  // 0x11fa4
    __asm_vstr(
        __asm_vmov_2(i_v25, i_v14 + (int32_t)i_v19 + (int32_t)(i_v25 < i_v24)),
        i_v23);
    return i_v1;
}

// Address range: 0x11fd4 - 0x12078
int32_t function_11fd4(int32_t *p_a1, int32_t i_a2, int64_t i_a3, int32_t i_a4,
                       int32_t i_a5) {
    // 0x11fd4
    function_11460(i_a2);
    function_11460(i_a2 + 8);
    function_11460(i_a2 + 16);
    function_11460(i_a2 + 24);
    return (int32_t)p_a1;
}

// Address range: 0x12078 - 0x128a0
int32_t function_12078(int32_t i_a1, uint32_t i_a2, int32_t i_a3,
                       int32_t i_a4) {
    // 0x12078
    if (i_a2 >= 16 != i_a2 != 16) {
        // 0x12890
        return function_11674(i_a1, i_a2);
    }
    // 0x120bc
    if (i_a2 >= 32 != i_a2 != 32 || i_a2 >= 64 != i_a2 != 64) {
        // 0x12890
        return i_a1;
    }
    int32_t i_v1 =
        -0x651e95c5 * function_11498(0x413964a1, -0x709bf205); // 0x12198
    int64_t i_v2;                                              // 0x12078
    __asm_vstr(__asm_vmov_i32_3(0), (int32_t)i_v2);
    int32_t i_v3 = i_v2;
    __asm_vstr(__asm_vmov_i32_3(0), i_v3);
    __asm_vstr(__asm_vmov_i32_3(0), (int32_t)i_v2);
    int32_t i_v4 = i_v2; // 0x121c8
    __asm_vstr(__asm_vmov_i32_3(0), i_v4);
    int32_t i_v5 = function_11460(i_a1);    // 0x121fc
    int32_t i_v6 = (i_a2 - 1 & -64) + i_a1; // 0x1221c
    uint32_t i_v7 = (i_a2 + 63) % 64;       // 0x1222c
    uint64_t i_v8 = 0x100000000 * i_v2 >> 32;
    int32_t i_v9 = i_v8;
    uint64_t i_v10 = i_v8 / 0x100000000;
    uint32_t i_v11 = (int32_t)i_v10;
    int32_t i_v12 = 2 * i_v3;
    int32_t i_v13 = -0x41670d8d * i_v11;
    int32_t i_v14 = i_v13 + -0x4b6d4991 * i_v9 +
                    (int32_t)(0xb492b66f * i_v10 / 0x100000000);
    uint64_t i_v15 = 0x100000000 * i_v2 >> 32;
    int32_t i_v16 = i_v15;
    uint32_t i_v17 = (int32_t)(i_v15 / 0x100000000);
    int32_t i_v18 = i_v5 >> 31;                              // 0x1223c
    int32_t i_v19 = 0x226bb990;                              // 0x1223c
    int32_t i_v20 = 0;                                       // 0x1223c
    int32_t i_v21 = i_v1 >> 31;                              // 0x1223c
    int32_t i_v22 = i_a1;                                    // 0x1223c
    uint32_t i_v23 = i_v20 + i_v18;                          // 0x12248
    int64_t i_v24;                                           // 0x12078
    uint64_t i_v25 = 0x100000000 * i_v24 >> 32;              // 0x12250
    uint32_t i_v26 = i_v23 + (int32_t)(i_v25 / 0x100000000); // 0x12254
    int32_t i_v27 = function_11460(i_v22 + 8) + i_v26;       // 0x12274
    int32_t i_v28 = function_114e4(
        (int64_t)i_v27,
        i_v19 + 2 * i_v18 + (int32_t)i_v25 + (int32_t)(i_v23 < i_v18) +
            (int32_t)(i_v26 < i_v23) + (int32_t)(i_v27 < i_v26),
        37);                                            // 0x12280
    uint32_t i_v29 = i_v20 + i_v11;                     // 0x122b4
    int32_t i_v30 = function_11460(i_v22 + 48) + i_v29; // 0x122d4
    int32_t i_v31 = function_114e4((int64_t)i_v30,
                                   i_v19 + i_v12 + (int32_t)(i_v29 < i_v11) +
                                       (int32_t)(i_v30 < i_v29),
                                   42); // 0x122e0
    int64_t i_v32;                      // bp-96, 0x12078
    i_v19 = (-0x4b6d4991 * i_v31 >> 31) + function_11460(i_v22 + 40) +
            (int32_t)((0x100000000 * i_v32 >> 32) / 0x100000000);
    int64_t i_v33;                                   // bp-112, 0x12078
    uint64_t i_v34 = 0x100000000 * i_v33 >> 32;      // 0x12354
    uint32_t i_v35 = (int32_t)(i_v34 / 0x100000000); // 0x12354
    int32_t i_v36 = i_v21 + i_v35;                   // 0x1235c
    int32_t i_v37 = -0x4b6d4991 * function_114e4((int64_t)i_v36,
                                                 i_v21 + (int32_t)i_v34 +
                                                     (int32_t)(i_v36 < i_v35),
                                                 33); // 0x12380
    i_v21 = (-0x4b6d4991 * i_v28 ^ i_v4) >> 31;
    int32_t i_v38 =
        i_v21 + (int32_t)((0x100000000 * i_v33 >> 32) / 0x100000000); // 0x123c0
    function_11fd4((int32_t *)&i_v32, i_v22,
                   -0x4b6d499100000000 * i_v10 / 0x100000000, i_v14, i_v38);
    i_v18 = i_v37 >> 31;
    int32_t i_v39 = i_v18 + i_v17; // 0x123ec
    i_v20 = i_v19 >> 31;
    uint32_t i_v40 = i_v20 + function_11460(i_v22 + 16); // 0x12408
    __asm_vstr(__asm_vmov_2(i_v40, i_v19 + i_v16 + (int32_t)(i_v40 < i_v20)),
               i_v38);
    function_11fd4((int32_t *)&i_v33, i_v22 + 32, (int64_t)i_v39,
                   i_v37 + i_v16 + (int32_t)(i_v39 < i_v17), (int32_t)&i_g7);
    i_v22 += 64;
    while (i_v22 != i_v6) {
        // 0x12240
        i_v23 = i_v20 + i_v18;
        i_v25 = 0x100000000 * i_v32 >> 32;
        i_v26 = i_v23 + (int32_t)(i_v25 / 0x100000000);
        i_v27 = function_11460(i_v22 + 8) + i_v26;
        i_v28 = function_114e4(
            (int64_t)i_v27,
            i_v19 + 2 * i_v18 + (int32_t)i_v25 + (int32_t)(i_v23 < i_v18) +
                (int32_t)(i_v26 < i_v23) + (int32_t)(i_v27 < i_v26),
            37);
        i_v29 = i_v20 + i_v11;
        i_v30 = function_11460(i_v22 + 48) + i_v29;
        i_v31 = function_114e4((int64_t)i_v30,
                               i_v19 + i_v12 + (int32_t)(i_v29 < i_v11) +
                                   (int32_t)(i_v30 < i_v29),
                               42);
        i_v19 = (-0x4b6d4991 * i_v31 >> 31) + function_11460(i_v22 + 40) +
                (int32_t)((0x100000000 * i_v32 >> 32) / 0x100000000);
        i_v34 = 0x100000000 * i_v33 >> 32;
        i_v35 = (int32_t)(i_v34 / 0x100000000);
        i_v36 = i_v21 + i_v35;
        i_v37 = -0x4b6d4991 * function_114e4((int64_t)i_v36,
                                             i_v21 + (int32_t)i_v34 +
                                                 (int32_t)(i_v36 < i_v35),
                                             33);
        i_v21 = (-0x4b6d4991 * i_v28 ^ i_v4) >> 31;
        i_v38 = i_v21 + (int32_t)((0x100000000 * i_v33 >> 32) / 0x100000000);
        function_11fd4((int32_t *)&i_v32, i_v22,
                       -0x4b6d499100000000 * i_v10 / 0x100000000, i_v14, i_v38);
        i_v18 = i_v37 >> 31;
        i_v39 = i_v18 + i_v17;
        i_v20 = i_v19 >> 31;
        i_v40 = i_v20 + function_11460(i_v22 + 16);
        __asm_vstr(
            __asm_vmov_2(i_v40, i_v19 + i_v16 + (int32_t)(i_v40 < i_v20)),
            i_v38);
        function_11fd4((int32_t *)&i_v33, i_v22 + 32, (int64_t)i_v39,
                       i_v37 + i_v16 + (int32_t)(i_v39 < i_v17),
                       (int32_t)&i_g7);
        i_v22 += 64;
    }
    int32_t i_v41 = i_v7 - 63 + i_v6;            // 0x12238
    uint32_t i_v42 = (i_v21 & 510) - 0x4b6d4991; // 0x124b0
    int32_t i_v43 =
        (i_v7 + (int32_t)((0x100000000 * i_v33 >> 32) / 0x100000000)) /
        0x80000000;
    int32_t i_v44 =
        i_v43 + (int32_t)((0x100000000 * i_v32 >> 32) / 0x100000000); // 0x124fc
    i_v32 = i_v44;
    int32_t i_v45 = i_v44 >> 31;
    i_v33 = i_v45 + i_v43;
    uint32_t i_v46 = i_v20 + i_v18;                    // 0x12544
    uint32_t i_v47 = i_v45 + i_v46;                    // 0x12550
    int32_t i_v48 = i_v47 + function_11460(i_v41 + 8); // 0x12570
    int32_t i_v49 =
        function_114e4((int64_t)i_v48,
                       2 * i_v18 + i_v19 + (int32_t)(i_v46 < i_v18) + i_v44 +
                           (int32_t)(i_v47 < i_v46) + (int32_t)(i_v48 < i_v47),
                       37);                             // 0x1257c
    uint32_t i_v50 = i_v20 + i_v11;                     // 0x125bc
    int32_t i_v51 = function_11460(i_v41 + 48) + i_v50; // 0x125dc
    int32_t i_v52 = function_114e4((int64_t)i_v51,
                                   i_v19 + i_v12 + (int32_t)(i_v50 < i_v11) +
                                       (int32_t)(i_v51 < i_v50),
                                   42); // 0x125e8
    int32_t i_v53 =
        __asm_vmov(__asm_vshl_i64(__asm_vmov_2(i_v17, i_v16), 3)); // 0x1262c
    uint64_t i_v54 = 0x100000000 * i_v32 >> 32;                    // 0x12650
    int32_t i_v55 = i_v54 / 0x100000000;                           // 0x12650
    int32_t i_v56 = __asm_vmov(
        __asm_vshl_i64(__asm_vmov_2(i_v55, (int32_t)i_v54), 3)); // 0x1265c
    int32_t i_v57 = i_v56 + i_v52 * i_v42 / 0x80000000 + i_v55 +
                    function_11460(i_v41 + 40);      // 0x1268c
    uint64_t i_v58 = 0x100000000 * i_v33 >> 32;      // 0x12698
    uint32_t i_v59 = (int32_t)(i_v58 / 0x100000000); // 0x12698
    int32_t i_v60 = i_v21 + i_v59;                   // 0x126a0
    int32_t i_v61 =
        function_114e4((int64_t)i_v60,
                       i_v21 + (int32_t)i_v58 + (int32_t)(i_v60 < i_v59), 33) *
        i_v42;                               // 0x126d0
    uint64_t i_v62 = i_v10 * (int64_t)i_v42; // 0x12700
    int32_t i_v63 = (i_v53 + i_v17 ^ i_v49 * i_v42) / 0x80000000;
    int32_t i_v64 =
        i_v63 + (int32_t)((0x100000000 * i_v33 >> 32) / 0x100000000); // 0x12714
    int64_t i_v65; // bp-136, 0x12078
    function_11fd4((int32_t *)&i_v65, i_v41, 0x100000000 * i_v62 / 0x100000000,
                   i_v42 * i_v9 + i_v13 + (int32_t)(i_v62 / 0x100000000),
                   i_v64);
    i_v32 = 0x100000000 * i_v65 >> 32;
    int32_t i_v66 = i_v61 >> 31;
    int32_t i_v67 = i_v66 + i_v17; // 0x12750
    uint32_t i_v68 = i_v57 >> 31;
    uint32_t i_v69 = function_11460(i_v41 + 16) + i_v68; // 0x1276c
    __asm_vstr(__asm_vmov_2(i_v69, i_v57 + i_v16 + (int32_t)(i_v69 < i_v68)),
               i_v64);
    function_11fd4((int32_t *)&i_v65, i_v41 + 32, (int64_t)i_v67,
                   i_v61 + i_v16 + (int32_t)(i_v67 < i_v17), (int32_t)&i_g7);
    int64_t i_v70 = 0x100000000 * i_v65;
    int64_t i_v71 = i_v70 >> 32; // 0x1279c
    i_v33 = i_v71;
    int32_t i_v72 = i_v32; // 0x127dc
    function_11550(0x100000000 * i_v32 >> 63, i_v72, i_v70 >> 63,
                   (int32_t)i_v71, -1, i_v42);
    uint32_t i_v73 = function_11498(i_v68, i_v57); // 0x12804
    int32_t i_v74 = i_v2;                          // 0x1283c
    int64_t i_v75 = 0x100000000 * i_v2 >> 63;      // 0x12854
    uint32_t i_v76 =
        function_11550(i_v75, i_v74, i_v75, i_v74, -1, i_v42); // 0x12854
    int32_t i_v77 = i_v76 + i_v66;                             // 0x12864
    // 0x12890
    return function_11550(
        0,
        -0x3c5a37a4 * i_v57 + i_v63 + i_v72 + -0x6834ced9 * i_v73 + i_v73 / 2,
        (int64_t)i_v77, i_v66 + i_v74 + (int32_t)(i_v77 < i_v76), -1, i_v42);
}

// Address range: 0x128a0 - 0x133d0
int32_t function_128a0(int32_t *p_a1, int32_t *p_a2, int32_t *p_a3,
                       int32_t *p_a4, uint32_t i_a5, uint32_t i_a6,
                       uint32_t i_a7) {
    int32_t i_v1 = (int32_t)p_a1;
    int32_t i_v2; // bp-200, 0x128a0
    function_137f4(i_v1, &i_v2);
    int64_t i_v3;                      // 0x128a0
    int32_t i_v4 = i_v3 / 0x100000000; // 0x128d0
    int32_t i_v5 = i_v4;               // 0x128dc
    if (i_v4 <= 2047) {
        // 0x128e8
        function_107bc("File '%s' Not Enough %d, Something Wrong!\n", i_v1,
                       2048, i_v4);
        i_v5 = 6;
        // 0x133c4
        return 6;
    }
    int32_t *p_v6 = (int32_t *)i_v4;                       // 0x12910
    int32_t i_v7 = function_10798(i_v1, "rb", i_v4, p_v6); // 0x12910
    i_v5 = i_v7;
    if (i_v7 == 0) {
        // 0x12924
        function_107bc("Read File '%s' Failed!\n", i_v1, i_v4, 0);
        i_v5 = 7;
        // 0x133c4
        return 7;
    }
    // 0x1293c
    function_1082c(p_a4, 2048, 1, i_v7);
    unsigned char i_v8 = *(char *)&i_v5; // 0x12954
    int32_t i_v9 = i_v8;                 // 0x12954
    i_v5 = i_v9;
    if (i_v8 != 38) {
        // 0x12984
        function_107bc("'%s' Not A Btmu File!\n", i_v1, 1, i_v9);
        function_10738(i_v7);
        i_v5 = 8;
        // 0x133c4
        return 8;
    }
    int32_t i_v10 = (int32_t)p_a4;
    int32_t i_v11 = (int32_t)p_a2;
    function_107bc("miner_type %s\n", i_v11, 1, i_v9);
    int32_t i_v12 = function_10780(p_a2);                   // 0x129a0
    int32_t i_v13 = function_12078(i_v11, i_v12, 1, i_v12); // 0x129b0
    int32_t i_v14 = i_v10 + 2;                              // 0x129bc
    int64_t i_v15;                                          // bp-208, 0x128a0
    function_1078c((int32_t *)&i_v15, i_v14, 8, (int32_t *)&i_v15);
    int32_t i_v16 = i_v13 >> 31;
    function_107bc("miner_type_hash %16llx, bmu_hash %16llx\n", i_v14, i_v16,
                   i_v13);
    uint64_t i_v17 = 0x100000000 * i_v15 >> 32; // 0x129e8
    int32_t i_v18 = i_v17;                      // 0x129e8
    int32_t i_v19 = i_v17 / 0x100000000;        // 0x129e8
    i_v5 = i_v18;
    if (i_v13 == i_v18 != (i_v16 == i_v19)) {
        // 0x12a1c
        function_107f0("input miner_type and bmu miner type donot match!",
                       i_v13, i_v19, i_v18);
        function_10738(i_v7);
        i_v5 = 30;
        // 0x133c4
        return 30;
    }
    int32_t i_v20 =
        __asm_sxth(256 * (int32_t) * (char *)(i_v10 + 11)); // 0x12a38
    uint32_t i_v21 = __asm_sxth(__asm_sxth((int32_t) * (char *)(i_v10 + 12)) |
                                i_v20); // 0x12a4c
    int32_t i_v22;                      // 0x128a0
    if (i_a7 % 256 == 0) {
        // 0x12a24
        i_v22 = i_v21 % 0x10000;
    } else {
        int32_t i_v23 = i_v21 % 0x10000;
        function_107bc("content:%x\n", i_v23, i_v20, i_v23);
        int32_t i_v24 = i_v21 & 0xfe00; // 0x12a78
        i_v5 = i_v24;
        i_v22 = i_v23;
        if ((int16_t)i_v21 <= 0xfdff) {
            // 0x12a84
            function_107f0("This Package Was Not Full Package!", i_v23, i_v20,
                           i_v24);
            i_v5 = 20;
            // 0x133c4
            return 20;
        }
    }
    int32_t i_v25 = (int32_t)p_a3;
    int32_t i_v26 = i_a6 % 256;
    int32_t i_v27 = i_a5 % 256;
    unsigned char i_v28 = 0;
    for (int32_t i_v29 = 0; i_v29 < 16; i_v29++) {
        // 0x12aa4
        i_v28 += (char)((1 << i_v29 & i_v22) != 0);
    }
    unsigned char i_v30 = *(char *)(i_v10 + 1304); // 0x12ae4
    int32_t i_v31 = i_v30;
    if (i_v28 != i_v30) {
        int32_t i_v32 = i_v28; // 0x12b00
        function_107bc("Content Doesn't Match![%d][%d]\n", i_v31, i_v32, i_v32);
        function_10738(i_v7);
        i_v5 = 9;
        // 0x133c4
        return 9;
    }
    int32_t i_v33 = 256 * i_v31 + 2304;            // 0x12b3c
    unsigned char i_v34 = *(char *)(i_v10 + 1305); // 0x12b48
    unsigned char i_v35 = *(char *)(i_v10 + 1306); // 0x12b54
    unsigned char i_v36 = *(char *)(i_v10 + 1307); // 0x12b64
    unsigned char i_v37 = *(char *)(i_v10 + 1308); // 0x12b74
    uint32_t i_v38 = (int32_t)i_v28;               // 0x12c64
    int32_t i_v39 = 0;                             // 0x12c70
    int32_t i_v40 = i_v33;                         // 0x12c70
    int32_t i_v41 = i_v33;                         // 0x12c70
    if (i_v28 != 0) {
        int32_t i_v42 = 5 * i_v39 + i_v10;             // 0x12ba0
        unsigned char i_v43 = *(char *)(i_v42 + 1310); // 0x12bac
        unsigned char i_v44 = *(char *)(i_v42 + 1311); // 0x12bd4
        unsigned char i_v45 = *(char *)(i_v42 + 1312); // 0x12bfc
        unsigned char i_v46 = *(char *)(i_v42 + 1313); // 0x12c28
        int32_t i_v47 = 0x10000 * (int32_t)i_v44 | 0x1000000 * (int32_t)i_v43 |
                        256 * (int32_t)i_v45 | (int32_t)i_v46; // 0x12c2c
        i_v40 += i_v47;
        function_107bc("file[%d] size:[%d]\n", i_v39, i_v47, i_v40);
        i_v39++;
        i_v41 = i_v40;
        while (i_v39 < i_v38) {
            // 0x12b8c
            i_v42 = 5 * i_v39 + i_v10;
            i_v43 = *(char *)(i_v42 + 1310);
            i_v44 = *(char *)(i_v42 + 1311);
            i_v45 = *(char *)(i_v42 + 1312);
            i_v46 = *(char *)(i_v42 + 1313);
            i_v47 = 0x10000 * (int32_t)i_v44 | 0x1000000 * (int32_t)i_v43 |
                    256 * (int32_t)i_v45 | (int32_t)i_v46;
            i_v40 += i_v47;
            function_107bc("file[%d] size:[%d]\n", i_v39, i_v47, i_v40);
            i_v39++;
            i_v41 = i_v40;
        }
    }
    // 0x12c74
    i_v5 = i_v4;
    if (i_v41 != i_v4) {
        // 0x12cb0
        function_107bc("Check FileSize Failed, FileSize Should Be [%d]Bytes, "
                       "But It Was [%d] Bytes, And Total Says[%d]\n",
                       0x10000 * (int32_t)i_v35 | 0x1000000 * (int32_t)i_v34 |
                           256 * (int32_t)i_v36 | (int32_t)i_v37,
                       i_v4, i_v41);
        function_10738(i_v7);
        i_v5 = 10;
        // 0x133c4
        return 10;
    }
    int32_t i_v48 = function_10798(i_v25, "r", i_v4, p_v6); // 0x12cc4
    i_v5 = i_v48;
    if (i_v48 == 0) {
        // 0x12cfc
        function_107bc("Cannot Open Root PublicKey '%s'!\n", i_v25, i_v4, 0);
        function_10738(i_v7);
        i_v5 = 11;
        // 0x133c4
        return 11;
    }
    int32_t i_v49 = 0; // bp-1232, 0x12d08
    int32_t i_v50;     // bp-1228, 0x128a0
    function_10744(&i_v50, 0, 1020, &i_v50);
    function_1082c(&i_v49, 1024, 1, i_v48);
    function_10738(i_v48);
    unsigned char i_v51 = *(char *)(i_v10 + 23); // 0x12d64
    int32_t i_v52 =
        256 * (int32_t) * (char *)(i_v10 + 22) | (int32_t)i_v51; // 0x12d68
    int32_t i_v53 = i_v10 + 24;                                  // 0x12d74
    int32_t i_v54 = i_v10 + 1048;                                // 0x12d84
    int32_t i_v55 = function_10c50(i_v53, i_v52, i_v54, &i_v49); // 0x12d94
    i_v5 = i_v55;
    if (i_v55 != 0) {
        // 0x12dcc
        function_107bc("Check pem payload failed! ret:[%d]\n", i_v55, i_v54,
                       i_v55);
        function_10738(i_v7);
        i_v5 = i_v55;
        // 0x133c4
        return i_v55;
    }
    int32_t i_v56 = function_10798((int32_t) "/usr/bin/fw_version", "w", i_v54,
                                   NULL); // 0x12de4
    int32_t i_v57 = i_v54;                // 0x12df4
    if (i_v56 != 0) {
        // 0x12df8
        function_107d4((int32_t *)(i_v10 + 13), 1, 8, i_v56);
        function_10738(i_v56);
        i_v57 = 8;
    }
    // 0x12e18
    i_v5 = i_v27;
    if (i_v27 != 0) {
        int32_t i_v58 = function_10798((int32_t) "/tmp/tmpfw/miner.pem", "w",
                                       i_v57, (int32_t *)i_v27); // 0x12e34
        i_v5 = i_v58;
        if (i_v58 == 0) {
            // 0x12e90
            function_107f0("Dump Miner.pem Failed!\r", (int32_t) "w", i_v57, 0);
            i_v5 = 15;
            // 0x133c4
            return 15;
        }
        // 0x12e48
        function_107d4((int32_t *)i_v53, 1, i_v52, i_v58);
        function_10738(i_v58);
        int32_t i_v59 = function_10798((int32_t) "/tmp/tmpfw/miner.pem.sig",
                                       "w", i_v52, (int32_t *)i_v58); // 0x12e78
        i_v5 = i_v59;
        if (i_v59 == 0) {
            // 0x12ecc
            function_107f0("Dump Miner.pem.sig Failed!\r", (int32_t) "w", i_v52,
                           0);
            i_v5 = 16;
            // 0x133c4
            return 16;
        }
        // 0x12ea4
        function_107d4((int32_t *)i_v54, 1, 256, i_v59);
        function_10738(i_v59);
    }
    // 0x12ee0
    int32_t i_v60; // bp-2288, 0x128a0
    function_10744(&i_v60, 0, 1056, &i_v60);
    int32_t i_v61; // bp-2400, 0x128a0
    function_10820(&i_v61);
    function_10808(&i_v61, i_v10, 2048, &i_v61);
    function_10774(&i_v60, &i_v61, &i_v61, &i_v60);
    int32_t i_v62 = &i_v60;
    if (i_v28 != 0) {
        int32_t i_v63 = i_v62 + 32; // 0x13010
        for (int32_t i_v64 = 0; i_v64 < i_v38; i_v64++) {
            int32_t i_v65 = 5 * i_v64 + i_v10;             // 0x12f70
            unsigned char i_v66 = *(char *)(i_v65 + 1310); // 0x12f7c
            unsigned char i_v67 = *(char *)(i_v65 + 1311); // 0x12fa4
            unsigned char i_v68 = *(char *)(i_v65 + 1312); // 0x12fcc
            unsigned char i_v69 = *(char *)(i_v65 + 1313); // 0x12ff8
            unsigned char i_v70 = *(char *)(i_v65 + 1309); // 0x13044
            function_10dc8(i_v7,
                           0x10000 * (int32_t)i_v67 |
                               0x1000000 * (int32_t)i_v66 |
                               256 * (int32_t)i_v68 | (int32_t)i_v69,
                           i_v63 + 32 * i_v64, (int32_t)i_v70, 0, i_v27);
        }
        int32_t i_v71 = 0;
        int32_t i_v72 = i_v71 + 1;
        unsigned char i_v73 = *(char *)(i_v10 + 1309 + 5 * i_v71); // 0x130d8
        function_10dc8(i_v7, 256, 32 * (i_v72 + i_v38) + i_v62, (int32_t)i_v73,
                       1, i_v27);
        while (i_v72 < i_v38) {
            // 0x13094
            i_v71 = i_v72;
            i_v72 = i_v71 + 1;
            i_v73 = *(char *)(i_v10 + 1309 + 5 * i_v71);
            function_10dc8(i_v7, 256, 32 * (i_v72 + i_v38) + i_v62,
                           (int32_t)i_v73, 1, i_v27);
        }
    }
    int32_t i_v74 = 0; // bp-2656, 0x13120
    int32_t i_v75;     // bp-2652, 0x128a0
    function_10744(&i_v75, 0, 252, &i_v75);
    function_1075c(i_v7, -256, 2);
    function_1082c(&i_v74, 256, 1, i_v7);
    int32_t i_v76 = 0; // bp-2688, 0x13170
    __asm_vmov_i32(0);
    float64_t f_v77; // 0x128a0
    int32_t i_v78;   // 0x128a0
    __asm_vst1_8(f_v77, f_v77, i_v78);
    __asm_vst1_8(f_v77, f_v77, i_v78);
    int32_t i_v79; // bp-2800, 0x128a0
    function_10820(&i_v79);
    function_10808(&i_v79, i_v62, 64 * i_v38 | 32, &i_v79);
    function_10774(&i_v76, &i_v79, &i_v79, &i_v76);
    int32_t i_v80 = function_107a4(i_v53, 1024);    // 0x13218
    int32_t i_v81 = function_10768(i_v80, 0, 0, 0); // 0x13230
    if (i_v81 == 0) {
        int32_t i_v82 = function_107c8(function_10714(0), 0); // 0x13254
        function_107bc("OpenSSL error: %s\n", i_v82, 0, i_v82);
        function_107f0("Load Pem Failed!", i_v82, 0, i_v82);
        i_v5 = 17;
        // 0x133c4
        return 17;
    }
    int32_t i_v83 =
        function_10750(672, &i_v76, 32, (int32_t)&i_v74, 256, i_v81); // 0x132b0
    function_107fc(i_v81);
    if (i_v80 != 0) {
        // 0x132d8
        function_10814(i_v80);
    }
    int32_t i_v84 = &i_v76; // 0x13294
    i_v5 = i_v83;
    if (i_v83 != 1) {
        int32_t i_v85 = function_107f0("Check File Sig failed!\r", i_v84, 32,
                                       i_v83);                    // 0x132f4
        int32_t i_v86 = function_107c8(function_10714(i_v85), 0); // 0x13308
        function_107bc("OpenSSL error: %s\n", i_v86, 32, i_v86);
        i_v5 = 18;
        // 0x133c4
        return 18;
    }
    // 0x1333c
    function_10738(i_v7);
    function_107f0("All Done!\r", i_v84, 32, 0);
    i_v5 = i_v26;
    if (i_v26 != 0) {
        // 0x1335c
        function_107f0("This Comment Of This Package:", i_v84, 32, i_v26);
        int32_t i_v87 = 0; // bp-3060, 0x1336c
        int32_t i_v88;     // bp-3056, 0x128a0
        function_10744(&i_v88, 0, 253, &i_v88);
        int32_t i_v89 = i_v10 + 1360; // 0x13390
        function_1078c(&i_v87, i_v89, 256, &i_v87);
        function_107f0((char *)&i_v87, i_v89, 256, (int32_t)&i_v87);
    }
    // 0x133c0
    i_v5 = 0;
    // 0x133c4
    return 0;
}

// Address range: 0x133d0 - 0x137b4
int32_t function_133d0(uint32_t i_a1, int32_t i_a2) {
    // 0x133d0
    if (i_a1 <= 1) {
        // 0x137a8
        return 1;
    }
    int32_t *p_v1 = (int32_t *)(i_a2 + 4); // 0x13414
    if (*(char *)*p_v1 != 45) {
        // 0x137a8
        return 2;
    }
    int32_t i_v2 = 0; // bp-272, 0x13440
    int32_t i_v3;     // bp-268, 0x133d0
    function_10744(&i_v3, 0, 252, &i_v3);
    int32_t i_v4 = 0; // bp-400, 0x1345c
    int32_t i_v5;     // bp-396, 0x133d0
    function_10744(&i_v5, 0, 124, &i_v5);
    int32_t i_v6 = 0; // bp-528, 0x13478
    int32_t i_v7;     // bp-524, 0x133d0
    function_10744(&i_v7, 0, 124, &i_v7);
    int32_t i_v8; // bp-2576, 0x133d0
    function_10744(&i_v8, 0, 2048, &i_v8);
    int32_t i_v9; // bp-2832, 0x133d0
    function_10744(&i_v9, 0, 253, &i_v9);
    int32_t i_v10 = 0;   // 0x133d0
    int32_t i_v11 = 253; // 0x133d0
    switch (i_a1) {
    case 5: {
        int32_t *p_v12 = (int32_t *)(i_a2 + 8);             // 0x134fc
        uint32_t i_v13 = function_10780((int32_t *)*p_v12); // 0x13504
        if (i_v13 != 255 && i_v13 >= 255) {
            // 0x13514
            function_107f0("fileName Too Long!", 0, 253, i_v13);
            // 0x137a8
            return 3;
        }
        int32_t i_v14 = *p_v12; // 0x13530
        function_107b0(&i_v2, i_v14);
        int32_t *p_v15 = (int32_t *)(i_a2 + 12);            // 0x1354c
        uint32_t i_v16 = function_10780((int32_t *)*p_v15); // 0x13554
        if (i_v16 != 127 && i_v16 >= 127) {
            // 0x13564
            function_107f0("fileName Too Long!", i_v14, i_v14, i_v16);
            // 0x137a8
            return 3;
        }
        int32_t i_v17 = *p_v15; // 0x13580
        function_107b0(&i_v4, i_v17);
        int32_t *p_v18 = (int32_t *)(i_a2 + 16);            // 0x1359c
        uint32_t i_v19 = function_10780((int32_t *)*p_v18); // 0x135a4
        if (i_v19 != 127 && i_v19 >= 127) {
            // 0x135b4
            function_107f0("pemName Too Long!", i_v17, i_v17, i_v19);
            // 0x137a8
            return 4;
        }
        int32_t i_v20 = *p_v18; // 0x135d0
        function_107b0(&i_v6, i_v20);
        i_v10 = i_v20;
        i_v11 = i_v20;
    }
    case 2: {
    lab_0x13678:;
        unsigned char i_v21 = *(char *)(*p_v1 + 1); // 0x13690
        int32_t i_v22 = (int32_t)i_v21 - 102;       // 0x13694
        i_g6 = i_v22;
        char i_v23 = 0;    // 0x1369c
        char i_v24 = 1;    // 0x1369c
        int32_t i_v25 = 0; // 0x1369c
        int32_t i_v26 = 0; // 0x1369c
        char i_v27 = 0;    // 0x1369c
        char i_v28 = 0;    // 0x1369c
        int32_t i_v29;     // 0x133d0
        switch (i_v21) {
        case 120: {
            // 0x1370c
            i_v23 = 1;
            i_v24 = 0;
            i_v25 = 1;
        }
        case 112: {
        lab_0x1370c:
            // 0x1370c
            i_v26 = i_v25;
            i_v27 = i_v24;
            i_v28 = i_v23;
        }
        case 102: {
            int32_t i_v30 =
                function_128a0(&i_v4, &i_v2, &i_v6, &i_v8, i_v26,
                               (int32_t)i_v27, (int32_t)i_v28); // 0x13754
            i_v29 = i_v30;
            // break -> 0x137a8
            break;
        }
        case 115: {
            // 0x1370c
            i_v23 = 0;
            i_v24 = 0;
            i_v25 = 1;
            // branch (via goto) -> 0x1370c
            goto lab_0x1370c;
        }
        case 113: {
            // 0x13774
            i_v29 = function_10b7c();
            // break -> 0x137a8
            break;
        }
        case 110: {
            // 0x13760
            i_v29 = function_109a8(&i_v4);
            // break -> 0x137a8
            break;
        }
        default: {
            // 0x13780
            function_107f0("Command Not Support!", i_v10, i_v11, i_v22);
            i_v29 = 5;
            // break -> 0x137a8
            break;
        }
        }
        // 0x137a8
        return i_v29;
    }
    case 3: {
        int32_t *p_v31 = (int32_t *)(i_a2 + 8);             // 0x135fc
        uint32_t i_v32 = function_10780((int32_t *)*p_v31); // 0x13604
        if (i_v32 != 127 && i_v32 >= 127) {
            // 0x13614
            function_107f0("fileName Too Long!", 0, 253, i_v32);
            // 0x137a8
            return 3;
        }
        int32_t i_v33 = *p_v31; // 0x13630
        function_107b0(&i_v4, i_v33);
        i_v10 = i_v33;
        i_v11 = i_v33;
        // branch (via goto) -> 0x13678
        goto lab_0x13678;
    }
    default: {
        // 0x13654
        function_107f0("Param Err!", 0, 253, i_a1);
        // 0x137a8
        return 3;
    }
    }
}

// Address range: 0x137b4 - 0x137e8
int32_t function_137b4(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    int32_t i_v1 = function_106e8(i_a1, i_a2, i_a3, i_a4); // 0x137c4
    return 0x24f0a - (int32_t)&i_g1 >> 2 == 0 ? i_v1 : i_a1;
}

// Address range: 0x137f0 - 0x137f2
int32_t function_137f0(void) {
    // 0x137f0
    int32_t i_v1; // 0x137f0
    return i_v1;
}

// Address range: 0x137f4 - 0x137f8
int32_t function_137f4(int32_t i_a1, int32_t *p_a2) {
    // 0x137f4
    return i_a1;
}

// Address range: 0x137f8 - 0x137fe
int32_t function_137f8(void) {
    // 0x137f8
    return function_107e0();
}

// Address range: 0x13800 - 0x13808
int32_t function_13800(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x13800
    return i_a1;
}

// Address range: 0x28623c - 0x28623d
int32_t function_28623c(void) {
    // 0x28623c
    int32_t i_v1; // 0x28623c
    return i_v1;
}

// Address range: 0xe0832002 - 0xe0832003
int32_t function_e0832002(void) {
    // 0xe0832002
    int32_t i_v1; // 0xe0832002
    return i_v1;
}

// Address range: 0xe1a00003 - 0xe1a00004
int32_t function_e1a00003(void) {
    // 0xe1a00003
    int32_t i_v1; // 0xe1a00003
    return i_v1;
}

// Address range: 0xe1a02003 - 0xe1a02004
int32_t function_e1a02003(void) {
    // 0xe1a02003
    int32_t i_v1; // 0xe1a02003
    return i_v1;
}

// Address range: 0xe1a03000 - 0xe1a03001
int32_t function_e1a03000(void) {
    // 0xe1a03000
    int32_t i_v1; // 0xe1a03000
    return i_v1;
}

// Address range: 0xe1a0c002 - 0xe1a0c003
int32_t function_e1a0c002(void) {
    // 0xe1a0c002
    int32_t i_v1; // 0xe1a0c002
    return i_v1;
}

// Address range: 0xe1a0e003 - 0xe1a0e004
int32_t function_e1a0e003(void) {
    // 0xe1a0e003
    int32_t i_v1; // 0xe1a0e003
    return i_v1;
}

// Address range: 0xe2433004 - 0xe2433005
int32_t function_e2433004(void) {
    // 0xe2433004
    int32_t i_v1; // 0xe2433004
    return i_v1;
}

// Address range: 0xe243300c - 0xe243300d
int32_t function_e243300c(void) {
    // 0xe243300c
    int32_t i_v1; // 0xe243300c
    return i_v1;
}

// Address range: 0xe24b3e51 - 0xe24b3e52
int32_t function_e24b3e51(void) {
    // 0xe24b3e51
    int32_t i_v1; // 0xe24b3e51
    return i_v1;
}

// Address range: 0xe3033bac - 0xe3033bad
int32_t function_e3033bac(void) {
    // 0xe3033bac
    int32_t i_v1; // 0xe3033bac
    return i_v1;
}

// Address range: 0xe3033bbc - 0xe3033bbd
int32_t function_e3033bbc(void) {
    // 0xe3033bbc
    int32_t i_v1; // 0xe3033bbc
    return i_v1;
}

// Address range: 0xe3403001 - 0xe3403002
int32_t function_e3403001(void) {
    // 0xe3403001
    int32_t i_v1; // 0xe3403001
    return i_v1;
}

// Address range: 0xe58c0000 - 0xe58c0001
int32_t function_e58c0000(void) {
    // 0xe58c0000
    int32_t i_v1; // 0xe58c0000
    return i_v1;
}

// Address range: 0xe58c1004 - 0xe58c1005
int32_t function_e58c1004(void) {
    // 0xe58c1004
    int32_t i_v1; // 0xe58c1004
    return i_v1;
}

// Address range: 0xe58c2008 - 0xe58c2009
int32_t function_e58c2008(void) {
    // 0xe58c2008
    int32_t i_v1; // 0xe58c2008
    return i_v1;
}

// Address range: 0xe58c300c - 0xe58c300d
int32_t function_e58c300c(void) {
    // 0xe58c300c
    int32_t i_v1; // 0xe58c300c
    return i_v1;
}

// Address range: 0xe8be000f - 0xe8be0010
int32_t function_e8be000f(void) {
    // 0xe8be000f
    int32_t i_v1; // 0xe8be000f
    return i_v1;
}

// Address range: 0xea00004f - 0xea000050
int32_t function_ea00004f(void) {
    // 0xea00004f
    int32_t i_v1; // 0xea00004f
    return i_v1;
}

// Address range: 0xebfffdc5 - 0xebfffdc6
int32_t function_ebfffdc5(void) {
    // 0xebfffdc5
    int32_t i_v1; // 0xebfffdc5
    return i_v1;
}

// Address range: 0xff86c440 - 0xff86c441
int32_t function_ff86c440(void) {
    // 0xff86c440
    int32_t i_v1; // 0xff86c440
    return i_v1;
}

// Address range: 0xff86c7c0 - 0xff86c7c1
int32_t function_ff86c7c0(void) {
    // 0xff86c7c0
    int32_t i_v1; // 0xff86c7c0
    return i_v1;
}

// Address range: 0xff86ce08 - 0xff86ce09
int32_t function_ff86ce08(void) {
    // 0xff86ce08
    int32_t i_v1; // 0xff86ce08
    return i_v1;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.4.3)
// Detected functions: 78
