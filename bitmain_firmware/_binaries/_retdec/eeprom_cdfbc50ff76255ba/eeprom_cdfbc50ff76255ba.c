//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <fcntl.h>
#include <getopt.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stropts.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int32_t __libc_start_main2(int32_t main, int32_t argc, char **ubp_av,
                           void (*init)(), void (*fini)(), void (*rtld_fini)());
void abort2(void);
int32_t close2(int32_t fd);
int32_t entry_point(int32_t i_a1, int32_t i_a2);
void exit2(int32_t status);
int32_t fflush2(struct _IO_FILE *stream);
char *fgets2(char *s, int32_t n, struct _IO_FILE *stream);
int32_t fprintf2(struct _IO_FILE *stream, char *format, ...);
int32_t function_85a0(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
void function_8614(void);
int32_t function_868c(int32_t i_a1, int32_t i_a2);
int32_t function_8ef8(void);
int32_t function_8f1c(int32_t i_a1, int32_t i_a2, int32_t i_a3, char i_a4);
int32_t function_8f54(int32_t *p_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_8f94(void);
int32_t function_8fbc(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_8ff0(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4,
                      uint32_t i_a5);
int32_t function_914c(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4,
                      uint32_t i_a5);
int32_t function_9248(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_92ac(void);
int32_t function_92b0(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t fwrite2(int32_t *ptr, int32_t size, int32_t n, struct _IO_FILE *s);
int32_t getopt2(int32_t argc, char **argv, char *shortopts);
int32_t ioctl2(int32_t fd, int32_t request, ...);
int32_t open2(char *file, int32_t oflag, ...);
void perror2(char *s);
int32_t read2(int32_t fd, int32_t *buf, int32_t nbytes);
int32_t sscanf2(char *s, char *format, ...);
int32_t strncmp2(char *s1, char *s2, int32_t n);
int32_t write2(int32_t fd, int32_t *buf, int32_t n);

// --------------------- Global Variables ---------------------

int32_t i_g1 = 0x8fbc;                       // 0x11be4
int32_t i_g2 = 0x8f94;                       // 0x11be8
int32_t i_g3 = 0;                            // 0x11bec
int32_t i_g4 = 0;                            // 0x11d28
struct _IO_FILE *p_g5 = NULL;                // 0x11d38
struct _IO_FILE *p_g6 = NULL;                // 0x11d40
char *p_g7;                                  // 0x11d48
char *p_g8;                                  // 0x11d4c
void (*p_g9)() = (void (*)()) - 0x16d2ba08;  // 0x9248
void (*p_g10)() = (void (*)()) - 0x1ed000e2; // 0x92ac
int32_t i_g11;
int32_t i_g12;

// ------- Dynamically Linked Functions Without Header --------

void __gmon_start__(void);
int32_t __libc_start_main(int32_t i_a1, int32_t i_a2, char **p_a3,
                          void (*p_a4)(), void (*p_a5)(), void (*p_a6)());

// ------------------------ Functions -------------------------

// Address range: 0x85a0 - 0x85ac
int32_t function_85a0(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x85a0
    return function_8ef8();
}

// Address range: 0x85c0 - 0x85cc
int32_t read2(int32_t fd, int32_t *buf, int32_t nbytes) {
    // 0x85c0
    return read(fd, buf, nbytes);
}

// Address range: 0x85cc - 0x85d8
int32_t fflush2(struct _IO_FILE *stream) {
    // 0x85cc
    return fflush(stream);
}

// Address range: 0x85d8 - 0x85e4
char *fgets2(char *s, int32_t n, struct _IO_FILE *stream) {
    // 0x85d8
    return fgets(s, n, stream);
}

// Address range: 0x85e4 - 0x85f0
void perror2(char *s) {
    // 0x85e4
    perror(s);
}

// Address range: 0x85f0 - 0x85fc
int32_t fwrite2(int32_t *ptr, int32_t size, int32_t n, struct _IO_FILE *s) {
    // 0x85f0
    return fwrite(ptr, size, n, s);
}

// Address range: 0x85fc - 0x8608
int32_t ioctl2(int32_t fd, int32_t request, ...) {
    // 0x85fc
    return ioctl(fd, request);
}

// Address range: 0x8608 - 0x8614
int32_t __libc_start_main2(int32_t main, int32_t argc, char **ubp_av,
                           void (*init)(), void (*fini)(),
                           void (*rtld_fini)()) {
    // 0x8608
    return __libc_start_main(main, argc, ubp_av, init, fini, rtld_fini);
}

// Address range: 0x8614 - 0x8620
void function_8614(void) {
    // 0x8614
    __gmon_start__();
}

// Address range: 0x8620 - 0x862c
int32_t open2(char *file, int32_t oflag, ...) {
    // 0x8620
    return open(file, oflag);
}

// Address range: 0x862c - 0x8638
void exit2(int32_t status) {
    // 0x862c
    exit(status);
}

// Address range: 0x8638 - 0x8644
int32_t getopt2(int32_t argc, char **argv, char *shortopts) {
    // 0x8638
    return getopt(argc, argv, shortopts);
}

// Address range: 0x8644 - 0x8650
int32_t fprintf2(struct _IO_FILE *stream, char *format, ...) {
    // 0x8644
    return fprintf(stream, format);
}

// Address range: 0x8650 - 0x865c
int32_t sscanf2(char *s, char *format, ...) {
    // 0x8650
    return sscanf(s, format);
}

// Address range: 0x865c - 0x8668
int32_t write2(int32_t fd, int32_t *buf, int32_t n) {
    // 0x865c
    return write(fd, buf, n);
}

// Address range: 0x8668 - 0x8674
int32_t strncmp2(char *s1, char *s2, int32_t n) {
    // 0x8668
    return strncmp(s1, s2, n);
}

// Address range: 0x8674 - 0x8680
void abort2(void) {
    // 0x8674
    abort();
}

// Address range: 0x8680 - 0x868c
int32_t close2(int32_t fd) {
    // 0x8680
    return close(fd);
}

// Address range: 0x868c - 0x8de8
int32_t function_868c(int32_t i_a1, int32_t i_a2) {
    int32_t i_v1 = 8;                                 // bp-300, 0x86b8
    int32_t i_v2 = 80;                                // bp-304, 0x86c0
    char **p_v3 = (char **)i_a2;                      // 0x86d0
    int32_t i_v4 = getopt(i_a1, p_v3, "d:a:p:wyf:h"); // 0x86d0
    int32_t i_v5 = i_v4;                              // 0x86d8
    int32_t i_v6 = 0;                                 // 0x86d8
    int32_t i_v7 = 0;                                 // 0x86d8
    int32_t i_v8 = (int32_t) "/dev/i2c-0";            // 0x86d8
    int32_t i_v9 = 0;                                 // 0x86d8
    int32_t i_v10 = 0;                                // 0x86d8
    int32_t i_v11 = (int32_t) "/dev/i2c-0";           // 0x86d8
    int32_t i_v12 = 0;                                // 0x86d8
    int32_t i_v13 = 0;                                // 0x86d8
    int32_t i_v14;                                    // 0x868c
    int32_t i_v15;                                    // 0x868c
    if (i_v4 >= 0) {
        while (true) {
            // 0x86dc
            i_v15 = i_v9;
            int32_t i_v16 = i_v5; // 0x86d0
            int32_t i_v17 = i_v8; // 0x88ac
            while (true) {
                // 0x86dc
                i_v8 = i_v17;
                int32_t i_v18 = i_v16; // 0x86d0
                int32_t i_v19 = i_v7;  // 0x8758
                while (true) {
                    // 0x86dc
                    i_v7 = i_v19;
                    int32_t i_v20 = i_v18; // 0x86d0
                    int32_t i_v21 = i_v6;  // 0x88a4
                    while (true) {
                        // 0x86dc
                        i_v6 = i_v21;
                        i_v14 = i_v20;
                        while (true) {
                        lab_0x86dc:
                            // 0x86dc
                            i_g11 = i_v14 - 97;
                            switch (i_v14) {
                            case 97: {
                                // 0x88b4
                                if (sscanf(p_g7, "0x%x", &i_v2) != 1) {
                                    // 0x88d0
                                    fprintf(p_g5,
                                            "Cannot parse '%s' as addrs., "
                                            "example: 0xa0\n",
                                            p_g7);
                                    exit(1);
                                    // UNREACHABLE
                                }
                                goto lab_0x86c4;
                            }
                            case 121: {
                                goto lab_0x8750;
                            }
                            case 119: {
                                goto lab_0x8758;
                            }
                            case 100: {
                                goto lab_0x88ac;
                            }
                            case 112: {
                                // 0x8760
                                if (sscanf(p_g7, "%d", &i_v1) != 1) {
                                    // 0x877c
                                    fprintf(p_g5,
                                            "Cannot parse '%s' as number of "
                                            "pages, example: 8\n",
                                            p_g7);
                                    exit(1);
                                    // UNREACHABLE
                                }
                                goto lab_0x86c4;
                            }
                            case 102: {
                                goto lab_0x88a4;
                            }
                            case 104: {
                                goto lab_0x8798;
                            }
                            default: {
                                goto lab_0x86c4;
                            }
                            }
                        }
                    lab_0x88a4:
                        // 0x88a4
                        i_v21 = (int32_t)p_g7;
                        i_v20 = getopt(i_a1, p_v3, "d:a:p:wyf:h");
                        i_v10 = i_v15;
                        i_v11 = i_v8;
                        i_v12 = i_v7;
                        i_v13 = i_v21;
                        if (i_v20 < 0) {
                            goto lab_0x88ec_5;
                        }
                    }
                lab_0x8758:
                    // 0x8758
                    i_v19 = i_v7 + 1;
                    i_v18 = getopt(i_a1, p_v3, "d:a:p:wyf:h");
                    i_v10 = i_v15;
                    i_v11 = i_v8;
                    i_v12 = i_v19;
                    i_v13 = i_v6;
                    if (i_v18 < 0) {
                        goto lab_0x88ec_5;
                    }
                }
            lab_0x88ac:
                // 0x88ac
                i_v17 = (int32_t)p_g7;
                i_v16 = getopt(i_a1, p_v3, "d:a:p:wyf:h");
                i_v10 = i_v15;
                i_v11 = i_v17;
                i_v12 = i_v7;
                i_v13 = i_v6;
                if (i_v16 < 0) {
                    goto lab_0x88ec_5;
                }
            }
        lab_0x8750:
            // 0x8750
            i_v9 = i_v15 + 1;
            i_v5 = getopt(i_a1, p_v3, "d:a:p:wyf:h");
            i_v10 = i_v9;
            i_v11 = i_v8;
            i_v12 = i_v7;
            i_v13 = i_v6;
            if (i_v5 < 0) {
                goto lab_0x88ec_5;
            }
        }
    lab_0x8798:
        // 0x8798
        fprintf(p_g5, "%s [-d dev] [-a adr] [-p pgs] [-w] [-y] [-f file]\n",
                (char *)i_a2);
        fwrite((int32_t *)"\tdev: device, e.g. /dev/i2c-0    (def)\n", 1, 39,
               p_g5);
        fwrite((int32_t *)"\tadr: base address of eeprom, eg 0xA0 (def)\n", 1,
               44, p_g5);
        fwrite((int32_t *)"\tpgs: number of pages to read, eg 8 (def)\n", 1, 42,
               p_g5);
        fwrite((int32_t *)"\t-w : write to eeprom (default is reading!)\n", 1,
               44, p_g5);
        fwrite((int32_t *)"\t-y : suppress warning when writing (default is to "
                          "warn!)\n",
               1, 58, p_g5);
        fwrite((int32_t *)"\t-f file: copy eeprom contents to/from file\n", 1,
               44, p_g5);
        fwrite((int32_t *)"\t         (default for read is test only; for "
                          "write is all zeros)\n",
               1, 66, p_g5);
        fwrite((int32_t *)"Note on pages/addresses:\n", 1, 25, p_g5);
        fwrite(
            (int32_t *)"\teeproms with more than 256 byte appear as if they\n",
            1, 51, p_g5);
        fwrite((int32_t *)"\twere several eeproms with consecutive addresses "
                          "on the bus\n",
               1, 60, p_g5);
        fwrite((int32_t *)"\tso we might as well address several separate "
                          "eeproms with\n",
               1, 59, p_g5);
        fwrite((int32_t *)"\tincreasing addresses....\n\n", 1, 27, p_g5);
        exit(1);
        // UNREACHABLE
    }
lab_0x88ec_5:
    // 0x88ec
    fprintf(p_g5, "base-address of eeproms       : 0x%02x\n", i_v2);
    int32_t i_v22 = i_v2; // 0x8904
    int32_t i_v23 = i_v1; // 0x8908
    fprintf(p_g5, "number of pages to read       : %d (0x%02x .. 0x%02x)\n",
            i_v23, i_v22, i_v22 - 1 + i_v23);
    int32_t i_v24 = -1; // 0x8930
    char *p_v25;        // 0x868c
    int32_t i_v26;      // 0x868c
    if (i_v13 != 0) {
        char *p_v27 = (char *)i_v13;
        int32_t i_v28; // 0x868c
        if (i_v12 == 0) {
            // 0x8940
            i_v28 = open(p_v27, 65);
        } else {
            // 0x8b34
            i_v28 = open(p_v27, O_RDONLY);
        }
        // 0x8950
        p_v25 = p_v27;
        i_v26 =
            (int32_t) "Could not open data-file %s for reading or writing\n";
        if (i_v28 < 0) {
        lab_0x8ba8_2:
            // 0x8ba8
            fprintf(p_g5, (char *)i_v26, p_v25);
            perror(p_v25);
        lab_0x8aec_2:
            // 0x8aec
            exit(1);
            // UNREACHABLE
        }
        int32_t i_v29 = i_v12 == 0 ? (int32_t) "writing" : (int32_t) "reading";
        fprintf(p_g5, "file opened for %7s       : %s\n", (char *)i_v29, p_v27);
        fprintf(p_g5, "            on filedescriptor : %d\n", i_v28);
        i_v24 = i_v28;
    }
    char *p_v30 = (char *)i_v11;         // 0x89a4
    int32_t i_v31 = open(p_v30, O_RDWR); // 0x89a4
    if (i_v31 < 0) {
        // 0x8bb8
        fprintf(p_g5, "Could not open i2c at %s\n", p_v30);
        perror(p_v30);
        exit(1);
        // UNREACHABLE
    }
    // 0x89b0
    fprintf(p_g5, "i2c-devicenode is             : %s\n", p_v30);
    fprintf(p_g5, "            on filedescriptor : %d\n\n", i_v31);
    int32_t i_v32; // bp-296, 0x868c
    if (i_v10 == 0 == (i_v12 != 0)) {
        // 0x8be0
        fwrite((int32_t *)"**WARNING**\n", 1, 12, p_g5);
        fwrite((int32_t *)" - \tYou have chosen to WRITE to this eeprom.\n", 1,
               45, p_g5);
        fwrite((int32_t
                    *)"\tMake sure that this tiny chip is *NOT* vital to the\n",
               1, 53, p_g5);
        fwrite(
            (int32_t
                 *)"\toperation of your computer as you can easily corrupt\n",
            1, 54, p_g5);
        fwrite(
            (int32_t
                 *)"\tthe configuration memory of your SDRAM-memory-module,\n",
            1, 55, p_g5);
        fwrite((int32_t *)"\tyour IBM ThinkPad or whatnot...! Fixing these "
                          "errors can be\n",
               1, 61, p_g5);
        fwrite((int32_t *)"\ta time-consuming and very costly process!\n\n", 1,
               44, p_g5);
        fwrite((int32_t *)"Things to consider:\n", 1, 20, p_g5);
        fwrite((int32_t *)" - \tYou can have more than one i2c-bus, check in "
                          "/proc/bus/i2c\n",
               1, 63, p_g5);
        fwrite((int32_t *)"\tand specify the correct one with -d\n", 1, 37,
               p_g5);
        fprintf(p_g5, "\tright now you have chosen to use '%s'\n", p_v30);
        fwrite((int32_t *)" - \tA eeprom can occupy several i2c-addresses (one "
                          "per page)\n",
               1, 61, p_g5);
        fwrite((int32_t *)"\tso please make sure that there is no vital eeprom "
                          "in your computer\n",
               1, 68, p_g5);
        int32_t i_v33 = i_v2; // 0x8ce0
        fprintf(p_g5, "\tsitting at addresses between 0x%02x and 0x%02x\n",
                i_v33, i_v33 - 1 + i_v1);
        fwrite((int32_t *)"Enter 'yes' to continue:", 1, 24, p_g5);
        fflush(p_g5);
        if (fgets((char *)&i_v32, 4, p_g6) == NULL) {
            // 0x8db0
            fwrite((int32_t *)"\nCould not read confirmation from stdin!\n", 1,
                   41, p_g5);
            exit(1);
            // UNREACHABLE
        }
        // 0x8d34
        if (strncmp((char *)&i_v32, "yes", 3) != 0) {
            // 0x8d4c
            fwrite((int32_t
                        *)"\n** ABORTING WRITE! **, you did not answer 'yes'\n",
                   1, 49, p_g5);
            exit(1);
            // UNREACHABLE
        }
    }
    // 0x8a08
    if (i_v1 <= 0) {
    lab_0x8d8c:
        if (i_v24 != -1) {
            // 0x8d98
            close(i_v24);
        }
        // 0x8da0
        close(i_v31);
        exit(0);
        // UNREACHABLE
    }
    // 0x8a44
    int32_t i_v34;          // bp-41, 0x868c
    int32_t i_v35 = &i_v34; // 0x8a18
    char *p_v36 = (char *)i_v13;
    int32_t i_v37 = &i_v32;
    int32_t i_v38 = 0; // 0x868c
    while (true) {
        int32_t i_v39 = i_v38;
        if (i_v12 == 0) {
            int32_t i_v40 = 0;
            if (function_914c(i_v31, i_v2 + i_v39, i_v40, i_v40 + i_v37, 8) <
                0) {
                // break (via goto) -> 0x8aec
                goto lab_0x8aec_2;
            }
            int32_t i_v41 = i_v40 + 8; // 0x8afc
            while (i_v41 != 256) {
                // 0x8b08
                i_v40 = i_v41;
                if (function_914c(i_v31, i_v2 + i_v39, i_v40, i_v40 + i_v37,
                                  8) < 0) {
                    // break (via goto) -> 0x8aec
                    goto lab_0x8aec_2;
                }
                // 0x8afc
                i_v41 = i_v40 + 8;
            }
        } else {
            // 0x8a4c
            if (i_v24 == -1) {
                int32_t i_v42;                       // bp-297, 0x868c
                int32_t i_v43 = (int32_t)&i_v42 + 1; // 0x8b68
                *(char *)i_v43 = 0;
                int32_t i_v44 = i_v43; // 0x8b70
                while (i_v43 != i_v35) {
                    // 0x8b68
                    i_v43 = i_v44 + 1;
                    *(char *)i_v43 = 0;
                    i_v44 = i_v43;
                }
            } else {
                int32_t i_v45 = read(i_v24, &i_v32, 256); // 0x8a64
                p_v25 = p_v36;
                i_v26 = (int32_t) "Cannot read from file '%s'\n";
                if (i_v45 < 0) {
                    goto lab_0x8ba8_2;
                }
                if (i_v45 != 256) {
                    // 0x8a78
                    fprintf(
                        p_g5,
                        "File '%s' is too small, padding eeprom with zeroes\n",
                        p_v36);
                    if (i_v45 >= 255 != i_v45 != 255) {
                        int32_t i_v46 = i_v37 - 1 + i_v45; // 0x8aa0
                        i_v46++;
                        *(char *)i_v46 = 0;
                        while (i_v46 != i_v35) {
                            // 0x8aa4
                            i_v46++;
                            *(char *)i_v46 = 0;
                        }
                    }
                }
            }
            int32_t i_v47 = 0;
            if (function_8ff0(i_v31, i_v2 + i_v39, i_v47, i_v47 + i_v37, 8) <
                0) {
                // break (via goto) -> 0x8aec
                goto lab_0x8aec_2;
            }
            int32_t i_v48 = i_v47 + 8; // 0x8ab8
            while (i_v48 != 256) {
                // 0x8ac4
                i_v47 = i_v48;
                if (function_8ff0(i_v31, i_v2 + i_v39, i_v47, i_v47 + i_v37,
                                  8) < 0) {
                    // break (via goto) -> 0x8aec
                    goto lab_0x8aec_2;
                }
                // 0x8ab8
                i_v48 = i_v47 + 8;
            }
        }
        if (i_v12 == 0 == i_v24 > -1) {
            int32_t i_v49 = write(i_v24, &i_v32, 256); // 0x8b84
            p_v25 = p_v36;
            i_v26 = (int32_t) "Cannot write to file '%s'\n";
            if (i_v49 != 256) {
                goto lab_0x8ba8_2;
            }
        }
        int32_t i_v50 = i_v39 + 1; // 0x8b5c
        i_v38 = i_v50;
        if (i_v50 >= i_v1) {
            goto lab_0x8d8c;
        }
    }
    // 0x8aec
    exit(1);
    // UNREACHABLE
lab_0x86c4:;
    int32_t i_v51 = getopt(i_a1, p_v3, "d:a:p:wyf:h"); // 0x86d0
    i_v14 = i_v51;
    i_v10 = i_v15;
    i_v11 = i_v8;
    i_v12 = i_v7;
    i_v13 = i_v6;
    if (i_v51 < 0) {
        goto lab_0x88ec_5;
    }
    goto lab_0x86dc;
}

// Address range: 0x8ebc - 0x8eec
int32_t entry_point(int32_t i_a1, int32_t i_a2) {
    // 0x8ebc
    int32_t i_v1; // 0x8ebc
    __libc_start_main(0x868c, i_a2, (char **)&i_v1, (void (*)()) & p_g9,
                      (void (*)()) & p_g10, (void (*)())i_a1);
    abort();
    return &i_g12;
}

// Address range: 0x8ef8 - 0x8f14
int32_t function_8ef8(void) {
    // 0x8ef8
    if (i_g4 == 0) {
        int32_t i_v1; // 0x8ef8
        return i_v1;
    }
    // 0x8f10
    __gmon_start__();
    return &i_g12;
}

// Address range: 0x8f1c - 0x8f48
int32_t function_8f1c(int32_t i_a1, int32_t i_a2, int32_t i_a3, char i_a4) {
    // 0x8f1c
    return 0x11d34;
}

// Address range: 0x8f54 - 0x8f88
int32_t function_8f54(int32_t *p_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x8f54
    return 0x11d34;
}

// Address range: 0x8f94 - 0x8fb8
int32_t function_8f94(void) {
    // 0x8f94
    int32_t i_v1; // 0x8f94
    if (*(char *)&p_g8 != 0) {
        return i_v1;
    }
    int32_t i_v2 = function_8f1c(i_v1, i_v1, i_v1, 0); // 0x8fa8
    *(char *)&p_g8 = 1;
    return i_v2;
}

// Address range: 0x8fbc - 0x8fe8
int32_t function_8fbc(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x8fbc
    return function_8f54(&i_g3, i_a2, i_a3, i_a4);
}

// Address range: 0x8ff0 - 0x9130
int32_t function_8ff0(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4,
                      uint32_t i_a5) {
    uint32_t i_v1 = i_a5 % 256;
    if (i_v1 >= 8 == (i_v1 != 8)) {
        // 0x90ec
        fwrite((int32_t *)"I can only write MAX_BYTES bytes at a time!\n", 1,
               44, p_g5);
        // 0x90a4
        return -1;
    }
    uint32_t i_v2 = i_v1 + i_a3; // 0x900c
    if (i_v2 >= 256 == (i_v2 != 256)) {
        // 0x90cc
        fprintf(p_g5, "Sorry, len(%d)+offset(%d) > 256 (page boundary)\n", i_v1,
                i_a3);
        // 0x90a4
        return -1;
    }
    int32_t i_v3 = 0x1000000 * i_a3 >> 24; // bp-56, 0x9020
    if (i_v1 != 0) {
        int32_t i_v4 = &i_v3;    // 0x901c
        int32_t i_v5 = i_a4 - 1; // 0x9034
        int32_t i_v6 = i_v4;     // 0x9038
        i_v5++;
        i_v6++;
        *(char *)i_v6 = *(char *)i_v5;
        int32_t i_v7; // 0x8ff0
        while (i_v6 != (i_v1 == 0 ? i_v7 : i_v1 + i_v4)) {
            // 0x9034
            i_v5++;
            i_v6++;
            *(char *)i_v6 = *(char *)i_v5;
        }
    }
    int32_t i_v8 = ioctl(i_a1, 1799); // 0x9074
    if (i_v8 < 0) {
        // 0x910c
        perror("ioctl()");
        fprintf(p_g5, "ioctl returned %d\n", i_v8);
        // 0x90a4
        return -1;
    }
    // 0x9080
    if (i_v1 == 0) {
        // 0x908c
        fprintf(p_g5, "Positioned pointer in eeprom at 0x%02x to offset %08x\n",
                i_a2, i_a3);
    } else {
        // 0x90ac
        fprintf(p_g5, "Wrote %d bytes to eeprom at 0x%02x, offset %08x\n", i_v1,
                i_a2, i_a3);
    }
    // 0x90a4
    return 0;
}

// Address range: 0x914c - 0x9234
int32_t function_914c(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4,
                      uint32_t i_a5) {
    uint32_t i_v1 = i_a5 % 256;
    if (i_v1 >= 8 == (i_v1 != 8)) {
        // 0x91e8
        fwrite((int32_t *)"I can only write MAX_BYTES bytes at a time!\n", 1,
               44, p_g5);
        // 0x91e0
        return -1;
    }
    // 0x9170
    if (function_8ff0(i_a1, i_a2, i_a3, 0, 0) < 0) {
        // 0x91e0
        return -1;
    }
    int32_t i_v2 = ioctl(i_a1, 1799); // 0x91b4
    int32_t i_v3;                     // 0x914c
    if (i_v2 < 0) {
        // 0x9210
        perror("ioctl()");
        fprintf(p_g5, "ioctl returned %d\n", i_v2);
        i_v3 = -1;
    } else {
        // 0x91c0
        fprintf(p_g5, "Read %d bytes from eeprom at 0x%02x, offset %08x\n",
                i_v1, i_a2, i_a3);
        i_v3 = 0;
    }
    // 0x91e0
    return i_v3;
}

// Address range: 0x9248 - 0x92a4
int32_t function_9248(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    int32_t i_v1 = function_85a0(i_a1, i_a2, i_a3, i_a4); // 0x9264
    int32_t i_v2 = (int32_t)&i_g2 - (int32_t)&i_g1 >> 2 == 0 ? i_v1 : i_a1;
    return i_v2;
}

// Address range: 0x92ac - 0x92b0
int32_t function_92ac(void) {
    // 0x92ac
    int32_t i_v1; // 0x92ac
    return i_v1;
}

// Address range: 0x92b0 - 0x92b8
int32_t function_92b0(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x92b0
    return i_a1;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.8.x)
// Detected functions: 30
