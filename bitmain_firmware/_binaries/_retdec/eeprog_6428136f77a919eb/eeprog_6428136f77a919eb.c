//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <errno.h>
#include <getopt.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stropts.h>
#include <unistd.h>

// ----------------- Float Types Definitions ------------------

typedef double float64_t;
typedef long double float128_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct stat64 {
    int64_t e0;
    int64_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int64_t e6;
    int64_t e7;
    int64_t e8;
    int32_t e9;
    int32_t e10;
    int64_t e11;
    int32_t e12;
    int32_t e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int32_t e17;
    int32_t e18;
    int32_t e19;
};

// ------------------- Function Prototypes --------------------

int32_t entry_point(int32_t i_a1, int32_t i_a2);
int32_t function_107bc(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_107dc(char *format, ...);
int32_t function_107e8(struct _IO_FILE *stream);
int32_t function_107f4(struct _IO_FILE *fp);
int32_t function_10800(int32_t c, struct _IO_FILE *fp);
int32_t function_1080c(int32_t *ptr, int32_t size, int32_t n,
                       struct _IO_FILE *s);
int32_t function_10818(int32_t fd, int32_t request, ...);
int32_t function_10824(int32_t useconds);
int32_t function_10830(int32_t i_a1, int32_t i_a2);
int32_t function_1083c(char *file, int32_t oflag, ...);
char *function_10848(char *name);
int32_t function_10854(char *s);
int32_t function_10860(int32_t main, int32_t argc, char **ubp_av,
                       void (*init)(), void (*fini)(), void (*rtld_fini)());
char *function_1086c(int32_t errnum);
void function_10878(void);
void function_10884(int32_t status);
int32_t function_10890(char *nptr, char **endptr, int32_t base);
int32_t function_1089c(int32_t i_a1);
int32_t function_108a8(char *s);
int32_t function_108b4(int32_t argc, char **argv, char *shortopts);
int32_t function_108c0(struct _IO_FILE *stream, char *format, ...);
int32_t function_108cc(void);
int32_t *function_108d8(void);
int32_t function_108e4(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4,
                       int32_t i_a5, int32_t i_a6, int32_t i_a7);
int32_t function_108f0(int32_t c, struct _IO_FILE *stream);
int32_t function_108fc(int32_t ver, char *filename, struct stat64 *stat_buf);
void function_10908(void);
int32_t function_10914(int32_t fd);
int32_t function_10920(int32_t i_a1, int32_t i_a2);
int32_t function_10d7c(int32_t i_a1);
int32_t function_10d88(void);
int32_t function_10dac(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_10e08(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4,
                       int32_t i_a5);
int32_t function_10e14(void);
int32_t function_10e18(int32_t i_a1);
int32_t function_10e48(char *p_a1, int32_t i_a2);
int32_t function_10e74(int32_t i_a1, int32_t i_a2);
int32_t function_10e88(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t function_10ea0(int32_t i_a1, int32_t *p_a2, int32_t *p_a3);
int32_t function_10ef8(void);
int32_t function_10f34(int32_t *p_a1, uint32_t i_a2, int32_t i_a3,
                       int32_t i_a4);
int32_t function_11070(int32_t *p_a1, int32_t i_a2);
int32_t function_11134(int32_t i_a1, int32_t i_a2);
int32_t function_1118c(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t *p_a4);
int32_t function_11338(int32_t *p_a1);
int32_t function_11364(int32_t i_a1);
int32_t function_11384(int32_t i_a1, uint32_t i_a2);
int32_t function_11468(int32_t i_a1, uint32_t i_a2, int32_t i_a3);
int32_t function_11534(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_11570(void);
int32_t function_11574(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t unknown_240(void);

// --------------------- Global Variables ---------------------

int32_t i_g1 = 0x10e15;       // 0x22f08
int32_t i_g2 = 0;             // 0x23078
int32_t i_g3 = 0;             // 0x23088
struct _IO_FILE *p_g4 = NULL; // 0x23090
struct _IO_FILE *p_g5 = NULL; // 0x23098
struct _IO_FILE *p_g6 = NULL; // 0x2309c
char *p_g7;                   // 0x230a0
int32_t i_g8 = 0;             // 0x230a8
int32_t i_g9;

// ------- Dynamically Linked Functions Without Header --------

void __gmon_start__(void);
int32_t __libc_start_main(int32_t i_a1, int32_t i_a2, char **p_a3,
                          void (*p_a4)(), void (*p_a5)(), void (*p_a6)());
int32_t __xstat64(int32_t i_a1, char *p_a2, struct stat64 *p_a3);
int32_t i2c_smbus_read_byte(int32_t i_a1);
int32_t i2c_smbus_write_byte(int32_t i_a1, int32_t i_a2);
int32_t i2c_smbus_write_byte_data(void);
int32_t i2c_smbus_write_word_data(int32_t i_a1, int32_t i_a2, int32_t i_a3,
                                  int32_t i_a4, int32_t i_a5, int32_t i_a6,
                                  int32_t i_a7);
int32_t open64(char *p_a1, int32_t i_a2, ...);

// ------------------------ Functions -------------------------

// Address range: 0x107bc - 0x107c8
int32_t function_107bc(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x107bc
    return function_10d88();
}

// Address range: 0x107dc - 0x107e8
int32_t function_107dc(char *format, ...) {
    // 0x107dc
    return printf(format);
}

// Address range: 0x107e8 - 0x107f4
int32_t function_107e8(struct _IO_FILE *stream) {
    // 0x107e8
    return fflush(stream);
}

// Address range: 0x107f4 - 0x10800
int32_t function_107f4(struct _IO_FILE *fp) {
    // 0x107f4
    return _IO_getc(fp);
}

// Address range: 0x10800 - 0x1080c
int32_t function_10800(int32_t c, struct _IO_FILE *fp) {
    // 0x10800
    return _IO_putc(c, fp);
}

// Address range: 0x1080c - 0x10818
int32_t function_1080c(int32_t *ptr, int32_t size, int32_t n,
                       struct _IO_FILE *s) {
    // 0x1080c
    return fwrite(ptr, size, n, s);
}

// Address range: 0x10818 - 0x10824
int32_t function_10818(int32_t fd, int32_t request, ...) {
    // 0x10818
    return ioctl(fd, request);
}

// Address range: 0x10824 - 0x10830
int32_t function_10824(int32_t useconds) {
    // 0x10824
    return usleep(useconds);
}

// Address range: 0x10830 - 0x1083c
int32_t function_10830(int32_t i_a1, int32_t i_a2) {
    // 0x10830
    return i2c_smbus_write_byte(i_a1, i_a2);
}

// Address range: 0x1083c - 0x10848
int32_t function_1083c(char *file, int32_t oflag, ...) {
    // 0x1083c
    return open64(file, oflag);
}

// Address range: 0x10848 - 0x10854
char *function_10848(char *name) {
    // 0x10848
    return getenv(name);
}

// Address range: 0x10854 - 0x10860
int32_t function_10854(char *s) {
    // 0x10854
    return puts(s);
}

// Address range: 0x10860 - 0x1086c
int32_t function_10860(int32_t main, int32_t argc, char **ubp_av,
                       void (*init)(), void (*fini)(), void (*rtld_fini)()) {
    // 0x10860
    return __libc_start_main(main, argc, ubp_av, init, fini, rtld_fini);
}

// Address range: 0x1086c - 0x10878
char *function_1086c(int32_t errnum) {
    // 0x1086c
    return strerror(errnum);
}

// Address range: 0x10878 - 0x10884
void function_10878(void) {
    // 0x10878
    __gmon_start__();
}

// Address range: 0x10884 - 0x10890
void function_10884(int32_t status) {
    // 0x10884
    exit(status);
}

// Address range: 0x10890 - 0x1089c
int32_t function_10890(char *nptr, char **endptr, int32_t base) {
    // 0x10890
    return strtoul(nptr, endptr, base);
}

// Address range: 0x1089c - 0x108a8
int32_t function_1089c(int32_t i_a1) {
    // 0x1089c
    return i2c_smbus_read_byte(i_a1);
}

// Address range: 0x108a8 - 0x108b4
int32_t function_108a8(char *s) {
    // 0x108a8
    return strlen(s);
}

// Address range: 0x108b4 - 0x108c0
int32_t function_108b4(int32_t argc, char **argv, char *shortopts) {
    // 0x108b4
    return getopt(argc, argv, shortopts);
}

// Address range: 0x108c0 - 0x108cc
int32_t function_108c0(struct _IO_FILE *stream, char *format, ...) {
    // 0x108c0
    return fprintf(stream, format);
}

// Address range: 0x108cc - 0x108d8
int32_t function_108cc(void) {
    // 0x108cc
    return i2c_smbus_write_byte_data();
}

// Address range: 0x108d8 - 0x108e4
int32_t *function_108d8(void) {
    // 0x108d8
    return __errno_location();
}

// Address range: 0x108e4 - 0x108f0
int32_t function_108e4(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4,
                       int32_t i_a5, int32_t i_a6, int32_t i_a7) {
    // 0x108e4
    return i2c_smbus_write_word_data(i_a1, i_a2, i_a3, i_a4, i_a5, i_a6, i_a7);
}

// Address range: 0x108f0 - 0x108fc
int32_t function_108f0(int32_t c, struct _IO_FILE *stream) {
    // 0x108f0
    return fputc(c, stream);
}

// Address range: 0x108fc - 0x10908
int32_t function_108fc(int32_t ver, char *filename, struct stat64 *stat_buf) {
    // 0x108fc
    return __xstat64(ver, filename, stat_buf);
}

// Address range: 0x10908 - 0x10914
void function_10908(void) {
    // 0x10908
    abort();
}

// Address range: 0x10914 - 0x10920
int32_t function_10914(int32_t fd) {
    // 0x10914
    return close(fd);
}

// Address range: 0x10920 - 0x10d58
int32_t function_10920(int32_t i_a1, int32_t i_a2) {
    // 0x10920
    i_g8 = 0;
    int32_t i_v1 = 0; // 0x10964
    int32_t i_v2 = 0; // 0x10964
    int32_t i_v3 = 0; // 0x10964
    int32_t i_v4 = 0; // 0x10964
    int32_t i_v5 = 0; // 0x10964
    int32_t i_v6 = 0; // 0x10964
    int32_t i_v7;     // 0x10920
    int32_t i_v8;     // 0x10920
    while (true) {
        // 0x10968
        i_v7 = i_v5;
        i_v8 = i_v1;
        int32_t i_v9 = i_v2; // 0x10920
        while (true) {
            // 0x10968
            i_v2 = i_v9;
            int32_t i_v10 = i_v3; // 0x10920
            int32_t i_v11 = i_v4; // 0x10920
            int32_t i_v12 = i_v6; // 0x10920
            while (true) {
                // 0x10968
                i_v3 = i_v10;
                while (true) {
                lab_0x10968_4:
                    // 0x10968
                    i_v4 = i_v11;
                    while (true) {
                    lab_0x10968_2:
                        // 0x10968
                        i_v6 = i_v12;
                        while (true) {
                        lab_0x10968:
                            // 0x10968
                            i_v5 = getopt(i_a1, (char **)i_a2, "1:8fr:qhw:xd");
                            switch (i_v5) {
                            case -1: {
                                goto lab_0x10a50;
                            }
                            case 102: {
                                goto lab_0x109dc;
                            }
                            default: {
                                if (i_v5 <= 102) {
                                    // break -> 0x1098c
                                    break;
                                }
                                switch (i_v5) {
                                case 113: {
                                    // 0x109ec
                                    i_g8++;
                                    goto lab_0x10968;
                                }
                                case 120: {
                                    goto lab_0x109cc;
                                }
                                case 104: {
                                    // 0x10a48
                                    function_10e18(203);
                                    // UNREACHABLE
                                }
                                default: {
                                    goto lab_0x109a4;
                                }
                                }
                            }
                            }
                        }
                        switch (i_v5) {
                        case 56: {
                            goto lab_0x10a30;
                        }
                        case 100: {
                            // 0x10a28
                            goto lab_0x10968_2;
                        }
                        case 49: {
                            char *p_v13 = p_g7;  // 0x109fc
                            char i_v14 = *p_v13; // 0x10a00
                            if (i_v14 != 54 || strlen(p_v13) != 1) {
                                // 0x10d08
                                function_10e18(182);
                                // UNREACHABLE
                            }
                            // 0x10a18
                            if (i_v4 != 0) {
                                // 0x10d20
                                function_10e48(
                                    "EEPROM type switch (-8 or -16) used twice",
                                    183);
                                // UNREACHABLE
                            }
                            goto lab_0x10968_4;
                        }
                        default: {
                            goto lab_0x109a4;
                        }
                        }
                    }
                lab_0x10a30:
                    // 0x10a30
                    if (i_v4 != 0) {
                        // 0x10cf8
                        function_10e48(
                            "EEPROM type switch (-8 or -16) used twice", 193);
                        // UNREACHABLE
                    }
                    goto lab_0x10968_4;
                }
            lab_0x109cc:
                // 0x109cc
                i_v10 = i_v3 + 1;
                i_v11 = i_v4;
                i_v12 = i_v6;
            }
        lab_0x109dc:
            // 0x109dc
            i_v9 = i_v2 + 1;
        }
    lab_0x109a4:
        if (i_v7 != 0) {
            // 0x10d10
            function_10e48("Both read and write requested", 206);
            // UNREACHABLE
        }
        // 0x109ac
        i_v1 = (int32_t)p_g7;
    }
lab_0x10a50:
    if (i_v7 == 0) {
        // 0x10d30
        function_10e18(214);
        // UNREACHABLE
    }
    int32_t i_v15 = i_g3; // 0x10a68
    int32_t i_v16;        // 0x10920
    int32_t i_v17;        // 0x10920
    switch (i_a1 - i_v15) {
    case 1: {
        int32_t i_v18 = *(int32_t *)(4 * i_v15 + i_a2); // 0x10c10
        int32_t i_v19;                                  // bp-144, 0x10920
        if (__xstat64(3, (char *)i_v18, (struct stat64 *)&i_v19) == -1) {
            char *p_v20 = getenv("EEPROG_DEV"); // 0x10ce4
            i_v16 = *(int32_t *)(4 * i_g3 + i_a2);
            i_v17 = (int32_t)p_v20;
        } else {
            // 0x10c28
            i_v16 = (int32_t)getenv("EEPROG_I2C_ADDR");
            i_v17 = *(int32_t *)(4 * i_g3 + i_a2);
        }
        // break -> 0x10aa4
        break;
    }
    case 2: {
        int32_t i_v21 = 4 * i_v15 + i_a2; // 0x10a90
        i_g3 = i_v15 + 1;
        i_v16 = *(int32_t *)(i_v21 + 4);
        i_v17 = *(int32_t *)i_v21;
        // break -> 0x10aa4
        break;
    }
    case 0: {
        char *p_v22 = getenv("EEPROG_DEV"); // 0x10b58
        i_v16 = (int32_t)getenv("EEPROG_I2C_ADDR");
        i_v17 = (int32_t)p_v22;
        // break -> 0x10aa4
        break;
    }
    default: {
        // 0x10a88
        function_10e18(238);
        // UNREACHABLE
    }
    }
    // 0x10aa4
    if (i_v17 == 0) {
        // 0x10d50
        return function_10e18(240);
    }
    int32_t i_v23 = i_v4 == 0 ? 1 : i_v4;
    int32_t i_v24 = i_v17 == 0;
    int32_t i_v25 = strtoul((char *)i_v16, (char **)i_v24, i_v24); // 0x10ac0
    if (i_g8 == 0) {
        // 0x10b94
        fprintf(p_g4, "eeprog %s, a 24Cxx EEPROM reader/writer\n", "0.7.5");
        if (i_g8 == 0) {
            // 0x10bc0
            fwrite((int32_t *)"Copyright (c) 2003 by Stefano Barbato - All "
                              "rights reserved.\n",
                   1, 61, p_g4);
            if (i_g8 == 0) {
                int32_t i_v26 = i_v23 == 1 ? 8 : 16;
                fprintf(p_g4, "  Bus: %s, Address: 0x%x, Mode: %dbit\n",
                        (char *)i_v17, i_v25, i_v26);
            }
        }
    }
    if (i_v6 != 0) {
        // 0x10b70
        fwrite((int32_t *)"Dummy mode selected, nothing done.\n", 1, 35, p_g4);
        // 0x10b44
        return 0;
    }
    // 0x10adc
    int32_t i_v27; // bp-160, 0x10920
    if (function_1118c(i_v17, i_v25, i_v23, &i_v27) < 0) {
        // 0x10d38
        function_10e48("unable to open eeprom device file (check that the file "
                       "exists and that it's readable)",
                       254);
        // UNREACHABLE
    }
    int32_t i_v28; // bp-164, 0x10920
    int32_t i_v29; // bp-168, 0x10920
    switch (i_v7) {
    case 114: {
        if (i_v2 == 0) {
            // 0x10cac
            function_10ef8();
        }
        // 0x10c4c
        i_v28 = 1;
        function_10ea0(i_v8, &i_v29, &i_v28);
        if (i_g8 == 0) {
            // 0x10c88
            fprintf(p_g4, "  Reading %d bytes from 0x%x\n", i_v28, i_v29);
        }
        // 0x10c70
        function_10f34(&i_v27, i_v29, i_v28, i_v3);
        // 0x10b3c
        function_11338(&i_v27);
        // 0x10b44
        return 0;
    }
    case 119: {
        if (i_v2 == 0) {
            // 0x10cd4
            function_10ef8();
        }
        // 0x10b14
        function_10ea0(i_v8, &i_v29, &i_v28);
        if (i_g8 == 0) {
            // 0x10cb4
            fprintf(p_g4, "  Writing stdin starting at address 0x%x\n", i_v29);
        }
        // 0x10b30
        function_11070(&i_v27, i_v29);
        // 0x10b3c
        function_11338(&i_v27);
        // 0x10b44
        return 0;
    }
    }
    // 0x10d48
    function_10e18(274);
    // UNREACHABLE
lab_0x10968_3:
    // 0x10968
    goto lab_0x10968_4;
}

// Address range: 0x10d58 - 0x10d7c
int32_t entry_point(int32_t i_a1, int32_t i_a2) {
    // 0x10d58
    int32_t i_v1; // 0x10d58
    __libc_start_main(0x10920, i_a2, (char **)&i_v1, (void (*)())0x11535,
                      (void (*)())0x10920, (void (*)())i_a1);
    abort();
    // UNREACHABLE
}

// Address range: 0x10d7c - 0x10d80
int32_t function_10d7c(int32_t i_a1) {
    // 0x10d7c
    return i_a1;
}

// Address range: 0x10d88 - 0x10da4
int32_t function_10d88(void) {
    // 0x10d88
    if (i_g2 == 0) {
        int32_t i_v1; // 0x10d88
        return i_v1;
    }
    // 0x10da0
    __gmon_start__();
    return &i_g9;
}

// Address range: 0x10dac - 0x10e08
int32_t function_10dac(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x10dac
    bool i_v1; // 0x10dac
    if (i_v1) {
        return i_a1;
    }
    // 0x10ddc
    int32_t i_v2;                   // 0x10dac
    int32_t i_v3 = 0x100001 * i_v2; // 0x10de0
    bool i_v4;                      // 0x10dac
    int32_t i_v5;                   // 0x10dac
    if (i_v1) {
        // .thread
        i_v5 = i_v1 ? i_v3 : 0;
    } else {
        int32_t i_v6 = i_v3 & -1 - 0x400000 * i_v2; // 0x10de4
        i_v5 = i_v6 < 1 ? 0 : i_v3;
        i_v4 = i_v6 < 0;
        if (i_v6 == 0) {
            return unknown_240();
        }
    }
    // 0x10df4
    if (i_v4 != i_v1) {
        __asm_svclt(0x4770);
    }
    float64_t f_v7; // 0x10dac
    __asm_vqrshl_s8(f_v7, f_v7);
    float128_t f_v8; // 0x10dac
    __asm_vaddhn_i16(f_v8, f_v8);
    if (!i_v1) {
        *(int32_t *)i_a4 = i_v5;
    }
    return i_a1;
}

// Address range: 0x10e08 - 0x10e14
int32_t function_10e08(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4,
                       int32_t i_a5) {
    int32_t i_v1 = i_a1; // 0x10e08
    if (i_a4 == 0) {
        // 0x10e0a
        i_v1 = function_10dac(i_a1, i_a2, i_a3, 0);
        int32_t i_v2; // 0x10e08
        *(char *)i_v2 = 1;
    }
    // 0x10e12
    return i_v1;
}

// Address range: 0x10e14 - 0x10e16
int32_t function_10e14(void) {
    // 0x10e14
    int32_t i_v1; // 0x10e14
    return i_v1;
}

// Address range: 0x10e18 - 0x10e48
int32_t function_10e18(int32_t i_a1) {
    // 0x10e18
    fprintf(
        p_g4, "%s\n[line %d]\n",
        "eeprog 0.7.5, a 24Cxx EEPROM reader/writer\nCopyright (c) 2003 by "
        "Stefano Barbato - All rights reserved.\nUsage: eeprog [-fqxdh] "
        "[-16|-8] [ -r addr[:count] | -w addr ]  /dev/i2c-N  i2c-address\n\n  "
        "Address modes:\n\t-8\t\tUse 8bit address mode for 24c0x...24C16 "
        "[default]\n\t-16\t\tUse 16bit address mode for 24c32...24C256\n  "
        "Actions:\n\t-r addr[:count]\tRead [count] (1 if omitted) bytes from "
        "[addr]\n\t\t\tand print them to the standard output\n\t-w "
        "addr\t\tWrite input (stdin) at address [addr] of the "
        "EEPROM\n\t-h\t\tPrint this help\n  Options:\n\t-x\t\tSet hex output "
        "mode\n\t-d\t\tDummy mode, display what *would* have been "
        "done\n\t-f\t\tDisable warnings and don't ask "
        "confirmation\n\t-q\t\tQuiet mode\n\nThe following environment "
        "variables could be set instead of the command\nline "
        "arguments:\n\tEEPROG_DEV\t\tdevice "
        "name(/dev/"
        "i2c-N)\n\tEEPROG_I2C_ADDR\t\ti2c-address\n\n\tExamples\n\t1- read 64 "
        "bytes from the EEPROM at address 0x54 on bus 0 starting\n\t   at "
        "address 123 (decimal)\n\t\teeprog /dev/i2c-0 0x54 -r 123:64\n\t2- "
        "prints the hex codes of the first 32 bytes read from bus 1\n\t   at "
        "address 0x22\n\t\teeprog /dev/i2c-1 0x51 -x -r 0x22:0x20\n\t3- write "
        "the current timestamp at address 0x200 of the EEPROM on\n\t   bus 0 "
        "at address 0x33\n\t\tdate | eeprog /dev/i2c-0 0x33 -w 0x200\n",
        i_a1);
    exit(1);
    return &i_g9;
}

// Address range: 0x10e48 - 0x10e74
int32_t function_10e48(char *p_a1, int32_t i_a2) {
    // 0x10e48
    fprintf(p_g4, "Error at line %d: %s\n", i_a2, p_a1);
    exit(1);
    // UNREACHABLE
}

// Address range: 0x10e74 - 0x10e88
int32_t function_10e74(int32_t i_a1, int32_t i_a2) {
    if (i_a1 == 0) {
        return 0;
    }
    // 0x10e7c
    function_10e18(i_a2);
    // UNREACHABLE
}

// Address range: 0x10e88 - 0x10ea0
int32_t function_10e88(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    if (i_a1 == 0) {
        return 0;
    }
    // 0x10e90
    return function_10e48((char *)i_a2, i_a3);
}

// Address range: 0x10ea0 - 0x10ef8
int32_t function_10ea0(int32_t i_a1, int32_t *p_a2, int32_t *p_a3) {
    // 0x10ea0
    char *p_v1;                                     // bp-20, 0x10ea0
    int32_t i_v2 = strtoul((char *)i_a1, &p_v1, 0); // 0x10eb8
    *p_a2 = i_v2;
    if (*p_v1 != 58) {
        // 0x10ed0
        return i_v2;
    }
    char *p_v3 = (char *)((int32_t)p_v1 + 1); // 0x10ee4
    p_v1 = p_v3;
    int32_t i_v4 = strtoul(p_v3, NULL, 0); // 0x10ee8
    *p_a3 = i_v4;
    return i_v4;
}

// Address range: 0x10ef8 - 0x10f34
int32_t function_10ef8(void) {
    // 0x10ef8
    fwrite(
        (int32_t
             *)"\n____________________________WARNING__________________________"
               "__\nErroneously writing to a system EEPROM (like DIMM SPD "
               "modules)\ncan break your system.  It will NOT boot anymore so "
               "you'll not\nbe able to fix it.\n\nReading from 8bit EEPROMs "
               "(like that in your DIMM) without using\nthe -8 switch can also "
               "UNEXPECTEDLY write to them, so be sure to\nuse the -8 command "
               "param when required.\n\nUse -f to disable this warning "
               "message\n\nPress ENTER to continue or hit CTRL-C to exit\n\n",
        1, 469, p_g4);
    _IO_getc(p_g5);
    return 1;
}

// Address range: 0x10f34 - 0x11070
int32_t function_10f34(int32_t *p_a1, uint32_t i_a2, int32_t i_a3,
                       int32_t i_a4) {
    int32_t i_v1 = (int32_t)p_a1;
    int32_t i_v2 = function_11384(i_v1, i_a2 % 0x10000); // 0x10f50
    if (i_v2 < 0) {
        // 0x11060
        return function_10e48("read error", 125);
    }
    if (i_a4 == 0) {
        // 0x1103c
        _IO_putc(i_v2, p_g6);
    } else {
        // 0x10f64
        printf("\n %.4x|  %.2x ", i_a2, i_v2);
    }
    int32_t i_v3 = i_a2; // 0x10f98
    uint32_t i_v4 = 1;   // 0x10f98
    int32_t i_v5 = i_a3; // 0x10f98
    if (i_a3 == 1) {
        if (i_a4 == 0) {
            // 0x10ff4
            fflush(p_g6);
            return 0;
        }
    lab_0x10fe8:
        // 0x10fe8
        puts("\n");
        // 0x10ff4
        fflush(p_g6);
        return 0;
    }
    while (true) {
        int32_t i_v6 = function_11364(i_v1); // 0x10fa0
        if (i_v6 < 0) {
            // break (via goto) -> 0x11050
            goto lab_0x11050;
        }
        // 0x10fac
        i_v5--;
        while (i_a4 != 0) {
            int32_t i_v7 = i_v3 + 1; // 0x10fb8
            if (i_v4 % 16 == 0) {
                // 0x1101c
                printf("\n %.4x|  ", i_v7);
            } else {
                if (i_v4 % 8 == 0) {
                    // 0x11030
                    printf("  ");
                }
            }
            // 0x10fc8
            printf("%.2x ", i_v6);
            if (i_v5 == 1) {
                goto lab_0x10fe8;
            }
            i_v6 = function_11364(i_v1);
            if (i_v6 < 0) {
                // break (via goto) -> 0x11050
                goto lab_0x11050;
            }
            // 0x10fac
            i_v3 = i_v7;
            i_v4++;
            i_v5--;
        }
        // 0x11010
        _IO_putc(i_v6, p_g6);
        if (i_v5 == 1) {
            // 0x10ff4
            fflush(p_g6);
            return 0;
        }
    }
lab_0x11050:
    // 0x11050
    function_10e48("read error", 133);
    // UNREACHABLE
}

// Address range: 0x11070 - 0x11134
int32_t function_11070(int32_t *p_a1, int32_t i_a2) {
    int32_t i_v1 = i_a2;            // 0x1109c
    uint32_t i_v2 = _IO_getc(p_g5); // 0x110c8
    while (i_v2 != -1) {
        // 0x110dc
        if (i_g8 == 0) {
            // 0x110e4
            fputc(46, p_g4);
        }
        // 0x110a0
        fflush(p_g6);
        int32_t i_v3 = function_11468((int32_t)p_a1, i_v1 % 0x10000,
                                      i_v2 % 256); // 0x110b4
        i_v1++;
        if (i_v3 != 0) {
            // 0x11124
            function_10e48("write error", 160);
            // UNREACHABLE
        }
        i_v2 = _IO_getc(p_g5);
    }
    if (i_g8 == 0) {
        // 0x110fc
        fwrite((int32_t *)"\n\n", 1, 2, p_g4);
    }
    // 0x1111c
    return 0;
}

// Address range: 0x11134 - 0x1118c
int32_t function_11134(int32_t i_a1, int32_t i_a2) {
    int32_t i_v1 = i2c_smbus_write_byte_data(); // 0x11140
    if (i_v1 < 0) {
        // 0x1115c
        fprintf(p_g4, "Error i2c_write_2b: %s\n",
                strerror(*__errno_location()));
    }
    // 0x1114c
    usleep(0x1388);
    return i_v1;
}

// Address range: 0x1118c - 0x11338
int32_t function_1118c(int32_t i_a1, int32_t i_a2, int32_t i_a3,
                       int32_t *p_a4) {
    int32_t i_v1 = (int32_t)p_a4;
    int32_t *p_v2 = (int32_t *)(i_v1 + 4); // 0x1119c
    *p_v2 = 0;
    int32_t *p_v3 = (int32_t *)(i_v1 + 8); // 0x111a4
    *p_v3 = 0;
    *p_a4 = 0;
    int32_t i_v4 = open64((char *)i_a1, 2); // 0x111b8
    if (i_v4 < 1) {
        // 0x11238
        return -1;
    }
    int32_t i_v5 = ioctl(i_v4, 1797); // 0x111cc
    if (i_v5 < 0) {
        // 0x11238
        return i_v5;
    }
    int32_t i_v6; // 0x1118c
    if ((i_v6 & 0x20000) == 0) {
        // 0x112c0
        fwrite((int32_t *)"\nError: I2C_FUNC_SMBUS_READ_BYTE function is "
                          "required. Program halted.\n\n",
               1, 72, p_g4);
        exit(1);
        // UNREACHABLE
    }
    if ((i_v6 & 0x40000) == 0) {
        // 0x11310
        fwrite((int32_t *)"\nError: I2C_FUNC_SMBUS_WRITE_BYTE function is "
                          "required. Program halted.\n\n",
               1, 73, p_g4);
        exit(1);
        return &i_g9;
    }
    if ((i_v6 & 0x80000) == 0) {
        // 0x112e8
        fwrite((int32_t *)"\nError: I2C_FUNC_SMBUS_READ_BYTE_DATA function is "
                          "required. Program halted.\n\n",
               1, 77, p_g4);
        exit(1);
        // UNREACHABLE
    }
    if ((i_v6 & 0x100000) == 0) {
        // 0x11270
        fwrite((int32_t *)"\nError: I2C_FUNC_SMBUS_WRITE_BYTE_DATA function is "
                          "required. Program halted.\n\n",
               1, 78, p_g4);
        exit(1);
        // UNREACHABLE
    }
    if ((i_v6 & 0x200000) == 0) {
        // 0x11248
        fwrite((int32_t *)"\nError: I2C_FUNC_SMBUS_READ_WORD_DATA function is "
                          "required. Program halted.\n\n",
               1, 77, p_g4);
        exit(1);
        // UNREACHABLE
    }
    if ((i_v6 & 0x400000) == 0) {
        // 0x11298
        fwrite((int32_t *)"\nError: I2C_FUNC_SMBUS_WRITE_WORD_DATA function is "
                          "required. Program halted.\n\n",
               1, 78, p_g4);
        exit(1);
        // UNREACHABLE
    }
    int32_t i_v7 = ioctl(i_v4, 1795); // 0x11218
    int32_t i_v8 = i_v7;              // 0x11220
    if (i_v7 >= 0) {
        // 0x11224
        *p_v3 = i_v4;
        *p_v2 = i_a2;
        *p_a4 = i_a1;
        *(int32_t *)(i_v1 + 12) = i_a3;
        i_v8 = 0;
    }
    // 0x11238
    return i_v8;
}

// Address range: 0x11338 - 0x11364
int32_t function_11338(int32_t *p_a1) {
    int32_t i_v1 = (int32_t)p_a1;
    int32_t *p_v2 = (int32_t *)(i_v1 + 8); // 0x11340
    close(*p_v2);
    *p_a1 = 0;
    *p_v2 = -1;
    *(int32_t *)(i_v1 + 12) = 0;
    return 0;
}

// Address range: 0x11364 - 0x11384
int32_t function_11364(int32_t i_a1) {
    int32_t *p_v1 = (int32_t *)(i_a1 + 8); // 0x11370
    ioctl(*p_v1, 0x1261);
    return i2c_smbus_read_byte(*p_v1);
}

// Address range: 0x11384 - 0x11468
int32_t function_11384(int32_t i_a1, uint32_t i_a2) {
    int32_t *p_v1 = (int32_t *)(i_a1 + 8); // 0x11394
    ioctl(*p_v1, 0x1261);
    int32_t i_v2; // 0x11384
    switch (*(int32_t *)(i_a1 + 12)) {
    case 1: {
        int32_t i_v3 = i2c_smbus_write_byte(*p_v1, i_a2 % 256); // 0x113f8
        if (i_v3 < 0) {
            // 0x11410
            fprintf(p_g4, "Error i2c_write_1b: %s\n",
                    strerror(*__errno_location()));
        }
        // 0x11404
        usleep(0x1388);
        i_v2 = i_v3;
        // break -> 0x113d0
        break;
    }
    case 2: {
        // 0x113b4
        i_v2 = *p_v1;
        // break -> 0x113d0
        break;
    }
    default: {
        // 0x11440
        fwrite((int32_t *)"ERR: unknown eeprom type\n", 1, 25, p_g4);
        // 0x113e4
        return -1;
    }
    }
    int32_t i_v4 = i_v2; // 0x113d4
    if (i_v2 >= 0) {
        // 0x113d8
        i_v4 = i2c_smbus_read_byte(*p_v1);
    }
    // 0x113e4
    return i_v4;
}

// Address range: 0x11468 - 0x11534
int32_t function_11468(int32_t i_a1, uint32_t i_a2, int32_t i_a3) {
    // 0x11468
    int32_t i_v1; // 0x11498
    switch (*(int32_t *)(i_a1 + 12)) {
    case 1: {
        // 0x114e8
        return *(int32_t *)(i_a1 + 8);
    }
    case 2: {
        uint32_t i_v2 = i_a2 % 256;            // 0x11488
        int32_t i_v3 = *(int32_t *)(i_a1 + 8); // 0x1148c
        int32_t i_v4;                          // 0x11468
        i_v1 = i2c_smbus_write_word_data(i_v3, i_a2 / 256, 256 * i_a3 | i_v2,
                                         i_v2, i_v4, i_v4, i_v4);
        if (i_v1 < 0) {
            // 0x114b8
            fprintf(p_g4, "Error i2c_write_3b: %s\n",
                    strerror(*__errno_location()));
        }
        // break -> 0x114a4
        break;
    }
    default: {
        // 0x1150c
        fwrite((int32_t *)"ERR: unknown eeprom type\n", 1, 25, p_g4);
        // 0x114ac
        return -1;
    }
    }
    // 0x114a4
    usleep(0x1388);
    // 0x114ac
    return i_v1;
}

// Address range: 0x11534 - 0x11568
int32_t function_11534(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    int32_t i_v1 = function_107bc(i_a1, i_a2, i_a3, i_a4); // 0x11544
    int32_t i_v2 = (int32_t) "te the current timestamp at address 0x200 of the "
                             "EEPROM on\n\t   bus 0 at address 0x33\n\t\tdate "
                             "| eeprog /dev/i2c-0 0x33 -w 0x200\n" +
                                   0x11544 - (int32_t)&i_g1 >>
                               2 ==
                           0
                       ? i_v1
                       : i_a1;
    return i_v2;
}

// Address range: 0x11570 - 0x11572
int32_t function_11570(void) {
    // 0x11570
    int32_t i_v1; // 0x11570
    return i_v1;
}

// Address range: 0x11574 - 0x1157c
int32_t function_11574(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x11574
    return i_a1;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.4.3)
// Detected functions: 52
