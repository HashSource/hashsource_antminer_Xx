//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <arpa/inet.h>
#include <assert.h>
#include <ctype.h>
#include <errno.h>
#include <math.h>
#include <netdb.h>
#include <pthread.h>
#include <semaphore.h>
#include <signal.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stropts.h>
#include <sys/file.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <unistd.h>

// ----------------- Float Types Definitions ------------------

typedef float float32_t;
typedef double float64_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct _TYPEDEF_sigset_t {
    int32_t e0[1];
};

struct hostent {
    char *e0;
    char **e1;
    int32_t e2;
    int32_t e3;
    char **e4;
};

struct in_addr {
    int32_t e0;
};

struct sockaddr {
    int32_t e0;
    char e1[14];
};

struct timeval {
    int32_t e0;
    int32_t e1;
};

struct itimerval {
    struct timeval e0;
    struct timeval e1;
};

struct timezone {
    int32_t e0;
    int32_t e1;
};

// ------------------- Function Prototypes --------------------

void __assert_fail2(char *assertion, char *file, int32_t line, char *function);
int16_t **__ctype_b_loc2(void);
int32_t **__ctype_tolower_loc2(void);
int32_t *__errno_location2(void);
int32_t __libc_start_main2(int32_t main, int32_t argc, char **ubp_av,
                           void (*init)(), void (*fini)(), void (*rtld_fini)());
int32_t _fini(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t _init(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
void abort2(void);
int32_t access2(char *name, int32_t type);
int32_t *calloc2(int32_t nmemb, int32_t size);
int32_t chdir2(char *path);
int32_t close2(int32_t fd);
int32_t CONF_modules_free2(int32_t i_a1);
int32_t CONF_modules_unload2(int32_t i_a1);
int32_t connect2(int32_t fd, struct sockaddr *addr, int32_t len);
int32_t CRYPTO_cleanup_all_ex_data2(int32_t i_a1);
int32_t curl_easy_cleanup2(int32_t i_a1);
int32_t curl_easy_init2(int32_t i_a1);
int32_t curl_easy_perform2(int32_t i_a1);
int32_t curl_easy_setopt2(int32_t i_a1, int32_t i_a2, char *p_a3);
int32_t curl_global_init2(int32_t i_a1);
int32_t ENGINE_cleanup2(int32_t i_a1);
int32_t entry_point(int32_t i_a1, int32_t i_a2);
int32_t ERR_free_strings2(int32_t i_a1);
int32_t ERR_print_errors_fp2(int32_t i_a1);
int32_t ERR_remove_state2(int32_t i_a1);
int32_t EVP_cleanup2(int32_t i_a1);
void exit2(int32_t status);
int32_t fclose2(struct _IO_FILE *stream);
char *fgets2(char *s, int32_t n, struct _IO_FILE *stream);
int32_t fileno2(struct _IO_FILE *stream);
int32_t flock2(int32_t fd, int32_t operation);
float64_t floor2(float64_t f_a1);
struct _IO_FILE *fopen2(char *filename, char *modes);
int32_t fork2(void);
int32_t fprintf2(struct _IO_FILE *stream, char *format, ...);
int32_t fputs2(char *s, struct _IO_FILE *stream);
int32_t fread2(int32_t *ptr, int32_t size, int32_t n, struct _IO_FILE *stream);
void free2(int32_t *ptr);
int32_t fseek2(struct _IO_FILE *stream, int32_t off, int32_t whence);
int32_t ftell2(struct _IO_FILE *stream);
int32_t function_10004(int32_t i_a1, int32_t *p_a2, int32_t i_a3, int32_t i_a4);
int32_t function_10210(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_10474(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_1049296(void);
int32_t function_10710(int32_t *p_a1);
int32_t function_108b4(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_10a34(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_10bfc(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_10c84(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_10cac(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_10cd4(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_10d04(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_10d34(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t *p_a4);
int32_t function_10d70(int32_t i_a1);
int32_t function_10d80(int32_t i_a1);
int32_t function_10d90(int32_t *p_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_10ddc(int32_t i_a1, int32_t i_a2);
int32_t function_10e24(void);
int32_t function_10e94(int32_t i_a1, int32_t i_a2);
int32_t function_10ec0(int32_t *p_a1, int32_t i_a2, int32_t i_a3,
                       int32_t *p_a4);
int32_t function_10f48(int32_t i_a1);
int32_t function_10f88(void);
int32_t function_10f8c(int32_t i_a1);
int32_t function_10f9c(int32_t i_a1);
int32_t function_10fb0(int32_t i_a1);
int32_t function_10fc4(int32_t *p_a1, int32_t *p_a2);
int32_t function_10fe0(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_11044(void);
int32_t function_148d6a(void);
int32_t function_1533fe(void);
int32_t function_1885f36(void);
int32_t function_1888c2(void);
int32_t function_18c91be(void);
int32_t function_1908afe(void);
int32_t function_1988ee6(void);
int32_t function_1c84da(void);
int32_t function_1c8e9e(void);
int32_t function_48d36(void);
int32_t function_64630a(void);
int32_t function_6af476(void);
int32_t function_848b56(void);
int32_t function_888d56(void);
int32_t function_95502(void);
void function_9f64(void);
int32_t function_9fa0(uint32_t i_a1);
int32_t function_a2e8(void);
int32_t function_a30c(int32_t i_a1, int32_t i_a2, int32_t i_a3, char i_a4);
int32_t function_a344(int32_t *p_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_a384(void);
int32_t function_a3ac(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_a3e0(void);
int32_t function_a3ec(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_a514(void);
int32_t function_a680(void);
int32_t function_a7f4(void);
int32_t function_a8a0(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_a938(void);
int32_t function_aa14(void);
int32_t function_ab74(void);
int32_t function_ace4(int32_t i_a1, int32_t i_a2);
int32_t function_ad18(int32_t i_a1);
int32_t function_adb0(void);
int32_t function_ae1c(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_ae50(void);
int32_t function_af94(void);
int32_t function_af98(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_afe1(void);
int32_t function_afe8(void);
int32_t function_b020(void);
int32_t function_b088(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_b208(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_b250(int32_t *p_a1, int32_t *p_a2, int32_t *p_a3);
int32_t function_b340(int32_t *p_a1, int32_t *p_a2, int32_t *p_a3,
                      int32_t *p_a4);
int32_t function_b46c(int32_t i_a1);
int32_t function_b6d4(int32_t i_a1);
int32_t function_b91c(int32_t i_a1);
int32_t function_b9c4(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_ba30(int32_t i_a1);
int32_t function_ba54(int32_t i_a1);
int32_t function_ba78(char *p_a1);
int32_t function_ba9c(int32_t i_a1, int32_t *p_a2, int32_t *p_a3);
int32_t function_bc44(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t function_bea4(int32_t i_a1, int32_t *p_a2, int32_t i_a3);
int32_t function_c130(uint32_t i_a1);
int32_t function_c244(int32_t i_a1, int32_t i_a2);
int32_t function_c540(void);
int32_t function_c574(int32_t *p_a1);
int32_t function_c5b4(int32_t i_a1);
int32_t function_c634(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_c69c(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_c8292(void);
int32_t function_c83c(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_d05c(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_d7ec(void);
int32_t function_d800(void);
int32_t function_d810(int32_t i_a1);
int32_t function_d858(int32_t i_a1, int32_t i_a2);
int32_t function_d864(int32_t i_a1);
int32_t function_d8e4(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t function_d9d8(int32_t i_a1);
int32_t function_d9e4(int32_t i_a1);
int32_t function_d9f0(void);
int32_t function_d9fc(int32_t i_a1);
int32_t function_da28(int32_t i_a1, int32_t i_a2);
int32_t function_da50(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_da90(int32_t i_a1, int32_t i_a2);
int32_t function_dac8(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t function_db34(int32_t i_a1, int32_t i_a2);
int32_t function_db7c(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_dba4(int32_t i_a1, int32_t i_a2);
int32_t function_dc0c(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_dc1c(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_dc78(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_dc88(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t function_dcfc(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t function_dd68(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_dd80(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_dd98(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_ddb0(int32_t i_a1);
int32_t function_ddd4(void);
int32_t function_ddd6(void);
int32_t function_dde0(void);
int32_t function_ddee(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_de00(int32_t i_a1);
int32_t function_de04(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_de34(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_de4c(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_de64(int32_t i_a1, int32_t i_a2);
int32_t function_dec8(int32_t i_a1, int32_t i_a2);
int32_t function_df24(int32_t i_a1, uint32_t i_a2);
int32_t function_df7c(int32_t i_a1, uint32_t i_a2);
int32_t function_dfd8(int32_t i_a1, int32_t i_a2);
int32_t function_e0bc(int32_t i_a1);
int32_t function_e1f4(void);
int32_t function_e1f8(int32_t *p_a1);
int32_t function_e284(char *p_a1, int32_t *p_a2);
int32_t function_e340(int32_t i_a1, char *p_a2);
int32_t function_e444(int32_t *p_a1, int32_t *p_a2);
int32_t function_e49c(int32_t i_a1);
int32_t function_e4cc(int32_t *p_a1);
int32_t function_e4e4(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t function_e50c(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t function_e54c(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_e598(int32_t *p_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_e62c(int32_t *p_a1, int32_t *p_a2);
int32_t function_e698(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_e75c(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_e7a4(int32_t i_a1);
int32_t function_e7d8(int32_t *p_a1);
int32_t function_e7ec(void);
int32_t function_e7f4(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_e8dc(void);
int32_t function_eb78(void);
int32_t function_ecd0(int32_t i_a1, uint32_t i_a2);
int32_t function_edfc(char *p_a1);
int32_t function_f064(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_f108(char *p_a1);
int32_t function_f410(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_f470(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_f4c0(void);
int32_t function_f69c(char *p_a1, int32_t *p_a2);
int32_t function_f798(void);
int32_t function_f84c(void);
int32_t function_f854(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_f990(int32_t i_a1, char *p_a2, int32_t *p_a3);
int32_t function_fa50(int32_t i_a1, char *p_a2, int32_t *p_a3, int32_t *p_a4);
int32_t function_fa54(int32_t i_a1, int32_t i_a2);
int32_t function_fc80(int32_t i_a1, int32_t *p_a2, char i_a3, char i_a4);
int32_t function_fc84(int32_t i_a1);
int32_t function_fe3c5ec2(void);
int32_t function_fe448956(void);
int32_t function_fe44919a(void);
int32_t function_fe8c8dba(void);
int32_t function_fe9491a2(void);
int32_t function_feb0(int32_t *p_a1, int32_t *p_a2);
int32_t function_ff048522(void);
int32_t function_ff048b46(void);
int32_t function_ff24807e(void);
int32_t function_ff24883a(void);
int32_t function_ff848096(void);
int32_t function_ff8480a6(void);
int32_t function_ff8484ca(void);
int32_t function_ff848826(void);
int32_t function_ff8882ca(void);
int32_t function_ff8883f6(void);
int32_t function_ff90690e(void);
int32_t function_ffa0631a(void);
int32_t function_ffa0652a(void);
int32_t function_ffa45ae2(void);
int32_t function_ffb2f126(void);
int32_t function_ffbaf116(void);
int32_t function_ffcc7f66(void);
int32_t fwrite2(int32_t *ptr, int32_t size, int32_t n, struct _IO_FILE *s);
struct hostent *gethostbyname2(char *name);
int32_t getpid2(void);
int32_t getsockopt2(int32_t fd, int32_t level, int32_t optname, int32_t *optval,
                    int32_t *optlen);
int32_t gettimeofday2(struct timeval *tv, struct timezone *tz);
char *inet_ntoa2(struct in_addr x_a1);
int32_t ioctl2(int32_t fd, int32_t request, ...);
int32_t *malloc2(int32_t size);
int32_t *memcpy2(int32_t *dest, int32_t *src, int32_t n);
int32_t *memset2(int32_t *s, int32_t c, int32_t n);
int32_t mkdir2(char *path, int32_t mode);
int32_t OPENSSL_add_all_algorithms_noconf2(int32_t i_a1);
void perror2(char *s);
float64_t pow2(float64_t f_a1, float64_t f_a2);
int32_t printf2(char *format, ...);
int32_t pthread_create2(int32_t *newthread, int32_t *attr,
                        int32_t *(*start_routine)(int32_t *), int32_t *arg);
int32_t pthread_join2(int32_t th, int32_t **thread_return);
int32_t putchar2(int32_t c);
int32_t puts2(char *s);
int32_t raise2(int32_t sig);
int32_t *realloc2(int32_t *ptr, int32_t size);
int32_t recv2(int32_t fd, int32_t *buf, int32_t n, int32_t flags);
int32_t sem_init2(int32_t *sem, int32_t pshared, int32_t value);
int32_t send2(int32_t fd, int32_t *buf, int32_t n, int32_t flags);
int32_t setitimer2(int32_t which, struct itimerval *new, struct itimerval *old);
int32_t setsid2(void);
int32_t sigaddset2(struct _TYPEDEF_sigset_t *set, int32_t signo);
int32_t sigdelset2(struct _TYPEDEF_sigset_t *set, int32_t signo);
int32_t sigemptyset2(struct _TYPEDEF_sigset_t *set);
int32_t sigfillset2(struct _TYPEDEF_sigset_t *set);
void (*signal2(int32_t sig, void (*handler)(int32_t)))(int32_t);
int32_t sigprocmask2(int32_t how, struct _TYPEDEF_sigset_t *set,
                     struct _TYPEDEF_sigset_t *oset);
int32_t sk_free2(int32_t i_a1);
int32_t sleep2(int32_t seconds);
int32_t socket2(int32_t domain, int32_t type, int32_t protocol);
int32_t sprintf2(char *s, char *format, ...);
int32_t SSL_CIPHER_get_name2(int32_t i_a1);
int32_t SSL_COMP_get_compression_methods2(int32_t i_a1);
int32_t SSL_connect2(int32_t i_a1);
int32_t SSL_CTX_free2(int32_t i_a1);
int32_t SSL_CTX_new2(int32_t i_a1);
int32_t SSL_free2(int32_t i_a1);
int32_t SSL_get_current_cipher2(int32_t i_a1);
int32_t SSL_get_peer_certificate2(void);
int32_t SSL_library_init2(void);
int32_t SSL_load_error_strings2(int32_t i_a1);
int32_t SSL_new2(void);
int32_t SSL_read2(void);
int32_t SSL_set_fd2(void);
int32_t SSL_shutdown2(int32_t i_a1);
int32_t SSL_write2(void);
char *stpcpy2(char *dest, char *src);
int32_t strcasecmp2(char *s1, char *s2);
char *strcat2(char *dest, char *src);
char *strchr2(char *s, int32_t c);
int32_t strcmp2(char *s1, char *s2);
char *strcpy2(char *dest, char *src);
char *strerror2(int32_t errnum);
int32_t strlen2(char *s);
char *strncat2(char *dest, char *src, int32_t n);
int32_t strncmp2(char *s1, char *s2, int32_t n);
char *strncpy2(char *dest, char *src, int32_t n);
char *strrchr2(char *s, int32_t c);
int32_t strtol2(char *nptr, char **endptr, int32_t base);
int32_t system2(char *command);
int32_t TLSv1_client_method2(int32_t i_a1);
int32_t umask2(int32_t mask);
int32_t unknown_40de30(void);
int32_t unknown_40e838(void);
int32_t X509_free2(int32_t i_a1);
int32_t X509_get_issuer_name2(int32_t i_a1);
int32_t X509_get_subject_name2(int32_t i_a1);
int32_t X509_NAME_oneline2(int32_t i_a1);

// --------------------- Global Variables ---------------------

int32_t i_g1 = 0x11e14;                                // 0x10000
int32_t i_g2 = -0x1a603fe4;                            // 0x10c84
int32_t i_g3 = -0x1a603fe4;                            // 0x10cac
int32_t i_g4 = -0x1a603fdc;                            // 0x10cd4
int32_t i_g5 = -0x1a603fdc;                            // 0x10d04
void (*p_g6)() = (void (*)()) - 0x1ed000e2;            // 0x11044
char *p_g7 = "No certificate information\xef\xbc\x81"; // 0x1129c
int32_t i_g8 = 0;                                      // 0x11908
char *p_g9;                                            // 0x1190c
int32_t i_g10 = 83;                                    // 0x11d78
int32_t i_g11 = 70;                                    // 0x11d94
int32_t i_g12 = 0xa3ac;                                // 0x1b000
int32_t i_g13 = 0xa384;                                // 0x1b004
int32_t i_g14 = 0;                                     // 0x1b008
int32_t i_g15 = 0;                                     // 0x1b2e0
char *p_g16 = "\x01";                                  // 0x1b2ec
char (*p_g17)[26] = "/config/minermonitor.conf";       // 0x1b2f0
int32_t i_g18 = 1;                                     // 0x1b2f4
char *x_g21[17] = {
    "lcd",          "01", "02", "03", "04", "05", "06", "07",
    "10",           "20", "30", "40", "50", "60", "70", "/config/cgminer.conf",
    "192.168.1.187"}; // 0x1b330
char *x_g22[9] = {"10",           "20", "30", "40",
                  "50",           "60", "70", "/config/cgminer.conf",
                  "192.168.1.187"}; // 0x1b350
char *x_g23[2] = {"/config/cgminer.conf", "192.168.1.187"}; // 0x1b36c
int32_t i_g24 = 0x9e68;                                     // 0x1b374
int32_t i_g25 = 0x9b20;                                     // 0x1b378
int32_t i_g26 = 1;                                          // 0x1b380
int32_t i_g27 = 0;                                          // 0x1b388
int32_t i_g28 = 0;                                          // 0x1b38c
char *p_g29;                                                // 0x1b390
int32_t i_g30 = 0;                                          // 0x1b394
int32_t i_g31 = 0;                                          // 0x1b398
int32_t i_g32 = 0;                                          // 0x1b3a0
int32_t i_g33 = 0;                                          // 0x1b3a4
int32_t i_g34 = 0;                                          // 0x1b3a8
int32_t i_g35 = 0;                                          // 0x1b3ac
int32_t i_g36 = 0;                                          // 0x1b3b0
int32_t i_g37 = 0;                                          // 0x1b3b8
char *p_g38;                                                // 0x1b3bb
char i_g39 = 0;                                             // 0x1b3bc
char i_g40 = 0;                                             // 0x1b3bd
int32_t i_g41 = 0;                                          // 0x1b3c0
int32_t i_g42 = 0;                                          // 0x1b3c4
int32_t i_g43 = 0;                                          // 0x1b3c8
char *p_g44;                                                // 0x1c3c0
struct _IO_FILE *p_g45 = NULL;                              // 0x1c3c8
int32_t i_g46 = 0;                                          // 0x1c3cc
char *p_g47;                                                // 0x1c3d0
int32_t i_g48 = 0;                                          // 0x1c3d4
int32_t i_g49 = 0;                                          // 0x1c3d8
int32_t i_g50 = 0;                                          // 0x1c3dc
int32_t i_g51 = 0;                                          // 0x1c3e0
int32_t i_g52 = 0;                                          // 0x1c3e4
int32_t i_g53 = 0;                                          // 0x1d3e4
int32_t i_g54 = 0;                                          // 0x1d404
int32_t i_g55 = 0;                                          // 0x1d40c
int32_t i_g56 = 0;                                          // 0x1d410
int32_t i_g57 = 0;                                          // 0x1d414
int32_t i_g58 = 0;                                          // 0x1d418
int32_t i_g59 = 0;                                          // 0x1d41c
int32_t i_g60 = 0;                                          // 0x1d420
int32_t i_g61 = 0;                                          // 0x1d424
int32_t i_g62 = 0;                                          // 0x1d434
int32_t i_g63 = 0;                                          // 0x1d43c
int32_t i_g64 = 0;                                          // 0x1d440
char *p_g65;                                                // 0x1d444
char *p_g66;                                                // 0x1d447
int32_t i_g67 = 0;                                          // 0x1d448
int32_t i_g68 = 0;                                          // 0x1d44c
int32_t i_g69 = 0;                                          // 0x1d450
int32_t i_g70 = 0;                                          // 0x1d454
char *p_g71;                                                // 0x1e44c
char *p_g72;                                                // 0x1e454
char i_g73 = 0;                                             // 0x1e455
char i_g74 = 0;                                             // 0x1e456
char *p_g75;                                                // 0x1e457
int32_t i_g76 = 0;                                          // 0x1e458
int32_t i_g77 = 0;                                          // 0x1e459
int32_t i_g78 = 0;                                          // 0x1e45c
int32_t i_g79 = 0;                                          // 0x1e460
char *p_g80;                                                // 0x1f45c
int32_t i_g81 = 0;                                          // 0x1f464
char *p_g82;                                                // 0x1f468
char *p_g83;                                                // 0x24490
int16_t *p_g84 = NULL;                                      // 0x258b8
int32_t i_g85 = 0;                                          // 0x258bc
int16_t *p_g86 = NULL;                                      // 0x258c0
int32_t i_g87 = 0;                                          // 0x258c2
int32_t i_g88 = 0;                                          // 0x258c4
char *p_g89;                                                // 0x25ab4
int16_t *p_g90 = NULL;                                      // 0x26ab4
int32_t i_g91 = 0;                                          // 0x26ab6
char *p_g92;                                                // 0x26ab8
int32_t i_g93 = 0;                                          // 0x26abc
int32_t i_g94 = 0;                                          // 0x26ac0
int32_t i_g95 = 0;                                          // 0x26ac4
int32_t i_g96 = 0;                                          // 0x26ac8
int32_t i_g97 = 0;                                          // 0x26acc
int32_t i_g98 = 0;                                          // 0x26ad0
int32_t i_g99 = 0;                                          // 0x26ad4
int32_t i_g100 = 0;                                         // 0x26ad8
int32_t i_g101 = 0;                                         // 0x26adc
int32_t i_g102 = 0;                                         // 0x26ae0
int32_t i_g103 = 0;                                         // 0x26d24
int32_t i_g104 = 0;                                         // 0x26d6c
int32_t i_g105 = 0;                                         // 0x26f8c
int32_t i_g106 = 0;                                         // 0x26f90
int32_t i_g107 = 0;                                         // 0x26f94
int32_t i_g108 = 0;                                         // 0x26f98
int32_t i_g109 = 0x58000005;                                // 0x8915
int32_t i_g110 = 0x9b2c00;                                  // 0x8927
int32_t i_g111 = 18;                                        // 0x8d80
int32_t i_g112 = 158;                                       // 0x8e39
void (*p_g113)(int32_t) = (void (*)(int32_t)) - 0x1cfeffac; // 0xa3e0
int32_t *(*p_g114)(int32_t *) = (int32_t * (*)(int32_t *)) -
                                0x16d2ba10; // 0xa514
int32_t *(*p_g115)(int32_t *) = (int32_t * (*)(int32_t *)) -
                                0x16d2ba10; // 0xa680
int32_t *(*p_g116)(int32_t *) = (int32_t * (*)(int32_t *)) -
                                0x16d2bf90;                 // 0xa7f4
void (*p_g117)(int32_t) = (void (*)(int32_t)) - 0x1a60ced8; // 0xab74
int32_t i_g118 = 0x1a00000b;                                // 0xc3d0
int32_t i_g119 = -0x1caeffd4;                               // 0xd3f4
int32_t i_g120 = -0x1cf4cc5c;                               // 0xd800
int32_t i_g121 = 0x11e1400;                                 // 0xffff
int32_t i_g122;
int32_t i_g123;
int32_t i_g124;
int32_t i_g125;
char *x_g19[31] = {"/tmp/miner-monitor/pid",
                   (char *)&i_g8,
                   "/config/dataformatconfig/dataformat_devs.conf",
                   "/config/dataformatconfig/dataformat_summary.conf",
                   "/config/dataformatconfig/dataformat_stats.conf",
                   "/config/dataformatconfig/dataformat_pools.conf",
                   (char *)&i_g8,
                   "/config/dataformatconfig/dataformat_lcds.conf",
                   "AUTH",
                   "devs",
                   "summary",
                   "stats",
                   "pools",
                   (char *)&i_g8,
                   "lcd",
                   "01",
                   "02",
                   "03",
                   "04",
                   "05",
                   "06",
                   "07",
                   "10",
                   "20",
                   "30",
                   "40",
                   "50",
                   "60",
                   "70",
                   "/config/cgminer.conf",
                   "192.168.1.187"}; // 0x1b2f8
char *x_g20[6] = {"AUTH",  "devs",  "summary",
                  "stats", "pools", (char *)&i_g8}; // 0x1b318

// ------- Dynamically Linked Functions Without Header --------

void __gmon_start__(void);
int32_t __libc_start_main(int32_t i_a1, int32_t i_a2, char **p_a3,
                          void (*p_a4)(), void (*p_a5)(), void (*p_a6)());
int32_t CONF_modules_free(int32_t i_a1);
int32_t CONF_modules_unload(int32_t i_a1);
int32_t CRYPTO_cleanup_all_ex_data(int32_t i_a1);
int32_t curl_easy_cleanup(int32_t i_a1);
int32_t curl_easy_init(int32_t i_a1);
int32_t curl_easy_perform(int32_t i_a1);
int32_t curl_easy_setopt(int32_t i_a1, int32_t i_a2, char *p_a3);
int32_t curl_global_init(int32_t i_a1);
int32_t ENGINE_cleanup(int32_t i_a1);
int32_t ERR_free_strings(int32_t i_a1);
int32_t ERR_print_errors_fp(int32_t i_a1);
int32_t ERR_remove_state(int32_t i_a1);
int32_t EVP_cleanup(int32_t i_a1);
int32_t OPENSSL_add_all_algorithms_noconf(int32_t i_a1);
int32_t sk_free(int32_t i_a1);
int32_t SSL_CIPHER_get_name(int32_t i_a1);
int32_t SSL_COMP_get_compression_methods(int32_t i_a1);
int32_t SSL_connect(int32_t i_a1);
int32_t SSL_CTX_free(int32_t i_a1);
int32_t SSL_CTX_new(int32_t i_a1);
int32_t SSL_free(int32_t i_a1);
int32_t SSL_get_current_cipher(int32_t i_a1);
int32_t SSL_get_peer_certificate(void);
int32_t SSL_library_init(void);
int32_t SSL_load_error_strings(int32_t i_a1);
int32_t SSL_new(void);
int32_t SSL_read(void);
int32_t SSL_set_fd(void);
int32_t SSL_shutdown(int32_t i_a1);
int32_t SSL_write(void);
int32_t TLSv1_client_method(int32_t i_a1);
int32_t X509_free(int32_t i_a1);
int32_t X509_get_issuer_name(int32_t i_a1);
int32_t X509_get_subject_name(int32_t i_a1);
int32_t X509_NAME_oneline(int32_t i_a1);

// ------------------------ Functions -------------------------

// Address range: 0x9a58 - 0x9a64
int32_t _init(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x9a58
    return function_a2e8();
}

// Address range: 0x9a78 - 0x9a84
int32_t SSL_write2(void) {
    // 0x9a78
    return SSL_write();
}

// Address range: 0x9a84 - 0x9a90
int32_t SSL_load_error_strings2(int32_t i_a1) {
    // 0x9a84
    return SSL_load_error_strings(i_a1);
}

// Address range: 0x9a90 - 0x9a9c
void (*signal2(int32_t sig, void (*handler)(int32_t)))(int32_t) {
    // 0x9a90
    return signal(sig, handler);
}

// Address range: 0x9a9c - 0x9aa8
int32_t chdir2(char *path) {
    // 0x9a9c
    return chdir(path);
}

// Address range: 0x9aa8 - 0x9ab4
int32_t curl_easy_perform2(int32_t i_a1) {
    // 0x9aa8
    return curl_easy_perform(i_a1);
}

// Address range: 0x9ab4 - 0x9ac0
int32_t getpid2(void) {
    // 0x9ab4
    return getpid();
}

// Address range: 0x9ac0 - 0x9acc
int32_t EVP_cleanup2(int32_t i_a1) {
    // 0x9ac0
    return EVP_cleanup(i_a1);
}

// Address range: 0x9acc - 0x9ad8
int32_t gettimeofday2(struct timeval *tv, struct timezone *tz) {
    // 0x9acc
    return gettimeofday(tv, tz);
}

// Address range: 0x9ad8 - 0x9ae4
int32_t X509_free2(int32_t i_a1) {
    // 0x9ad8
    return X509_free(i_a1);
}

// Address range: 0x9ae4 - 0x9af0
int32_t getsockopt2(int32_t fd, int32_t level, int32_t optname, int32_t *optval,
                    int32_t *optlen) {
    // 0x9ae4
    return getsockopt(fd, level, optname, optval, optlen);
}

// Address range: 0x9af0 - 0x9afc
int32_t ERR_free_strings2(int32_t i_a1) {
    // 0x9af0
    return ERR_free_strings(i_a1);
}

// Address range: 0x9afc - 0x9b08
int32_t strcasecmp2(char *s1, char *s2) {
    // 0x9afc
    return strcasecmp(s1, s2);
}

// Address range: 0x9b08 - 0x9b14
int32_t strtol2(char *nptr, char **endptr, int32_t base) {
    // 0x9b08
    return strtol(nptr, endptr, base);
}

// Address range: 0x9b14 - 0x9b20
int32_t curl_easy_init2(int32_t i_a1) {
    // 0x9b14
    return curl_easy_init(i_a1);
}

// Address range: 0x9b20 - 0x9b2c
void free2(int32_t *ptr) {
    // 0x9b20
    free(ptr);
}

// Address range: 0x9b2c - 0x9b38
int32_t SSL_library_init2(void) {
    // 0x9b2c
    return SSL_library_init();
}

// Address range: 0x9b38 - 0x9b44
int32_t fseek2(struct _IO_FILE *stream, int32_t off, int32_t whence) {
    // 0x9b38
    return fseek(stream, off, whence);
}

// Address range: 0x9b44 - 0x9b50
int32_t ERR_print_errors_fp2(int32_t i_a1) {
    // 0x9b44
    return ERR_print_errors_fp(i_a1);
}

// Address range: 0x9b50 - 0x9b5c
int32_t X509_get_subject_name2(int32_t i_a1) {
    // 0x9b50
    return X509_get_subject_name(i_a1);
}

// Address range: 0x9b5c - 0x9b68
int32_t strncmp2(char *s1, char *s2, int32_t n) {
    // 0x9b5c
    return strncmp(s1, s2, n);
}

// Address range: 0x9b68 - 0x9b74
int32_t pthread_join2(int32_t th, int32_t **thread_return) {
    // 0x9b68
    return pthread_join(th, thread_return);
}

// Address range: 0x9b74 - 0x9b80
int32_t ERR_remove_state2(int32_t i_a1) {
    // 0x9b74
    return ERR_remove_state(i_a1);
}

// Address range: 0x9b80 - 0x9b8c
void exit2(int32_t status) {
    // 0x9b80
    exit(status);
}

// Address range: 0x9b8c - 0x9b98
int32_t printf2(char *format, ...) {
    // 0x9b8c
    return printf(format);
}

// Address range: 0x9b98 - 0x9ba4
char *strerror2(int32_t errnum) {
    // 0x9b98
    return strerror(errnum);
}

// Address range: 0x9ba4 - 0x9bb0
int32_t SSL_read2(void) {
    // 0x9ba4
    return SSL_read();
}

// Address range: 0x9bb0 - 0x9bbc
char *stpcpy2(char *dest, char *src) {
    // 0x9bb0
    return stpcpy(dest, src);
}

// Address range: 0x9bbc - 0x9bc8
int32_t SSL_connect2(int32_t i_a1) {
    // 0x9bbc
    return SSL_connect(i_a1);
}

// Address range: 0x9bc8 - 0x9bd4
int32_t puts2(char *s) {
    // 0x9bc8
    return puts(s);
}

// Address range: 0x9bd4 - 0x9be0
void perror2(char *s) {
    // 0x9bd4
    perror(s);
}

// Address range: 0x9be0 - 0x9bec
int32_t flock2(int32_t fd, int32_t operation) {
    // 0x9be0
    return flock(fd, operation);
}

// Address range: 0x9bec - 0x9bf8
int32_t sigfillset2(struct _TYPEDEF_sigset_t *set) {
    // 0x9bec
    return sigfillset(set);
}

// Address range: 0x9bf8 - 0x9c04
int32_t setitimer2(int32_t which, struct itimerval *new,
                   struct itimerval *old) {
    // 0x9bf8
    return setitimer(which, new, old);
}

// Address range: 0x9c04 - 0x9c10
int32_t SSL_CIPHER_get_name2(int32_t i_a1) {
    // 0x9c04
    return SSL_CIPHER_get_name(i_a1);
}

// Address range: 0x9c10 - 0x9c1c
int32_t putchar2(int32_t c) {
    // 0x9c10
    return putchar(c);
}

// Address range: 0x9c1c - 0x9c28
int32_t *memset2(int32_t *s, int32_t c, int32_t n) {
    // 0x9c1c
    return memset(s, c, n);
}

// Address range: 0x9c28 - 0x9c34
int32_t recv2(int32_t fd, int32_t *buf, int32_t n, int32_t flags) {
    // 0x9c28
    return recv(fd, buf, n, flags);
}

// Address range: 0x9c34 - 0x9c40
int32_t SSL_get_current_cipher2(int32_t i_a1) {
    // 0x9c34
    return SSL_get_current_cipher(i_a1);
}

// Address range: 0x9c40 - 0x9c4c
int32_t sigaddset2(struct _TYPEDEF_sigset_t *set, int32_t signo) {
    // 0x9c40
    return sigaddset(set, signo);
}

// Address range: 0x9c4c - 0x9c58
int32_t close2(int32_t fd) {
    // 0x9c4c
    return close(fd);
}

// Address range: 0x9c58 - 0x9c64
struct _IO_FILE *fopen2(char *filename, char *modes) {
    // 0x9c58
    return fopen(filename, modes);
}

// Address range: 0x9c64 - 0x9c70
int32_t sk_free2(int32_t i_a1) {
    // 0x9c64
    return sk_free(i_a1);
}

// Address range: 0x9c70 - 0x9c7c
void abort2(void) {
    // 0x9c70
    abort();
}

// Address range: 0x9c7c - 0x9c88
int32_t X509_NAME_oneline2(int32_t i_a1) {
    // 0x9c7c
    return X509_NAME_oneline(i_a1);
}

// Address range: 0x9c88 - 0x9c94
float64_t pow2(float64_t f_a1, float64_t f_a2) {
    // 0x9c88
    return pow(f_a1, f_a2);
}

// Address range: 0x9c94 - 0x9ca0
struct hostent *gethostbyname2(char *name) {
    // 0x9c94
    return gethostbyname(name);
}

// Address range: 0x9ca0 - 0x9cac
int32_t ioctl2(int32_t fd, int32_t request, ...) {
    // 0x9ca0
    return ioctl(fd, request);
}

// Address range: 0x9cac - 0x9cb8
int32_t system2(char *command) {
    // 0x9cac
    return system(command);
}

// Address range: 0x9cb8 - 0x9cc4
int32_t SSL_get_peer_certificate2(void) {
    // 0x9cb8
    return SSL_get_peer_certificate();
}

// Address range: 0x9cc4 - 0x9cd0
char *inet_ntoa2(struct in_addr x_a1) {
    // 0x9cc4
    return inet_ntoa(x_a1);
}

// Address range: 0x9cd0 - 0x9cdc
int32_t *realloc2(int32_t *ptr, int32_t size) {
    // 0x9cd0
    return realloc(ptr, size);
}

// Address range: 0x9cdc - 0x9ce8
char *strcpy2(char *dest, char *src) {
    // 0x9cdc
    return strcpy(dest, src);
}

// Address range: 0x9ce8 - 0x9cf4
void __assert_fail2(char *assertion, char *file, int32_t line, char *function) {
    // 0x9ce8
    __assert_fail(assertion, file, line, function);
}

// Address range: 0x9cf4 - 0x9d00
int32_t curl_easy_cleanup2(int32_t i_a1) {
    // 0x9cf4
    return curl_easy_cleanup(i_a1);
}

// Address range: 0x9d00 - 0x9d0c
int32_t SSL_free2(int32_t i_a1) {
    // 0x9d00
    return SSL_free(i_a1);
}

// Address range: 0x9d0c - 0x9d18
char *strcat2(char *dest, char *src) {
    // 0x9d0c
    return strcat(dest, src);
}

// Address range: 0x9d18 - 0x9d24
int32_t CRYPTO_cleanup_all_ex_data2(int32_t i_a1) {
    // 0x9d18
    return CRYPTO_cleanup_all_ex_data(i_a1);
}

// Address range: 0x9d24 - 0x9d30
int32_t fread2(int32_t *ptr, int32_t size, int32_t n, struct _IO_FILE *stream) {
    // 0x9d24
    return fread(ptr, size, n, stream);
}

// Address range: 0x9d30 - 0x9d3c
int32_t fileno2(struct _IO_FILE *stream) {
    // 0x9d30
    return fileno(stream);
}

// Address range: 0x9d3c - 0x9d48
int32_t fork2(void) {
    // 0x9d3c
    return fork();
}

// Address range: 0x9d48 - 0x9d54
int32_t socket2(int32_t domain, int32_t type, int32_t protocol) {
    // 0x9d48
    return socket(domain, type, protocol);
}

// Address range: 0x9d54 - 0x9d60
int32_t access2(char *name, int32_t type) {
    // 0x9d54
    return access(name, type);
}

// Address range: 0x9d60 - 0x9d6c
int32_t sigdelset2(struct _TYPEDEF_sigset_t *set, int32_t signo) {
    // 0x9d60
    return sigdelset(set, signo);
}

// Address range: 0x9d6c - 0x9d78
int32_t setsid2(void) {
    // 0x9d6c
    return setsid();
}

// Address range: 0x9d78 - 0x9d84
int32_t mkdir2(char *path, int32_t mode) {
    // 0x9d78
    return mkdir(path, mode);
}

// Address range: 0x9d84 - 0x9d90
int32_t CONF_modules_unload2(int32_t i_a1) {
    // 0x9d84
    return CONF_modules_unload(i_a1);
}

// Address range: 0x9d90 - 0x9d9c
int32_t SSL_COMP_get_compression_methods2(int32_t i_a1) {
    // 0x9d90
    return SSL_COMP_get_compression_methods(i_a1);
}

// Address range: 0x9d9c - 0x9da8
int32_t sem_init2(int32_t *sem, int32_t pshared, int32_t value) {
    // 0x9d9c
    return sem_init(sem, pshared, value);
}

// Address range: 0x9da8 - 0x9db4
int32_t OPENSSL_add_all_algorithms_noconf2(int32_t i_a1) {
    // 0x9da8
    return OPENSSL_add_all_algorithms_noconf(i_a1);
}

// Address range: 0x9db4 - 0x9dc0
int32_t SSL_new2(void) {
    // 0x9db4
    return SSL_new();
}

// Address range: 0x9dc0 - 0x9dcc
int32_t sleep2(int32_t seconds) {
    // 0x9dc0
    return sleep(seconds);
}

// Address range: 0x9dcc - 0x9dd8
int32_t raise2(int32_t sig) {
    // 0x9dcc
    return raise(sig);
}

// Address range: 0x9dd8 - 0x9de4
int16_t **__ctype_b_loc2(void) {
    // 0x9dd8
    return __ctype_b_loc();
}

// Address range: 0x9de4 - 0x9df0
int32_t connect2(int32_t fd, struct sockaddr *addr, int32_t len) {
    // 0x9de4
    return connect(fd, addr, len);
}

// Address range: 0x9df0 - 0x9dfc
int32_t SSL_CTX_free2(int32_t i_a1) {
    // 0x9df0
    return SSL_CTX_free(i_a1);
}

// Address range: 0x9dfc - 0x9e08
int32_t *calloc2(int32_t nmemb, int32_t size) {
    // 0x9dfc
    return calloc(nmemb, size);
}

// Address range: 0x9e08 - 0x9e14
char *strncat2(char *dest, char *src, int32_t n) {
    // 0x9e08
    return strncat(dest, src, n);
}

// Address range: 0x9e14 - 0x9e20
int32_t ftell2(struct _IO_FILE *stream) {
    // 0x9e14
    return ftell(stream);
}

// Address range: 0x9e20 - 0x9e2c
int32_t curl_easy_setopt2(int32_t i_a1, int32_t i_a2, char *p_a3) {
    // 0x9e20
    return curl_easy_setopt(i_a1, i_a2, p_a3);
}

// Address range: 0x9e2c - 0x9e38
char *fgets2(char *s, int32_t n, struct _IO_FILE *stream) {
    // 0x9e2c
    return fgets(s, n, stream);
}

// Address range: 0x9e38 - 0x9e44
int32_t fwrite2(int32_t *ptr, int32_t size, int32_t n, struct _IO_FILE *s) {
    // 0x9e38
    return fwrite(ptr, size, n, s);
}

// Address range: 0x9e44 - 0x9e50
int32_t *memcpy2(int32_t *dest, int32_t *src, int32_t n) {
    // 0x9e44
    return memcpy(dest, src, n);
}

// Address range: 0x9e50 - 0x9e5c
int32_t umask2(int32_t mask) {
    // 0x9e50
    return umask(mask);
}

// Address range: 0x9e5c - 0x9e68
int32_t curl_global_init2(int32_t i_a1) {
    // 0x9e5c
    return curl_global_init(i_a1);
}

// Address range: 0x9e68 - 0x9e74
int32_t *malloc2(int32_t size) {
    // 0x9e68
    return malloc(size);
}

// Address range: 0x9e74 - 0x9e80
int32_t strlen2(char *s) {
    // 0x9e74
    return strlen(s);
}

// Address range: 0x9e80 - 0x9e8c
int32_t fprintf2(struct _IO_FILE *stream, char *format, ...) {
    // 0x9e80
    return fprintf(stream, format);
}

// Address range: 0x9e8c - 0x9e98
int32_t fclose2(struct _IO_FILE *stream) {
    // 0x9e8c
    return fclose(stream);
}

// Address range: 0x9e98 - 0x9ea4
int32_t X509_get_issuer_name2(int32_t i_a1) {
    // 0x9e98
    return X509_get_issuer_name(i_a1);
}

// Address range: 0x9ea4 - 0x9eb0
int32_t SSL_set_fd2(void) {
    // 0x9ea4
    return SSL_set_fd();
}

// Address range: 0x9eb0 - 0x9ebc
int32_t sprintf2(char *s, char *format, ...) {
    // 0x9eb0
    return sprintf(s, format);
}

// Address range: 0x9ebc - 0x9ec8
int32_t ENGINE_cleanup2(int32_t i_a1) {
    // 0x9ebc
    return ENGINE_cleanup(i_a1);
}

// Address range: 0x9ec8 - 0x9ed4
int32_t SSL_shutdown2(int32_t i_a1) {
    // 0x9ec8
    return SSL_shutdown(i_a1);
}

// Address range: 0x9ed4 - 0x9ee0
int32_t pthread_create2(int32_t *newthread, int32_t *attr,
                        int32_t *(*start_routine)(int32_t *), int32_t *arg) {
    // 0x9ed4
    return pthread_create(newthread, attr, start_routine, arg);
}

// Address range: 0x9ee0 - 0x9eec
int32_t strcmp2(char *s1, char *s2) {
    // 0x9ee0
    return strcmp(s1, s2);
}

// Address range: 0x9eec - 0x9ef8
int32_t *__errno_location2(void) {
    // 0x9eec
    return __errno_location();
}

// Address range: 0x9ef8 - 0x9f04
int32_t send2(int32_t fd, int32_t *buf, int32_t n, int32_t flags) {
    // 0x9ef8
    return send(fd, buf, n, flags);
}

// Address range: 0x9f04 - 0x9f10
char *strncpy2(char *dest, char *src, int32_t n) {
    // 0x9f04
    return strncpy(dest, src, n);
}

// Address range: 0x9f10 - 0x9f1c
int32_t CONF_modules_free2(int32_t i_a1) {
    // 0x9f10
    return CONF_modules_free(i_a1);
}

// Address range: 0x9f1c - 0x9f28
int32_t sigemptyset2(struct _TYPEDEF_sigset_t *set) {
    // 0x9f1c
    return sigemptyset(set);
}

// Address range: 0x9f28 - 0x9f34
char *strrchr2(char *s, int32_t c) {
    // 0x9f28
    return strrchr(s, c);
}

// Address range: 0x9f34 - 0x9f40
int32_t **__ctype_tolower_loc2(void) {
    // 0x9f34
    return __ctype_tolower_loc();
}

// Address range: 0x9f40 - 0x9f4c
int32_t SSL_CTX_new2(int32_t i_a1) {
    // 0x9f40
    return SSL_CTX_new(i_a1);
}

// Address range: 0x9f4c - 0x9f58
int32_t fputs2(char *s, struct _IO_FILE *stream) {
    // 0x9f4c
    return fputs(s, stream);
}

// Address range: 0x9f58 - 0x9f64
int32_t __libc_start_main2(int32_t main, int32_t argc, char **ubp_av,
                           void (*init)(), void (*fini)(),
                           void (*rtld_fini)()) {
    // 0x9f58
    return __libc_start_main(main, argc, ubp_av, init, fini, rtld_fini);
}

// Address range: 0x9f64 - 0x9f70
void function_9f64(void) {
    // 0x9f64
    __gmon_start__();
}

// Address range: 0x9f70 - 0x9f7c
int32_t sigprocmask2(int32_t how, struct _TYPEDEF_sigset_t *set,
                     struct _TYPEDEF_sigset_t *oset) {
    // 0x9f70
    return sigprocmask(how, set, oset);
}

// Address range: 0x9f7c - 0x9f88
char *strchr2(char *s, int32_t c) {
    // 0x9f7c
    return strchr(s, c);
}

// Address range: 0x9f88 - 0x9f94
int32_t TLSv1_client_method2(int32_t i_a1) {
    // 0x9f88
    return TLSv1_client_method(i_a1);
}

// Address range: 0x9f94 - 0x9fa0
float64_t floor2(float64_t f_a1) {
    // 0x9f94
    return floor(f_a1);
}

// Address range: 0x9fa0 - 0xa234
int32_t function_9fa0(uint32_t i_a1) {
    // 0x9fa0
    int32_t i_v1; // 0x9fa0
    if (function_b088(i_a1, i_v1, i_v1, i_v1) == 0) {
        // 0xa1d4
        puts("process exist!");
        // 0xa188
        return 1;
    }
    if (i_a1 >= 2) {
        // 0x9fc4
        sleep(40);
    }
    // 0x9fcc
    function_afe8();
    function_e444(&i_g34, &i_g56);
    function_10d34(i_g60, (int32_t)&i_g56, i_v1, &i_g60);
    if (pthread_create(&i_g54, NULL, (int32_t * (*)(int32_t *)) & p_g116,
                       NULL) != 0) {
        // 0xa180
        puts("Create pthread error!");
        // 0xa188
        return 1;
    }
    // 0xa004
    sleep(1);
    if (i_g30 == 1) {
        // 0xa224
        puts("Web  Switch is OFF!");
        exit(1);
        return &i_g125;
    }
    // 0xa028
    if (function_aa14() == -1) {
        sleep(30);
        while (function_aa14() == -1) {
            // 0xa020
            sleep(30);
        }
    }
    // 0xa034
    int32_t i_v2; // 0x9fa0
    int32_t i_v3; // 0x9fa0
    if (function_a938() == -1) {
        // 0xa1f4
        i_g62 = &i_g4;
        i_g63 = &i_g5;
        puts("encrypt connect failed.");
        close(i_g85);
        function_aa14();
        i_v2 = &i_g5;
        i_v3 = &i_g85;
    } else {
        // 0xa044
        i_g62 = &i_g2;
        i_g63 = &i_g3;
        i_v2 = &i_g3;
        i_v3 = &i_g63;
    }
    // 0xa058
    function_ae1c(30, (int32_t)&i_g62, i_v2, i_v3);
    signal(SIGBUS, 0xad18);
    signal(SIGSYS, 0xad18);
    signal(SIGINT, 0xa3ec);
    signal(SIGTERM, 0xa3ec);
    int32_t i_v4 = pthread_create(
        &i_g81, NULL, (int32_t * (*)(int32_t *)) & p_g115, NULL); // 0xa0a4
    i_g31 = i_v4;
    if (i_v4 != 0) {
        // 0xa180
        puts("Create pthread error!");
        // 0xa188
        return 1;
    }
    int32_t i_v5 = pthread_create(
        &i_g46, NULL, (int32_t * (*)(int32_t *)) & p_g114, NULL); // 0xa0c4
    i_g31 = i_v5;
    if (i_v5 != 0) {
        // 0xa180
        puts("Create pthread error!");
        // 0xa188
        return 1;
    }
    // 0xa0ec
    if (*(char *)&p_g16 == 0) {
        // 0xa188
        return 1;
    }
    while (true) {
    lab_0xa0f8:
        // 0xa0f8
        if ((i_g36 + 1) % 20 == i_g35) {
            // 0xa198
            puts("the queue is full");
            sleep(5);
            goto lab_0xa0ec;
        } else {
            // 0xa11c
            if ((i_g58 + 1) % 20 == i_g57) {
                // 0xa198
                puts("the queue is full");
                sleep(5);
                goto lab_0xa0ec;
            } else {
                // 0xa140
                if (function_adb0() == -1) {
                    // 0xa1e0
                    puts("Bad Package REV!");
                    sleep(1);
                } else {
                    // 0xa14c
                    int32_t i_v6; // bp-4128, 0x9fa0
                    if (*(char *)&p_g75 == 102) {
                        // 0xa1ac
                        puts("this is respond ");
                        memcpy(&i_v6, &i_g79, 0x1003);
                        function_e598(&i_g56, (int32_t)p_g72, i_g76, i_g78);
                    } else {
                        // 0xa158
                        puts("this is command");
                        memcpy(&i_v6, &i_g79, 0x1003);
                        function_e598(&i_g34, (int32_t)p_g72, i_g76, i_g78);
                    }
                }
                goto lab_0xa0ec;
            }
        }
    }
    // 0xa188
    return 1;
lab_0xa0ec:
    // 0xa0ec
    if (*(char *)&p_g16 == 0) {
        return 1;
    }
    goto lab_0xa0f8;
}

// Address range: 0xa2ac - 0xa2dc
int32_t entry_point(int32_t i_a1, int32_t i_a2) {
    // 0xa2ac
    int32_t i_v1; // 0xa2ac
    __libc_start_main(0x9fa0, i_a2, (char **)&i_v1, (void (*)())0x10fe0,
                      (void (*)()) & p_g6, (void (*)())i_a1);
    abort();
    return &i_g125;
}

// Address range: 0xa2e8 - 0xa304
int32_t function_a2e8(void) {
    // 0xa2e8
    if (i_g15 == 0) {
        int32_t i_v1; // 0xa2e8
        return i_v1;
    }
    // 0xa300
    __gmon_start__();
    return &i_g125;
}

// Address range: 0xa30c - 0xa338
int32_t function_a30c(int32_t i_a1, int32_t i_a2, int32_t i_a3, char i_a4) {
    // 0xa30c
    return 0x1b384;
}

// Address range: 0xa344 - 0xa378
int32_t function_a344(int32_t *p_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0xa344
    return 0x1b384;
}

// Address range: 0xa384 - 0xa3a8
int32_t function_a384(void) {
    // 0xa384
    int32_t i_v1; // 0xa384
    if (*(char *)&p_g29 != 0) {
        return i_v1;
    }
    int32_t i_v2 = function_a30c(i_v1, i_v1, i_v1, 0); // 0xa398
    *(char *)&p_g29 = 1;
    return i_v2;
}

// Address range: 0xa3ac - 0xa3d8
int32_t function_a3ac(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0xa3ac
    return function_a344(&i_g14, i_a2, i_a3, i_a4);
}

// Address range: 0xa3e0 - 0xa3ec
int32_t function_a3e0(void) {
    // 0xa3e0
    return puts("send or recv: Broken pipe");
}

// Address range: 0xa3ec - 0xa4dc
int32_t function_a3ec(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0xa3ec
    puts("oops! stop by ctrl+c or "
         "kill!!!----------------------------------------");
    int32_t i_v1 = fileno(p_g45); // 0xa404
    int32_t i_v2 = flock(i_v1, LOCK_UN) == 0
                       ? (int32_t) "unlock fd_pid_conf succeed!"
                       : (int32_t) "unlock fd_pid_conf failed!";
    puts((char *)i_v2);
    fclose(p_g45);
    function_10f48(i_g60);
    *(char *)&p_g16 = 0;
    pthread_join(i_g54, NULL);
    pthread_join(i_g81, NULL);
    pthread_join(i_g46, NULL);
    SSL_shutdown(i_g108);
    SSL_free(i_g108);
    close(i_g85);
    CONF_modules_free(SSL_CTX_free(i_g105));
    ENGINE_cleanup(ERR_remove_state(0));
    int32_t i_v3 = CRYPTO_cleanup_all_ex_data(
        EVP_cleanup(ERR_free_strings(CONF_modules_unload(1)))); // 0xa4c8
    sk_free(SSL_COMP_get_compression_methods(i_v3));
    exit(0);
    return &i_g125;
}

// Address range: 0xa514 - 0xa650
int32_t function_a514(void) {
    // 0xa514
    int32_t i_v1; // 0xa514
    if (*(char *)&p_g16 == 0) {
    lab_0xa628:
        // 0xa628
        return i_v1;
    }
    int32_t i_v2; // bp-4128, 0xa514
    int32_t i_v3; // 0xa514
    int32_t i_v4; // 0xa59c
    int32_t i_v5; // 0xa5a8
    while (function_e7d8(&i_g56) != 0) {
        // 0xa550
        i_g59 = 0;
        if (function_e62c(&i_g56, &i_g37) == 0) {
            // 0xa634
            i_v3 = puts("respond queue  empty");
        } else {
            // 0xa56c
            function_e698(i_g56, i_g57, i_g58, 0xe75c);
            function_eb78();
            printf("response node:%s,%s----------\n", (char *)&p_g38,
                   (char *)&p_g44);
            i_v4 = function_10d90(&i_g37, i_g60, (int32_t)&p_g44, 0xe75c);
            if (i_v4 == 0) {
                // 0xa640
                puts("no cmd for responding!");
                exit(1);
                return &i_g125;
            }
            // 0xa5a8
            i_v5 = *(int32_t *)i_v4;
            if (*(char *)(i_v5 + 3) == 48) {
                // 0xa5b8
                if (*(char *)(i_v5 + 4) == 49) {
                    // 0xa5c4
                    if (*(char *)(i_v5 + 5) == 0) {
                        // 0xa5d0
                        function_fc80((int32_t)p_g17, (int32_t *)&p_g38, 49, 0);
                    }
                }
            }
            // 0xa5dc
            printf("Delete node:%s,%s----------\n", (char *)&p_g38,
                   (char *)&p_g44);
            function_10e24();
            memcpy(&i_v2, &i_g43, 4095);
            i_v3 = function_e7f4(i_g37, (int32_t)i_g39, i_g41, i_g42);
        }
        // 0xa614
        i_g18 = 0;
        i_v1 = i_v3;
        if (*(char *)&p_g16 == 0) {
            return i_v1;
        }
    }
    while (*(char *)&p_g16 != 0) {
        while (function_e7d8(&i_g56) != 0) {
            // 0xa550
            i_g59 = 0;
            if (function_e62c(&i_g56, &i_g37) == 0) {
                // 0xa634
                i_v3 = puts("respond queue  empty");
            } else {
                // 0xa56c
                function_e698(i_g56, i_g57, i_g58, 0xe75c);
                function_eb78();
                printf("response node:%s,%s----------\n", (char *)&p_g38,
                       (char *)&p_g44);
                i_v4 = function_10d90(&i_g37, i_g60, (int32_t)&p_g44, 0xe75c);
                if (i_v4 == 0) {
                    // 0xa640
                    puts("no cmd for responding!");
                    exit(1);
                    return &i_g125;
                }
                // 0xa5a8
                i_v5 = *(int32_t *)i_v4;
                if (*(char *)(i_v5 + 3) == 48) {
                    // 0xa5b8
                    if (*(char *)(i_v5 + 4) == 49) {
                        // 0xa5c4
                        if (*(char *)(i_v5 + 5) == 0) {
                            // 0xa5d0
                            function_fc80((int32_t)p_g17, (int32_t *)&p_g38, 49,
                                          0);
                        }
                    }
                }
                // 0xa5dc
                printf("Delete node:%s,%s----------\n", (char *)&p_g38,
                       (char *)&p_g44);
                function_10e24();
                memcpy(&i_v2, &i_g43, 4095);
                i_v3 = function_e7f4(i_g37, (int32_t)i_g39, i_g41, i_g42);
            }
            // 0xa614
            i_g18 = 0;
            i_v1 = i_v3;
            if (*(char *)&p_g16 == 0) {
                return i_v1;
            }
        }
    }
    // 0xa628
    return 0;
}

// Address range: 0xa680 - 0xa7b0
int32_t function_a680(void) {
    // 0xa680
    int32_t i_v1; // 0xa680
    if (*(char *)&p_g16 == 0) {
        // 0xa780
        return i_v1;
    }
    while (true) {
        puts("next command!");
        if (i_g30 == 1) {
            // break (via goto) -> 0xa7a0
            goto lab_0xa7a0;
        }
        int32_t i_v2; // 0xa680
        while (function_e62c(&i_g34, (int32_t *)&p_g65) != 0) {
            // 0xa6d4
            printf("get a command head:%s!\n", (char *)&p_g65);
            printf("get a command:%s!\n", (char *)&p_g66);
            function_e698(i_g34, i_g35, i_g36, 0xe75c);
            int32_t i_v3; // bp-4128, 0xa680
            memcpy(&i_v3, &i_g70, 4095);
            i_v2 = 0;
            if (function_f854((int32_t)p_g65, i_g67, i_g68, i_g69) == 0) {
                goto lab_0xa6a0;
            }
            // 0xa718
            puts("after deal_cmd()");
            printf("get a command nonce:%s!\n", (char *)&p_g71);
            i_g18 = 0;
            int32_t i_v4 = i_g60; // 0xa73c
            function_10ec0((int32_t *)&p_g65, i_v4, i_v4, &i_g60);
            printf("new node:%s,%s==========\n", (char *)&p_g66,
                   (char *)&p_g71);
            memcpy(&i_v3, &i_g70, 4095);
            i_v1 = function_e7f4((int32_t)p_g65, i_g67, i_g68, i_g69);
            if (*(char *)&p_g16 == 0) {
                // 0xa780
                return i_v1;
            }
            puts("next command!");
            if (i_g30 == 1) {
                // break (via goto) -> 0xa7a0
                goto lab_0xa7a0;
            }
        }
        // 0xa78c
        puts("queue empty1");
        i_v2 = sleep(1);
    lab_0xa6a0:
        // 0xa6a0
        i_v1 = i_v2;
        if (*(char *)&p_g16 == 0) {
            // 0xa780
            return i_v1;
        }
    }
lab_0xa7a0:
    // 0xa7a0
    puts("Web  Switch is OFF!");
    exit(1);
    return &i_g125;
}

// Address range: 0xa7f4 - 0xa88c
int32_t function_a7f4(void) {
    // 0xa7f4
    if (*(char *)&p_g16 == 0) {
        // 0xa878
        puts("will bi exited###################");
        return 0;
    }
    int32_t i_v1; // bp-32, 0xa7f4
    int32_t i_v2 = function_f990((int32_t)p_g17, "api-switch", &i_v1); // 0xa820
    if (*(char *)i_v2 == 111) {
        // 0xa83c
        if (*(char *)(i_v2 + 1) == 102) {
            // 0xa848
            if (*(char *)(i_v2 + 2) == 102) {
                // 0xa854
                if (*(char *)(i_v2 + 3) == 0) {
                    i_g30 = 1;
                }
            }
        }
    }
    // 0xa860
    printf("key_switch = %s\n", &i_v1);
    sleep(15);
    while (*(char *)&p_g16 != 0) {
        // 0xa814
        i_v2 = function_f990((int32_t)p_g17, "api-switch", &i_v1);
        if (*(char *)i_v2 == 111) {
            // 0xa83c
            if (*(char *)(i_v2 + 1) == 102) {
                // 0xa848
                if (*(char *)(i_v2 + 2) == 102) {
                    // 0xa854
                    if (*(char *)(i_v2 + 3) == 0) {
                        i_g30 = 1;
                    }
                }
            }
        }
        // 0xa860
        printf("key_switch = %s\n", &i_v1);
        sleep(15);
    }
    // 0xa878
    puts("will bi exited###################");
    return 0;
}

// Address range: 0xa8a0 - 0xa928
int32_t function_a8a0(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    int32_t i_v1 = SSL_get_peer_certificate(); // 0xa8a4
    if (i_v1 == 0) {
        // 0xa91c
        return puts((char *)&p_g7);
    }
    // 0xa8b0
    puts("A digital certificate information:");
    int32_t i_v2 = X509_NAME_oneline(X509_get_subject_name(i_v1)); // 0xa8c8
    printf("certificate: %s\n", (char *)i_v2);
    free((int32_t *)i_v2);
    int32_t i_v3 = X509_NAME_oneline(X509_get_issuer_name(i_v1)); // 0xa8f4
    printf("Issued by the: %s\n", (char *)i_v3);
    free((int32_t *)i_v3);
    return X509_free(i_v1);
}

// Address range: 0xa938 - 0xa9f8
int32_t function_a938(void) {
    int32_t i_v1 = SSL_CTX_new(TLSv1_client_method(SSL_load_error_strings(
        OPENSSL_add_all_algorithms_noconf(SSL_library_init())))); // 0xa94c
    i_g105 = i_v1;
    if (i_v1 == 0) {
        // 0xa9e4
        ERR_print_errors_fp(i_g28);
        exit(1);
        return &i_g125;
    }
    // 0xa960
    i_g108 = SSL_new();
    SSL_set_fd();
    if (SSL_connect(i_g108) == -1 ||
        strcmp("(NONE)", (char *)SSL_CIPHER_get_name(
                             SSL_get_current_cipher(i_g108))) == 0) {
        // 0xa9d0
        ERR_print_errors_fp(i_g27);
        return -1;
    }
    int32_t i_v2 =
        SSL_CIPHER_get_name(SSL_get_current_cipher(i_g108)); // 0xa9b0
    printf("Connected with %s encryption\n", (char *)i_v2);
    function_a8a0(i_g108, i_v2, (int32_t)&i_g105, (int32_t)&i_g85);
    return 1;
}

// Address range: 0xaa14 - 0xab4c
int32_t function_aa14(void) {
    // 0xaa14
    if (i_g30 == 1) {
        // 0xab1c
        puts("Web  Switch is OFF!");
        exit(1);
        // UNREACHABLE
    }
    // 0xaa2c
    int32_t i_v1; // bp-76, 0xaa14
    memset(&i_v1, 0, 60);
    function_fa50((int32_t)p_g17, "ip_server", &i_v1, (int32_t *)&p_g16);
    char *p_v2 = strchr((char *)&i_v1, 58); // 0xaa5c
    *p_v2 = 0;
    int32_t i_v3 = strtol((char *)((int32_t)p_v2 + 1), NULL, 10); // 0xaa6c
    if (gethostbyname((char *)&i_v1) == NULL) {
        // 0xab3c
        perror("gethostbyname");
        exit(1);
        return &i_g125;
    }
    int32_t i_v4 = socket(AF_INET, SOCK_STREAM, IPPROTO_IP); // 0xaa90
    i_g85 = i_v4;
    if (i_v4 == -1) {
        // 0xab2c
        perror("socket");
        exit(1);
        // UNREACHABLE
    }
    // 0xaaa4
    __asm_ubfx(i_v3, 8, 8);
    int32_t i_v5 = 2;                                           // bp-92, 0xaac4
    int32_t i_v6 = connect(i_v4, (struct sockaddr *)&i_v5, 16); // 0xaad8
    if (i_v6 == -1) {
        // 0xab08
        puts("connect failed");
        i_g26 = 0;
    } else {
        // 0xaae8
        i_g26 = 1;
        puts("server connected");
    }
    // 0xaafc
    return i_v6;
}

// Address range: 0xab74 - 0xaca4
int32_t function_ab74(void) {
    int32_t i_v1 = 104; // bp-124, 0xab94
    if (i_g30 == 1) {
        // 0xac94
        puts("Web  Switch is OFF!");
        exit(1);
        return &i_g125;
    }
    int32_t i_v2 = &i_v1; // bp-4224, 0xaba8
    int32_t i_v3;         // bp-120, 0xab74
    getsockopt(i_g85, SO_BROADCAST, 11, &i_v3, &i_v1);
    if (i_v3 % 256 == 1) {
        // 0xac44
        return puts("Connect to normal!!!");
    }
    // 0xabd4
    puts("Off Line!!! in tcp_state()");
    i_g26 = 0;
    memcpy(&i_v2, &i_g52, 4095);
    function_e7f4(i_g48, i_g49, i_g50, i_g51);
    memset(&i_g103, 0, 70);
    if (function_aa14() == -1) {
        // 0xac44
        return puts("tcp_state, sock_connect_server failed!");
    }
    // 0xac20
    int32_t i_v4; // 0xab74
    if (function_a938() == -1) {
        // 0xac5c
        i_g62 = &i_g4;
        i_g63 = &i_g5;
        close(i_g85);
        function_aa14();
        i_v4 = puts("encrypt connect failed.");
    } else {
        // 0xac30
        i_g62 = &i_g2;
        i_g63 = &i_g3;
        i_v4 = &i_g2;
    }
    // 0xac44
    return i_v4;
}

// Address range: 0xace4 - 0xad18
int32_t function_ace4(int32_t i_a1, int32_t i_a2) {
    int32_t i_v1 = i_a1; // bp-24, 0xacf0
    return setitimer(ITIMER_REAL, (struct itimerval *)&i_v1, NULL);
}

// Address range: 0xad18 - 0xad9c
int32_t function_ad18(int32_t i_a1) {
    int32_t i_v1 = printf("receive signal :%d\n", i_a1); // 0xad28
    switch (i_a1) {
    case 10: {
        // 0xad60
        function_ace4((int32_t)&i_g111 & 0xffff | 0x5b0000,
                      (int32_t)&i_g111 & 0xffff | 0x5b0000);
        i_g26 = 0;
        close(i_g85);
        function_e4cc(&i_g34);
        return function_e4cc(&i_g56);
    }
    case 12: {
        // 0xad3c
        function_e4cc(&i_g34);
        function_e4cc(&i_g56);
        function_ace4(30, 30);
        return function_ab74();
    }
    }
    return i_v1;
}

// Address range: 0xadb0 - 0xae14
int32_t function_adb0(void) {
    int32_t i_v1 = function_e8dc(); // 0xadb4
    if (i_v1 != 0) {
        // 0xadc0
        return i_v1 == -1 ? -1 : 1;
    }
    // 0xadd0
    puts("OFF LINE !!!!Please Wait!!! in recv_serpkg_struct() in client");
    while (true) {
        // 0xadec
        if (i_g26 == 0) {
            // 0xadf8
            sleep(30);
            if (function_e8dc() >= 1) {
                // break -> 0xae0c
                break;
            }
        } else {
            // 0xade0
            if (function_e8dc() > 0) {
                // break -> 0xae0c
                break;
            }
        }
    }
    // 0xae0c
    return 1;
}

// Address range: 0xae1c - 0xae50
int32_t function_ae1c(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0xae1c
    function_ace4(30, 30);
    signal(SIGALARM, (void (*)(int32_t))((int32_t)&p_g117 & 0xffff));
    return (int32_t)signal(SIGPIPE,
                           (void (*)(int32_t))((int32_t)&p_g113 & 0xffff));
}

// Address range: 0xae50 - 0xaf70
int32_t function_ae50(void) {
    // 0xae50
    if (*(char *)&p_g16 == 0) {
        // 0xaf18
        return (int32_t) "the queue is full";
    }
    while (true) {
    lab_0xae84:
        while ((i_g36 + 1) % 20 != i_g35) {
            // 0xaea8
            if ((i_g58 + 1) % 20 == i_g57) {
                // break -> 0xaf24
                break;
            }
            // 0xaecc
            if (function_adb0() == -1) {
                // 0xaf5c
                puts("Bad Package REV!");
                sleep(1);
                goto lab_0xae74;
            }
            // 0xaedc
            int32_t i_v1; // bp-4128, 0xae50
            if (*(char *)&p_g75 == 102) {
                // 0xaf34
                puts("this is respond ");
                memcpy(&i_v1, &i_g79, 0x1003);
                function_e598(&i_g56, (int32_t)p_g72, i_g76, i_g78);
                goto lab_0xae74;
            }
            // 0xaee8
            puts("this is command");
            memcpy(&i_v1, &i_g79, 0x1003);
            function_e598(&i_g34, (int32_t)p_g72, i_g76, i_g78);
            if (*(char *)&p_g16 == 0) {
                return (int32_t) "the queue is full";
            }
        }
        // 0xaf24
        puts("the queue is full");
        sleep(5);
        goto lab_0xae74;
    }
    // 0xaf18
    return (int32_t) "the queue is full";
lab_0xae74:
    // 0xae74
    if (*(char *)&p_g16 == 0) {
        return (int32_t) "the queue is full";
    }
    goto lab_0xae84;
}

// Address range: 0xaf94 - 0xaf98
int32_t function_af94(void) {
    // 0xaf94
    int32_t i_v1; // 0xaf94
    return i_v1;
}

// Address range: 0xaf98 - 0xafdc
int32_t function_af98(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0xaf98
    if (sem_init(&i_g53, 0, 0) != 0) {
        // 0xafcc
        perror("Semaphore initialization failed");
        exit(1);
        return &i_g125;
    }
    // 0xafb4
    if (sem_init(&i_g61, 0, 0) == 0) {
        // 0xafc8
        return 0;
    }
    // 0xafcc
    perror("Semaphore initialization failed");
    exit(1);
    return &i_g125;
}

// Address range: 0xafe1 - 0xafe2
int32_t function_afe1(void) {
    // 0xafe1
    int32_t i_v1; // 0xafe1
    return i_v1;
}

// Address range: 0xafe8 - 0xb020
int32_t function_afe8(void) {
    // 0xafe8
    int32_t i_v1; // bp-136, 0xafe8
    sigemptyset((struct _TYPEDEF_sigset_t *)&i_v1);
    sigfillset((struct _TYPEDEF_sigset_t *)&i_v1);
    sigdelset((struct _TYPEDEF_sigset_t *)&i_v1, SIGINT);
    return sigdelset((struct _TYPEDEF_sigset_t *)&i_v1, SIGPIPE);
}

// Address range: 0xb020 - 0xb084
int32_t function_b020(void) {
    int32_t i_v1 = fork(); // 0xb024
    if (i_v1 < 0) {
        // 0xb074
        exit(1);
        // UNREACHABLE
    }
    if (i_v1 != 0) {
        // 0xb07c
        exit(0);
        return &i_g125;
    }
    // 0xb034
    setsid();
    int32_t i_v2 = fork(); // 0xb038
    if (i_v2 > 0) {
        // 0xb07c
        exit(0);
        return &i_g125;
    }
    // 0xb044
    if (i_v2 != 0) {
        // 0xb074
        exit(1);
        // UNREACHABLE
    }
    int32_t i_v3 = 0;
    int32_t i_v4 = i_v3 + 1; // 0xb050
    close(i_v3);
    while (i_v4 != 256) {
        // 0xb04c
        i_v3 = i_v4;
        i_v4 = i_v3 + 1;
        close(i_v3);
    }
    // 0xb060
    chdir("/root/test");
    return umask(0);
}

// Address range: 0xb088 - 0xb1ec
int32_t function_b088(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    int32_t i_v1 = access((char *)*(int32_t *)&x_g19, F_OK); // 0xb098
    int32_t i_v2 = *(int32_t *)&x_g19;
    char *p_v3 = (char *)i_v2;
    if (i_v1 == 0) {
        struct _IO_FILE *p_v4 = fopen(p_v3, "w"); // 0xb120
        int32_t i_v5 = (int32_t)p_v4;             // 0xb120
        *(int32_t *)&p_g45 = i_v5;
        if (p_v4 == NULL) {
            // 0xb14c
            fclose((struct _IO_FILE *)i_v5);
            return 0;
        }
        // 0xb134
        if (flock(fileno(p_v4), LOCK_EX | LOCK_NB) != 0) {
            // 0xb14c
            fclose((struct _IO_FILE *)(int32_t)p_g45);
            return 0;
        }
        // 0xb1c8
        fprintf(p_g45, "The thread executing miner-monitor:%d", getpid());
        puts("exist,write and lock!");
        return 1;
    }
    int32_t i_v6 = strlen(p_v3);  // 0xb0b4
    int32_t *p_v7 = malloc(i_v6); // 0xb0bc
    memcpy(p_v7, (int32_t *)i_v2, i_v6 + 1);
    char *p_v8 = strchr((char *)((int32_t)p_v7 + 1), 47); // 0xb0e4
    if (p_v8 != NULL) {
        char *p_v9 = p_v8; // 0xb0e4
        *p_v9 = 0;
        if (access((char *)p_v7, F_OK) != 0) {
            // 0xb108
            mkdir((char *)p_v7, 511);
        }
        // 0xb0d8
        *p_v9 = 47;
        p_v9 = strchr((char *)((int32_t)p_v9 + 1), 47);
        while (p_v9 != NULL) {
            // 0xb0f8
            *p_v9 = 0;
            if (access((char *)p_v7, F_OK) != 0) {
                // 0xb108
                mkdir((char *)p_v7, 511);
            }
            // 0xb0d8
            *p_v9 = 47;
            p_v9 = strchr((char *)((int32_t)p_v9 + 1), 47);
        }
    }
    struct _IO_FILE *p_v10 = fopen((char *)*(int32_t *)&x_g19, "w"); // 0xb160
    *(int32_t *)&p_g45 = (int32_t)p_v10;
    if (p_v10 == NULL) {
        // 0xb19c
        return 1;
    }
    // 0xb174
    puts("created!");
    if (p_g45 == NULL || flock(fileno(p_g45), LOCK_EX) != 0) {
        // 0xb19c
        return 1;
    }
    // 0xb1a4
    fprintf(p_g45, "The thread executing miner-monitor:%d", getpid());
    puts("locked!");
    return 1;
}

// Address range: 0xb208 - 0xb250
int32_t function_b208(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    int32_t i_v1 = strlen((char *)i_a1); // 0xb214
    if (i_v1 == 0) {
        // 0xb24c
        return 0;
    }
    int32_t i_v2 = i_v1 + i_a1;               // 0xb220
    unsigned char i_v3 = *(char *)(i_v2 - 1); // 0xb224
    if ((int32_t)i_v3 != i_a2) {
        // 0xb24c
        return i_v1;
    }
    int32_t i_v4 = i_v1; // 0xb22c
    int32_t i_v5 = i_v2;
    int32_t i_v6 = i_v5 - 1; // 0xb238
    *(char *)i_v6 = 0;
    while (i_v4 != 1) {
        // 0xb240
        i_v4--;
        if (i_v3 != *(char *)(i_v5 - 2)) {
            // break -> 0xb24c
            break;
        }
        i_v5 = i_v6;
        i_v6 = i_v5 - 1;
        *(char *)i_v6 = 0;
    }
    // 0xb24c
    return 0;
}

// Address range: 0xb250 - 0xb340
int32_t function_b250(int32_t *p_a1, int32_t *p_a2, int32_t *p_a3) {
    if (p_a1 == NULL) {
        // 0xb2cc
        return -1;
    }
    int16_t **p_v1 = __ctype_b_loc(); // 0xb268
    int32_t i_v2 = (int32_t)p_a1;
    unsigned char i_v3 = *(char *)i_v2; // 0xb278
    int32_t i_v4 = i_v2 + 1;            // 0xb278
    while ((*(int16_t *)(2 * (int32_t)i_v3 + (int32_t)*p_v1) & 0x2000) != 0) {
        // 0xb274
        i_v2 = i_v4;
        i_v3 = *(char *)i_v2;
        i_v4 = i_v2 + 1;
    }
    if (i_v3 == 0) {
        // 0xb2cc
        return -1;
    }
    // 0xb294
    *p_a2 = i_v2;
    int32_t i_v5 = i_v4;
    char *p_v6 = (char *)i_v5;  // 0xb2bc
    unsigned char i_v7 = *p_v6; // 0xb2bc
    int32_t i_v8;               // 0xb250
    while (i_v7 != 0) {
        int16_t i_v9 =
            *(int16_t *)(2 * (int32_t)i_v7 + (int32_t)*p_v1); // 0xb2a4
        if (i_v7 == 61 || (i_v9 & 0x2000) != 0) {
            // 0xb2d4
            *p_v6 = 0;
            i_v8 = i_v5;
            goto lab_0xb2e0;
        }
        i_v5++;
        p_v6 = (char *)i_v5;
        i_v7 = *p_v6;
    }
    // 0xb2cc
    return -1;
lab_0xb2e0:;
    int32_t i_v10 = i_v8;
    int32_t i_v11 = i_v10 + 1;            // 0xb2e0
    unsigned char i_v12 = *(char *)i_v11; // 0xb2e0
    if (i_v12 == 0) {
        return -1;
    }
    int32_t i_v13 = i_v12; // 0xb2e0
    i_v8 = i_v11;
    if (!((i_v12 == 61 |
           (*(int16_t *)(2 * i_v13 + (int32_t)*p_v1) & 0x2000) != 0))) {
        if (i_v12 != 34) {
            return -1;
        }
        int32_t i_v14 = i_v10 + 2; // 0xb318
        *p_a3 = i_v14;
        char *p_v15 = strchr((char *)i_v14, i_v13); // 0xb320
        if (p_v15 == NULL) {
            return -1;
        }
        // 0xb32c
        *p_v15 = 0;
        return 0;
    }
    goto lab_0xb2e0;
}

// Address range: 0xb340 - 0xb468
int32_t function_b340(int32_t *p_a1, int32_t *p_a2, int32_t *p_a3,
                      int32_t *p_a4) {
    if (p_a1 == NULL) {
        // 0xb40c
        return -1;
    }
    int16_t **p_v1 = __ctype_b_loc(); // 0xb358
    int32_t i_v2 = (int32_t)*p_v1;    // 0xb360
    int32_t i_v3 = (int32_t)p_a1;
    char *p_v4 = (char *)i_v3;  // 0xb36c
    unsigned char i_v5 = *p_v4; // 0xb36c
    int32_t i_v6 = i_v3 + 1;    // 0xb37c
    while ((*(int16_t *)(2 * (int32_t)i_v5 + i_v2) & 0x2000) != 0) {
        // 0xb368
        i_v3 = i_v6;
        p_v4 = (char *)i_v3;
        i_v5 = *p_v4;
        i_v6 = i_v3 + 1;
    }
    if (i_v5 == 0 || strncmp(p_v4, "option", 6) != 0) {
        // 0xb40c
        return -1;
    }
    int32_t i_v7 = i_v3 + 6;                 // 0xb3a0
    int32_t i_v8 = (int32_t) * (char *)i_v7; // 0xb3a0
    int32_t i_v9 = i_v7;                     // 0xb3b4
    int32_t i_v10 = i_v8;                    // 0xb3b4
    if ((*(int16_t *)(2 * i_v8 + i_v2) & 0x2000) != 0) {
        int32_t i_v11 = i_v3 + 7;
        int32_t i_v12 = (int32_t) * (char *)i_v11; // 0xb3c0
        int32_t i_v13 = i_v11 + 1;                 // 0xb3d0
        i_v9 = i_v11;
        i_v10 = i_v12;
        while ((*(int16_t *)(2 * i_v12 + i_v2) & 0x2000) != 0) {
            // 0xb3bc
            i_v11 = i_v13;
            i_v12 = (int32_t) * (char *)i_v11;
            i_v13 = i_v11 + 1;
            i_v9 = i_v11;
            i_v10 = i_v12;
        }
    }
    // 0xb3d4
    if (i_v10 == 0) {
        // 0xb40c
        return -1;
    }
    // 0xb3dc
    *p_a2 = i_v9;
    int32_t i_v14 = i_v9;
    int32_t i_v15 = i_v14 + 1;
    char *p_v16 = (char *)i_v15;  // 0xb3fc
    unsigned char i_v17 = *p_v16; // 0xb3fc
    int32_t i_v18;                // 0xb340
    while (i_v17 != 0) {
        // 0xb3e8
        if ((*(int16_t *)(2 * (int32_t)i_v17 + (int32_t)*p_v1) & 0x2000) != 0) {
            // 0xb414
            *p_v16 = 0;
            i_v18 = i_v14 + 2;
            goto lab_0xb41c;
        }
        i_v14 = i_v15;
        i_v15 = i_v14 + 1;
        p_v16 = (char *)i_v15;
        i_v17 = *p_v16;
    }
    // 0xb40c
    return -1;
lab_0xb41c:;
    unsigned char i_v19 = *(char *)i_v18; // 0xb41c
    if (i_v19 == 0) {
        return -1;
    }
    int32_t i_v20 = i_v19;     // 0xb41c
    int32_t i_v21 = i_v18 + 1; // 0xb41c
    i_v18 = i_v21;
    if ((*(int16_t *)(2 * i_v20 + (int32_t)*p_v1) & 0x2000) == 0) {
        if (i_v19 != 39) {
            return -1;
        }
        // 0xb44c
        *p_a3 = i_v21;
        char *p_v22 = strchr((char *)i_v21, i_v20); // 0xb450
        if (p_v22 == NULL) {
            return -1;
        }
        // 0xb45c
        *p_v22 = 0;
        return 0;
    }
    goto lab_0xb41c;
}

// Address range: 0xb46c - 0xb6b0
int32_t function_b46c(int32_t i_a1) {
    char *p_v1 = (char *)i_a1;                // 0xb47c
    struct _IO_FILE *p_v2 = fopen(p_v1, "r"); // 0xb47c
    if (p_v2 == NULL) {
        // 0xb5c4
        printf("can't open '%s' as config file: %s\n", p_v1,
               strerror(*__errno_location()));
        // 0xb5e4
        fclose(p_v2);
        return i_g32;
    }
    // 0xb488
    int32_t i_v3; // bp-812, 0xb46c
    if (fgets((char *)&i_v3, 770, p_v2) == NULL) {
        // 0xb5e4
        fclose(p_v2);
        return i_g32;
    }
    int32_t i_v4 = &i_v3; // 0xb48c
    int32_t i_v5 = 0;     // 0xb4b0
    while (true) {
        // 0xb4ac
        i_v5++;
        int32_t i_v6 = strlen((char *)&i_v3); // 0xb4b4
        if (i_v6 >= 768 == (i_v6 != 768)) {
            // 0xb5b0
            printf("line too long, conf line skipped %s, line %d\n", p_v1,
                   i_v5);
        } else {
            if (i_v6 != 0) {
                int16_t *p_v7 = *__ctype_b_loc(); // 0xb4d4
                int32_t i_v8 = i_v6;
                int32_t i_v9 = i_v4;
                char *p_v10 = (char *)i_v9;   // 0xb4e8
                unsigned char i_v11 = *p_v10; // 0xb4e8
                while ((*(int16_t *)(2 * (int32_t)i_v11 + (int32_t)p_v7) &
                        0x2000) != 0) {
                    int32_t i_v12 = i_v9 + 1; // 0xb4e0
                    int32_t i_v13 = i_v8 - 1; // 0xb4e0
                    if (i_v8 == 1) {
                        goto lab_0xb494;
                    }
                    i_v8 = i_v13;
                    i_v9 = i_v12;
                    p_v10 = (char *)i_v9;
                    i_v11 = *p_v10;
                }
                if (i_v11 != 35) {
                    // 0xb50c
                    if (strncmp(p_v10, "config", 6) != 0) {
                        // 0xb524
                        memcpy(&i_v3, (int32_t *)i_v9, i_v8);
                        int32_t i_v14 = i_v4; // bp-824, 0xb548
                        int32_t i_v15;        // bp-40, 0xb46c
                        *(char *)((int32_t)&i_v15 - 772 + i_v8) = 0;
                        char *p_v16; // bp-816, 0xb46c
                        char *p_v17; // bp-820, 0xb46c
                        int32_t i_v18 =
                            function_b340(&i_v14, (int32_t *)&p_v17,
                                          (int32_t *)&p_v16, &i_v15); // 0xb554
                        if (i_v18 == 0) {
                            // 0xb560
                            if (i_g32 > 39) {
                                // 0xb614
                                printf("too many vars in  %s, line %d:%d\n",
                                       p_v1, i_v5, i_v14 - i_v4);
                            } else {
                                uint32_t i_v19 = strlen(p_v17); // 0xb574
                                if (i_v19 >= 128 == (i_v19 != 128)) {
                                    // 0xb694
                                    printf("var name to long %s, line %d:%d\n",
                                           p_v1, i_v5, i_v14 - i_v4);
                                } else {
                                    uint32_t i_v20 = strlen(p_v16); // 0xb588
                                    if (i_v20 == 512 || i_v20 < 512) {
                                        // 0xb630
                                        strncpy((char *)(129 * i_g32 +
                                                         (int32_t)&p_g83),
                                                p_v17, 129);
                                        function_b208((int32_t)p_v16, 47, 129,
                                                      (int32_t)&p_g83);
                                        strncpy((char *)(513 * i_g32 +
                                                         (int32_t)&p_g82),
                                                p_v16, 513);
                                        i_g32++;
                                    } else {
                                        // 0xb594
                                        printf("value to long %s, line %d:%d\n",
                                               p_v1, i_v5, i_v14 - i_v4);
                                    }
                                }
                            }
                        } else {
                            // 0xb5f8
                            printf("error parsing %s, line %d:%d\n", p_v1, i_v5,
                                   i_v14 - i_v4);
                        }
                    }
                }
            }
        }
    lab_0xb494:
        // 0xb494
        if (fgets((char *)&i_v3, 770, p_v2) == NULL) {
            // break -> 0xb5e4
            break;
        }
    }
    // 0xb5e4
    fclose(p_v2);
    return i_g32;
}

// Address range: 0xb6d4 - 0xb8fc
int32_t function_b6d4(int32_t i_a1) {
    char *p_v1 = (char *)i_a1;                // 0xb6e4
    struct _IO_FILE *p_v2 = fopen(p_v1, "r"); // 0xb6e4
    if (p_v2 == NULL) {
        // 0xb810
        printf("can't open '%s' as config file: %s\n", p_v1,
               strerror(*__errno_location()));
        // 0xb830
        fclose(p_v2);
        return i_g32;
    }
    // 0xb6f0
    int32_t i_v3; // bp-812, 0xb6d4
    if (fgets((char *)&i_v3, 770, p_v2) == NULL) {
        // 0xb830
        fclose(p_v2);
        return i_g32;
    }
    int32_t i_v4 = &i_v3; // 0xb6f4
    int32_t i_v5 = 0;     // 0xb718
    while (true) {
        // 0xb714
        i_v5++;
        int32_t i_v6 = strlen((char *)&i_v3); // 0xb71c
        if (i_v6 >= 768 == (i_v6 != 768)) {
            // 0xb7fc
            printf("line too long, conf line skipped %s, line %d\n", p_v1,
                   i_v5);
        } else {
            if (i_v6 != 0) {
                int16_t *p_v7 = *__ctype_b_loc(); // 0xb73c
                int32_t i_v8 = i_v6;
                int32_t i_v9 = i_v4;
                unsigned char i_v10 = *(char *)i_v9; // 0xb750
                while ((*(int16_t *)(2 * (int32_t)i_v10 + (int32_t)p_v7) &
                        0x2000) != 0) {
                    int32_t i_v11 = i_v9 + 1; // 0xb748
                    int32_t i_v12 = i_v8 - 1; // 0xb748
                    if (i_v8 == 1) {
                        goto lab_0xb6fc;
                    }
                    i_v8 = i_v12;
                    i_v9 = i_v11;
                    i_v10 = *(char *)i_v9;
                }
                if (i_v10 != 35) {
                    // 0xb774
                    memcpy(&i_v3, (int32_t *)i_v9, i_v8);
                    int32_t i_v13 = i_v4; // bp-824, 0xb794
                    int32_t i_v14;        // bp-40, 0xb6d4
                    *(char *)((int32_t)&i_v14 - 772 + i_v8) = 0;
                    char *p_v15; // bp-816, 0xb6d4
                    char *p_v16; // bp-820, 0xb6d4
                    int32_t i_v17 = function_b250(&i_v13, (int32_t *)&p_v16,
                                                  (int32_t *)&p_v15); // 0xb7a0
                    if (i_v17 == 0) {
                        // 0xb7ac
                        if (i_g32 > 39) {
                            // 0xb8c4
                            printf("too many vars in  %s, line %d:%d\n", p_v1,
                                   i_v5, i_v13 - i_v4);
                        } else {
                            uint32_t i_v18 = strlen(p_v16); // 0xb7c0
                            if (i_v18 >= 128 == (i_v18 != 128)) {
                                // 0xb8e0
                                printf("var name to long %s, line %d:%d\n",
                                       p_v1, i_v5, i_v13 - i_v4);
                            } else {
                                uint32_t i_v19 = strlen(p_v15); // 0xb7d4
                                if (i_v19 == 512 || i_v19 < 512) {
                                    // 0xb860
                                    strncpy(
                                        (char *)(129 * i_g32 + (int32_t)&p_g83),
                                        p_v16, 129);
                                    function_b208((int32_t)p_v15, 47, 129,
                                                  (int32_t)&p_g83);
                                    strncpy(
                                        (char *)(513 * i_g32 + (int32_t)&p_g82),
                                        p_v15, 513);
                                    i_g32++;
                                } else {
                                    // 0xb7e0
                                    printf("value to long %s, line %d:%d\n",
                                           p_v1, i_v5, i_v13 - i_v4);
                                }
                            }
                        }
                    } else {
                        // 0xb844
                        printf("error parsing %s, line %d:%d\n", p_v1, i_v5,
                               i_v13 - i_v4);
                    }
                }
            }
        }
    lab_0xb6fc:
        // 0xb6fc
        if (fgets((char *)&i_v3, 770, p_v2) == NULL) {
            // break -> 0xb830
            break;
        }
    }
    // 0xb830
    fclose(p_v2);
    return i_g32;
}

// Address range: 0xb91c - 0xb9b4
int32_t function_b91c(int32_t i_a1) {
    int32_t i_v1 = i_g32; // 0xb928
    char *p_v2 = (char *)i_a1;
    if (i_v1 < 1) {
        // 0xb988
        memset((int32_t *)&p_g83, 0, 0x1428);
        i_g32 = 0;
        printf("get %s failed\n", p_v2);
        return 0;
    }
    int32_t i_v3 = 0;
    while (strcasecmp((char *)(129 * i_v3 + (int32_t)&p_g83), p_v2) != 0) {
        int32_t i_v4 = i_v3 + 1; // 0xb940
        if (i_v4 == i_v1) {
            // 0xb988
            memset((int32_t *)&p_g83, 0, 0x1428);
            i_g32 = 0;
            printf("get %s failed\n", p_v2);
            return 0;
        }
        i_v3 = i_v4;
    }
    // 0xb964
    i_g32 = 0;
    memset((int32_t *)&p_g83, 0, 0x1428);
    return 513 * i_v3 + (int32_t)&p_g82;
}

// Address range: 0xb9c4 - 0xba1c
int32_t function_b9c4(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    int32_t i_v1 = printf("g_var_num == %d\n", i_g32); // 0xb9e0
    if (i_g32 < 1) {
        // 0xba18
        return i_v1;
    }
    int32_t i_v2 = 0;
    int32_t i_v3 = i_v2 + 1; // 0xba04
    int32_t i_v4 = printf("%s = %s\n", (char *)(129 * i_v2 + (int32_t)&p_g83),
                          (char *)(513 * i_v2 + (int32_t)&p_g82)); // 0xba08
    while (i_g32 > i_v3) {
        // 0xb9f0
        i_v2 = i_v3;
        i_v3 = i_v2 + 1;
        i_v4 = printf("%s = %s\n", (char *)(129 * i_v2 + (int32_t)&p_g83),
                      (char *)(513 * i_v2 + (int32_t)&p_g82));
    }
    // 0xba18
    return i_v4;
}

// Address range: 0xba30 - 0xba54
int32_t function_ba30(int32_t i_a1) {
    int32_t i_v1 = *(int32_t *)((int32_t)&i_g119 & (int32_t)&i_g121 |
                                (int32_t)&i_g1); // 0xba40
    function_b6d4(i_v1);
    return function_b91c(i_a1);
}

// Address range: 0xba54 - 0xba78
int32_t function_ba54(int32_t i_a1) {
    // 0xba54
    function_b46c(i_g55);
    return function_b91c(i_a1);
}

// Address range: 0xba78 - 0xba9c
int32_t function_ba78(char *p_a1) {
    int32_t i_v1 = *(int32_t *)((int32_t)&i_g118 & (int32_t)&i_g121 |
                                (int32_t)&i_g1); // 0xba88
    function_b46c(i_v1);
    return function_b91c((int32_t)p_a1);
}

// Address range: 0xba9c - 0xbc3c
int32_t function_ba9c(int32_t i_a1, int32_t *p_a2, int32_t *p_a3) {
    struct _IO_FILE *p_v1 = fopen((char *)i_a1, "rb+"); // 0xbab0
    if (p_v1 == NULL) {
        // 0xbc2c
        puts("open error0");
        // 0xbadc
        return 0;
    }
    // 0xbabc
    fseek(p_v1, 0, SEEK_END);
    int32_t i_v2 = ftell(p_v1); // 0xbacc
    if (i_v2 == 0) {
        // 0xbadc
        return 0;
    }
    // 0xbae8
    fseek(p_v1, 0, SEEK_SET);
    int32_t *p_v3 = malloc(i_v2 + 100); // 0xbafc
    fread(p_v3, 1, i_v2, p_v1);
    fclose(p_v1);
    int32_t i_v4 = function_d9d8((int32_t)p_v3); // 0xbb20
    int32_t i_v5 = function_d9fc(i_v4);          // 0xbb28
    int32_t i_v6 = 4 * i_v5;                     // 0xbb2c
    *p_a2 = (int32_t)malloc(i_v6);
    int32_t *p_v7 = malloc(i_v6); // 0xbb44
    int32_t i_v8;                 // 0xba9c
    char i_v9 = i_v5 > 0 ? 0 : i_v8;
    *p_a3 = (int32_t)p_v7;
    int32_t i_v10 = 0; // 0xbb5c
    if (i_v5 <= 0) {
        // 0xbc18
        function_d864(i_v4);
        free(p_v3);
        // 0xbadc
        return i_v5;
    }
    int32_t i_v11 =
        strlen((char *)*(int32_t *)(function_da28(i_v4, i_v10) + 32)); // 0xbb70
    int32_t i_v12 =
        strlen((char *)*(int32_t *)(function_da28(i_v4, i_v10) + 16)); // 0xbb88
    int32_t *p_v13 = malloc(i_v11 + 1);                                // 0xbb98
    int32_t *p_v14 = (int32_t *)(5 * i_v10);                           // 0xbb9c
    *p_v14 = (int32_t)p_v13;
    int32_t *p_v15 = malloc(i_v12 + 1); // 0xbba8
    int32_t i_v16 = 4 * i_v10;          // 0xbbb0
    *(int32_t *)(i_v16 + i_v2) = (int32_t)p_v15;
    int32_t i_v17 = *(int32_t *)(function_da28(i_v4, i_v10) + 32); // 0xbbc4
    strcpy((char *)*p_v14, (char *)i_v17);
    int32_t i_v18 = *(int32_t *)(function_da28(i_v4, i_v10) + 16); // 0xbbe4
    strcpy((char *)*p_v14, (char *)i_v18);
    int32_t i_v19 = *(int32_t *)(i_v18 + i_v16); // 0xbbf8
    *(char *)(i_v19 + i_v11) = i_v9;
    int32_t i_v20 = *(int32_t *)(i_v19 + i_v16); // 0xbc04
    i_v10++;
    *(char *)(i_v20 + i_v12) = i_v9;
    while (i_v10 != i_v5) {
        // 0xbb60
        i_v11 = strlen((char *)*(int32_t *)(function_da28(i_v4, i_v10) + 32));
        i_v12 = strlen((char *)*(int32_t *)(function_da28(i_v4, i_v10) + 16));
        p_v13 = malloc(i_v11 + 1);
        p_v14 = (int32_t *)(5 * i_v10);
        *p_v14 = (int32_t)p_v13;
        p_v15 = malloc(i_v12 + 1);
        i_v16 = 4 * i_v10;
        *(int32_t *)(i_v16 + i_v20) = (int32_t)p_v15;
        i_v17 = *(int32_t *)(function_da28(i_v4, i_v10) + 32);
        strcpy((char *)*p_v14, (char *)i_v17);
        i_v18 = *(int32_t *)(function_da28(i_v4, i_v10) + 16);
        strcpy((char *)*p_v14, (char *)i_v18);
        i_v19 = *(int32_t *)(i_v18 + i_v16);
        *(char *)(i_v19 + i_v11) = i_v9;
        i_v20 = *(int32_t *)(i_v19 + i_v16);
        i_v10++;
        *(char *)(i_v20 + i_v12) = i_v9;
    }
    // 0xbc18
    function_d864(i_v4);
    free(p_v3);
    // 0xbadc
    return i_v5;
}

// Address range: 0xbc44 - 0xbe98
int32_t function_bc44(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    int32_t i_v1 = 0;                                 // bp-148, 0xbc60
    int32_t i_v2 = 0;                                 // bp-144, 0xbc64
    int32_t i_v3 = function_ba9c(i_a1, &i_v1, &i_v2); // 0xbc68
    printf("sum = %d\n", i_v3);
    int32_t i_v4; // bp-140, 0xbc44
    memset(&i_v4, 0, 100);
    char *p_v5 = (char *)i_a3;      // 0xbc94
    char *p_v6 = strchr(p_v5, 124); // 0xbc94
    int32_t i_v7 = (int32_t)p_v6;   // 0xbc94
    int32_t i_v8 = i_v7;            // 0xbca4
    if (p_v6 != NULL) {
        *p_v6 = 0;
        i_v8 = i_v7 + 1;
    }
    char *p_v9 = strrchr(p_v5, 124); // 0xbca8
    if (p_v9 != NULL) {
        *p_v9 = 0;
    }
    int32_t i_v10; // 0xbc44
    int32_t i_v11; // 0xbc44
    int32_t i_v12; // 0xbc44
    int32_t i_v13; // bp-152, 0xbc44
    char *p_v14;   // 0xbc44
    char *p_v15;   // 0xbcd8
    if (i_v8 != 0) {
        // 0xbcc0
        if (*(char *)i_v8 != 0) {
            // 0xbcd0
            p_v14 = (char *)i_a2;
            i_v10 = i_v8;
            while (true) {
            lab_0xbcd0:
                // 0xbcd0
                p_v15 = (char *)i_v10;
                char *p_v16 = strchr(p_v15, 44);  // 0xbcd8
                char *p_v17 = strchr(p_v15, 124); // 0xbce8
                if (p_v16 >= (char *)1 == p_v17 >= p_v16) {
                    // 0xbe6c
                    strncpy((char *)&i_v13, p_v16, 1);
                    i_v11 = (int32_t)p_v16;
                    goto lab_0xbd20;
                } else {
                    int32_t i_v18 = (int32_t)p_v17; // 0xbce8
                    strncpy((char *)&i_v13, p_v17, 1);
                    i_v11 = i_v18;
                    i_v12 = i_v18;
                    if (p_v17 == NULL) {
                        goto lab_0xbd24;
                    } else {
                        goto lab_0xbd20;
                    }
                }
            }
        }
    }
lab_0xbdac_4:;
    char *p_v19 = (char *)i_a2;                       // 0xbdb0
    char *p_v20 = (char *)(i_a2 - 1 + strlen(p_v19)); // 0xbdbc
    switch (*p_v20) {
    case 124: {
    }
    case 44: {
        *p_v20 = 0;
        // break ->
        break;
    }
    }
    int32_t i_v21 = 0; // 0xbddc
    if (i_v3 > 0) {
        int32_t i_v22 = 4 * i_v21;                  // 0xbde4
        int32_t i_v23 = *(int32_t *)(i_v1 + i_v22); // 0xbde8
        if (i_v23 != 0) {
            // 0xbdf8
            free((int32_t *)i_v23);
        }
        int32_t i_v24 = *(int32_t *)(i_v2 + i_v22); // 0xbe00
        if (i_v24 != 0) {
            // 0xbe0c
            free((int32_t *)i_v24);
        }
        int32_t i_v25 = i_v21 + 1; // 0xbdec
        i_v21 = i_v25;
        while (i_v25 != i_v3) {
            // 0xbde0
            i_v22 = 4 * i_v21;
            i_v23 = *(int32_t *)(i_v1 + i_v22);
            if (i_v23 != 0) {
                // 0xbdf8
                free((int32_t *)i_v23);
            }
            // 0xbdfc
            i_v24 = *(int32_t *)(i_v2 + i_v22);
            if (i_v24 != 0) {
                // 0xbe0c
                free((int32_t *)i_v24);
            }
            // 0xbe10
            i_v25 = i_v21 + 1;
            i_v21 = i_v25;
        }
    }
    // 0xbe18
    if (i_v1 != 0) {
        // 0xbe24
        free((int32_t *)i_v1);
    }
    // 0xbe28
    if (i_v2 != 0) {
        // 0xbe34
        free((int32_t *)i_v2);
    }
    // 0xbe38
    printf("after format :%s\n\n", p_v19);
    return i_a2;
lab_0xbd20:
    // 0xbd20
    *(char *)i_v11 = 0;
    i_v12 = i_v11 + 1;
    goto lab_0xbd24;
lab_0xbd24:;
    int32_t i_v26 = i_v12;
    char *p_v27 = strchr(p_v15, 61); // 0xbd2c
    int32_t i_v28 = (int32_t)p_v27;  // 0xbd2c
    int32_t i_v29 = i_v28;           // 0xbd34
    if (p_v27 != NULL) {
        *p_v27 = 0;
        i_v29 = i_v28 + 1;
    }
    char *p_v30; // 0xbc44
    if (i_v3 < 1) {
    lab_0xbe50:
        if (i_v26 == 0) {
            // break -> 0xbdac
            goto lab_0xbdac_4;
        }
        // 0xbe50
        p_v30 = (char *)i_v26;
    } else {
        int32_t i_v31 = i_v29;
        int32_t i_v32 = 0; // 0xbd4c
        int32_t i_v33 = 0;
        while (strcmp((char *)*(int32_t *)(i_v33 + i_v1), p_v15) != 0) {
            // 0xbd50
            i_v32++;
            int32_t i_v34 = i_v33 + 4; // 0xbd58
            if (i_v32 == i_v3) {
                goto lab_0xbe50;
            }
            i_v33 = i_v34;
        }
        int32_t i_v35 = *(int32_t *)(i_v2 + i_v33); // 0xbd84
        sprintf((char *)&i_v4, "%s=%s", (char *)i_v35, (char *)i_v31);
        strcat(p_v14, (char *)&i_v4);
        if (i_v26 == 0) {
            // break -> 0xbdac
            goto lab_0xbdac_4;
        }
        char *p_v36 = (char *)i_v26;
        if (*p_v36 == 0) {
            // break -> 0xbdac
            goto lab_0xbdac_4;
        }
        // 0xbe80
        strncat(p_v14, (char *)&i_v13, 1);
        p_v30 = p_v36;
    }
    // 0xbe5c
    i_v10 = i_v26;
    if (*p_v30 == 0) {
        // break -> 0xbdac
        goto lab_0xbdac_4;
    }
    goto lab_0xbcd0;
}

// Address range: 0xbea4 - 0xc0f4
int32_t function_bea4(int32_t i_a1, int32_t *p_a2, int32_t i_a3) {
    int32_t *p_v1 = malloc(0xffdd); // 0xbebc
    if (p_v1 == NULL) {
        // 0xc0e0
        __assert_fail("buf", "cgminer_api.c", 139, "callapi");
        return &i_g125;
    }
    // 0xbec8
    if (gethostbyname((char *)p_a2) == NULL) {
        // 0xc0cc
        printf("Failed to resolve host %s\n", p_a2);
        // 0xc06c
        return 0;
    }
    int32_t i_v2 = socket(AF_INET, SOCK_STREAM, IPPROTO_IP); // 0xbee4
    if (i_v2 == -1) {
        // 0xc0ac
        printf("Socket initialisation failed: %s\n",
               strerror(*__errno_location()));
        // 0xc06c
        return 0;
    }
    // 0xbef4
    __asm_ubfx(i_a3, 8, 8);
    int32_t i_v3 = 2; // bp-48, 0xbf1c
    if (connect(i_v2, (struct sockaddr *)&i_v3, 16) < 0) {
        // 0xbf68
        puts("Call API error.Disconnect with server!");
        raise(10);
        puts("Call API Failed wait 5s !!");
        sleep(5);
        while (connect(i_v2, (struct sockaddr *)&i_v3, 16) < 0) {
            // 0xbf34
            puts("Call API Failed wait 5s !!");
            sleep(5);
        }
        // 0xc078
        close(i_v2);
        raise(12);
        // 0xc06c
        return &i_g8;
    }
    int32_t i_v4 = (int32_t)p_v1; // 0xbebc
    char *p_v5 = (char *)i_a1;    // 0xbf88
    int32_t i_v6 = strlen(p_v5);  // 0xbf88
    int32_t i_v7 = i_v4;          // 0xbfa4
    int32_t i_v8;                 // 0xbea4
    if (send(i_v2, (int32_t *)i_a1, i_v6, 0) < 0) {
        goto lab_0xc03c;
    } else {
        // 0xbfa8
        puts("Send succed");
        *(char *)p_v1 = 0;
        int32_t i_v9 = 0;       // 0xbfbc
        int32_t i_v10 = i_v4;   // 0xbfbc
        int32_t i_v11 = 0xffdc; // 0xbfbc
        int32_t i_v12;          // 0xbea4
        while (true) {
            // 0xbfc0
            i_v12 = i_v10;
            puts("begin to Recv");
            int32_t i_v13 =
                recv(i_v2, (int32_t *)(i_v9 + i_v12), 0xffdc, 0); // 0xbfd8
            printf("Recved n: %d\n", i_v13);
            if (i_v13 < 0) {
                // break (via goto) -> 0xc090
                goto lab_0xc090;
            }
            // 0xbff4
            i_v8 = i_v12;
            if (i_v13 == 0) {
                goto lab_0xc054;
            }
            int32_t i_v14 = i_v13 + i_v9; // 0xbff8
            *(char *)(i_v14 + i_v12) = 0;
            int32_t i_v15 = i_v14; // 0xc00c
            while (i_v11 >= i_v14 + 0xffdc) {
                // 0xbfc0
                puts("begin to Recv");
                i_v13 = recv(i_v2, (int32_t *)(i_v15 + i_v12), 0xffdc, 0);
                printf("Recved n: %d\n", i_v13);
                if (i_v13 < 0) {
                    // break (via goto) -> 0xc090
                    goto lab_0xc090;
                }
                // 0xbff4
                i_v8 = i_v12;
                if (i_v13 == 0) {
                    goto lab_0xc054;
                }
                // 0xbff8
                i_v14 = i_v13 + i_v15;
                *(char *)(i_v14 + i_v12) = 0;
                i_v15 = i_v14;
            }
            // 0xc010
            i_v11 *= 2;
            int32_t *p_v16 = realloc((int32_t *)i_v12, i_v11); // 0xc01c
            i_v7 = (int32_t)p_v16;
            i_v9 = i_v14;
            i_v10 = i_v7;
            if (p_v16 == NULL) {
                // 0xc028
                __assert_fail("buf", "cgminer_api.c", 187, "callapi");
                goto lab_0xc03c;
            }
        }
    lab_0xc090:
        // 0xc090
        printf("Recv failed: %s\n", strerror(*__errno_location()));
        i_v8 = i_v12;
        goto lab_0xc054;
    }
lab_0xc054:
    // 0xc054
    close(i_v2);
    printf("the result of callapi about %s: %s\n\n", p_v5, (char *)i_v8);
    // 0xc06c
    return i_v8;
lab_0xc03c:
    // 0xc03c
    printf("Send failed: %s\n", strerror(*__errno_location()));
    i_v8 = i_v7;
    goto lab_0xc054;
}

// Address range: 0xc130 - 0xc244
int32_t function_c130(uint32_t i_a1) {
    uint32_t i_v1 = i_a1 % 256; // 0xc134
    unsigned char i_v2 = (char)i_a1 - 48;
    bool i_v3 = i_v2 == 9 | i_v2 < 9; // 0xc144
    int32_t i_v4 = i_v1 - 48;
    int32_t i_v5 = i_v4; // 0xc148
    if (!i_v3) {
        int32_t i_v6 = i_v3 ? i_v4 : i_v1;
        uint32_t i_v7 = i_v6 - 65;        // 0xc14c
        bool i_v8 = i_v7 == 5 | i_v7 < 5; // 0xc154
        int32_t i_v9 = i_v6 - 55;
        i_v5 = i_v9;
        if (!i_v8) {
            int32_t i_v10 = i_v8 ? i_v9 : i_v6;
            uint32_t i_v11 = i_v10 - 97; // 0xc15c
            if (i_v11 >= 5 == (i_v11 != 5)) {
                // 0xc210
                return 0;
            }
            // 0xc168
            i_v5 = i_v10 - 87;
        }
    }
    unsigned char i_v12 = *(char *)(i_a1 + 1); // 0xc16c
    int32_t i_v13 = i_v12;                     // 0xc16c
    int32_t i_v14 = 16 * i_v5;                 // 0xc170
    unsigned char i_v15 = i_v12 - 48;
    bool i_v16 = i_v15 == 9 | i_v15 < 9; // 0xc180
    int32_t i_v17 = i_v14 - 48 + i_v13;
    int32_t i_v18 = i_v17; // 0xc184
    if (!i_v16) {
        int32_t i_v19 = i_v16 ? i_v17 : i_v14;
        uint32_t i_v20 = i_v13 - 65;         // 0xc188
        bool i_v21 = i_v20 == 5 | i_v20 < 5; // 0xc190
        int32_t i_v22 = i_v21 ? i_v13 - 55 : i_v13;
        int32_t i_v23 = i_v22 + i_v19;
        i_v18 = i_v23;
        if (!i_v21) {
            uint32_t i_v24 = i_v22 - 97; // 0xc19c
            if (i_v24 >= 5 == (i_v24 != 5)) {
                // 0xc210
                return 0;
            }
            // 0xc1a8
            i_v18 = i_v22 - 87 + (i_v21 ? i_v23 : i_v19);
        }
    }
    unsigned char i_v25 = *(char *)(i_a1 + 2); // 0xc1b0
    int32_t i_v26 = i_v25;                     // 0xc1b0
    unsigned char i_v27 = i_v25 - 48;
    int32_t i_v28 = i_v26 - 48; // 0xc1c4
    if (i_v27 >= 9 == (i_v27 != 9)) {
        uint32_t i_v29 = i_v26 - 65; // 0xc218
        i_v28 = i_v26 - 55;
        if (i_v29 != 5 && i_v29 >= 5) {
            uint32_t i_v30 = i_v26 - 97; // 0xc22c
            i_v28 = i_v26 - 87;
            if (i_v30 != 5 && i_v30 >= 5) {
                // 0xc210
                return 0;
            }
        }
    }
    unsigned char i_v31 = *(char *)(i_a1 + 3); // 0xc1cc
    int32_t i_v32 = i_v31;                     // 0xc1cc
    int32_t i_v33 = 16 * (i_v28 + 16 * i_v18); // 0xc1d0
    unsigned char i_v34 = i_v31 - 48;
    if (i_v34 == 9 || i_v34 < 9) {
        // 0xc210
        return i_v33 - 48 + i_v32;
    }
    uint32_t i_v35 = i_v32 - 65;         // 0xc1e8
    bool i_v36 = i_v35 == 5 | i_v35 < 5; // 0xc1f0
    int32_t i_v37 = i_v36 ? i_v32 - 55 : i_v32;
    if (i_v36) {
        // 0xc210
        return i_v37 + i_v33;
    }
    uint32_t i_v38 = i_v37 - 97; // 0xc1fc
    if (i_v38 >= 5 != i_v38 != 5) {
        // 0xc210
        return i_v38 == 5 | i_v38 < 5 ? i_v37 + i_v33 - 87 : i_a1;
    }
    // 0xc210
    return 0;
}

// Address range: 0xc244 - 0xc538
int32_t function_c244(int32_t i_a1, int32_t i_a2) {
    int32_t i_v1 = i_a2 + 1; // 0xc248
    int32_t i_v2 = 0;        // 0xc268
    int32_t i_v3 = i_v1;     // 0xc268
    if ((char)i_a2 != 34) {
        // 0xc450
        i_g33 = i_a2;
        // 0xc37c
        return 0;
    }
    int32_t i_v4;        // 0xc244
    int32_t i_v5;        // 0xc244
    int32_t i_v6;        // 0xc244
    int32_t i_v7;        // 0xc244
    int32_t i_v8;        // 0xc244
    int32_t i_v9;        // 0xc244
    int32_t i_v10;       // 0xc244
    int32_t i_v11;       // 0xc244
    int32_t i_v12;       // 0xc244
    int32_t i_v13;       // 0xc244
    char i_v14;          // 0xc244
    char i_v15;          // 0xc244
    char i_v16;          // 0xc244
    char i_v17;          // 0xc244
    int32_t i_v18;       // 0xc244
    uint32_t i_v19;      // 0xc244
    char i_v20;          // 0xc244
    char i_v21;          // 0xc244
    char i_v22;          // 0xc244
    char i_v23;          // 0xc244
    char i_v24;          // 0xc244
    char i_v25;          // 0xc244
    int32_t i_v26;       // 0xc244
    int32_t i_v27;       // 0xc244
    int32_t i_v28;       // 0xc244
    int32_t i_v29;       // 0xc2f8
    unsigned char i_v30; // 0xc2f8
    int32_t i_v31;       // 0xc390
    int32_t i_v32;       // 0xc394
    uint32_t i_v33;      // 0xc39c
    uint32_t i_v34;      // 0xc3b0
    char i_v35;          // 0xc3bc
    char i_v36;          // 0xc4d8
    int32_t i_v37;       // 0xc3dc
    int32_t i_v38;       // 0xc3e0
    uint32_t i_v39;      // 0xc3e8
    int32_t i_v40;       // 0xc468
    int32_t i_v41;       // 0xc46c
    int32_t *p_v42;      // 0xc2ac
    int32_t i_v43;       // 0xc2ac
    int32_t i_v44;       // 0xc244
    while (true) {
        char i_v45 = *(char *)i_v3; // 0xc26c
        int32_t i_v46 = i_v2;       // 0xc244
        int32_t i_v47 = i_v3;       // 0xc28c
        char i_v48 = i_v45;         // 0xc290
        i_v8 = i_v2;
        switch (i_v45) {
        case 34: {
        }
        case 0: {
        lab_0xc2a0:
            // 0xc2a0
            p_v42 = malloc(i_v8 + 1);
            i_v43 = (int32_t)p_v42;
            if (p_v42 == NULL) {
                // 0xc37c
                return i_v43;
            }
            // 0xc2b8
            i_v15 = *(char *)i_v1;
            i_v27 = i_v1;
            i_v5 = i_v43;
            while (true) {
            lab_0xc2d0_2:
                // 0xc2d0
                i_v6 = i_v5;
                i_v28 = i_v27;
                i_v16 = i_v15;
                switch (i_v16) {
                case 34: {
                    goto lab_0xc360;
                }
                case 0: {
                    goto lab_0xc360;
                }
                case 92: {
                    // 0xc2f8
                    i_v29 = i_v28 + 1;
                    i_v30 = *(char *)i_v29;
                    i_g122 = (int32_t)i_v30 - 98;
                    switch (i_v30) {
                    case 98: {
                        // 0xc434
                        *(char *)i_v6 = 8;
                        i_v12 = i_v29;
                        i_v17 = *(char *)(i_v28 + 2);
                        i_v7 = i_v6 + 1;
                        goto lab_0xc404;
                    }
                    case 117: {
                        // 0xc388
                        i_v31 = function_c130(i_v28 + 2);
                        i_v32 = i_v28 + 5;
                        if (i_v31 == 0) {
                            goto lab_0xc460;
                        } else {
                            i_v33 = i_v31 - 0xdc00;
                            if (i_v33 == 1023 || i_v33 < 1023) {
                                goto lab_0xc460;
                            } else {
                                // 0xc3b0
                                i_v34 = i_v31 - (int32_t)&i_g120;
                                i_v13 = i_v32;
                                i_v18 = i_v31;
                                if (i_v34 >= 1023 == (i_v34 != 1023)) {
                                    goto lab_0xc478;
                                } else {
                                    // 0xc3bc
                                    i_v35 = *(char *)(i_v28 + 6);
                                    i_v12 = i_v32;
                                    i_v17 = i_v35;
                                    i_v7 = i_v6;
                                    if (i_v35 == 92) {
                                        // 0xc3c8
                                        i_v12 = i_v32;
                                        i_v17 = 92;
                                        i_v7 = i_v6;
                                        if (*(char *)(i_v28 + 7) == 117) {
                                            // 0xc3d4
                                            i_v37 = function_c130(i_v28 + 8);
                                            i_v38 = i_v28 + 11;
                                            i_v39 = i_v37 - 0xdc00;
                                            if (i_v39 == 1023 || i_v39 < 1023) {
                                                // 0xc468
                                                i_v40 =
                                                    __asm_ubfx(i_v31, 0, 10);
                                                i_v41 =
                                                    __asm_ubfx(i_v37, 0, 10);
                                                i_v13 = i_v38;
                                                i_v18 = (i_v41 | 1024 * i_v40) +
                                                        (int32_t)&i_g1;
                                                goto lab_0xc478;
                                            } else {
                                                // 0xc3f4
                                                i_v12 = i_v38;
                                                i_v17 = *(char *)(i_v28 + 12);
                                                i_v7 = i_v6;
                                                goto lab_0xc404;
                                            }
                                        } else {
                                            goto lab_0xc404;
                                        }
                                    } else {
                                        goto lab_0xc404;
                                    }
                                }
                            }
                        }
                    }
                    case 116: {
                        // 0xc3fc
                        *(char *)i_v6 = 9;
                        i_v12 = i_v29;
                        i_v17 = *(char *)(i_v28 + 2);
                        i_v7 = i_v6 + 1;
                        goto lab_0xc404;
                    }
                    case 114: {
                        // 0xc40c
                        *(char *)i_v6 = 13;
                        i_v12 = i_v29;
                        i_v17 = *(char *)(i_v28 + 2);
                        i_v7 = i_v6 + 1;
                        goto lab_0xc404;
                    }
                    case 102: {
                        // 0xc428
                        *(char *)i_v6 = 12;
                        i_v12 = i_v29;
                        i_v17 = *(char *)(i_v28 + 2);
                        i_v7 = i_v6 + 1;
                        goto lab_0xc404;
                    }
                    case 110: {
                        // 0xc418
                        *(char *)i_v6 = 10;
                        i_v12 = i_v29;
                        i_v17 = *(char *)(i_v28 + 2);
                        i_v7 = i_v6 + 1;
                        goto lab_0xc404;
                    }
                    default: {
                        // 0xc444
                        *(char *)i_v6 = i_v30;
                        i_v12 = i_v29;
                        i_v17 = *(char *)(i_v28 + 2);
                        i_v7 = i_v6 + 1;
                        goto lab_0xc404;
                    }
                    }
                }
                default: {
                    *(char *)i_v6 = i_v16;
                    i_v44 = i_v28 + 1;
                    i_v26 = i_v44;
                    i_v14 = *(char *)i_v44;
                    i_v4 = i_v6 + 1;
                    goto lab_0xc2d0;
                }
                }
            }
        lab_0xc360:
            // 0xc360
            *(char *)i_v6 = 0;
            *(int32_t *)(i_a1 + 16) = i_v43;
            *(int32_t *)(i_a1 + 12) = 4;
            // 0xc37c
            return i_v28 + (int32_t)(*(char *)i_v28 == 34);
        lab_0xc2d0:
            // 0xc2d0
            i_v15 = i_v14;
            i_v27 = i_v26;
            i_v5 = i_v4;
            goto lab_0xc2d0_2;
        lab_0xc404:
            // 0xc404
            i_v26 = i_v12 + 1;
            i_v14 = i_v17;
            i_v4 = i_v7;
            goto lab_0xc2d0;
        lab_0xc460:
            // 0xc460
            i_v12 = i_v32;
            i_v17 = *(char *)(i_v28 + 6);
            i_v7 = i_v6;
            goto lab_0xc404;
        lab_0xc478:
            // 0xc478
            i_v19 = i_v18;
            if (i_v19 == 127 || i_v19 < 127) {
                // 0xc4f0
                i_v11 = 1;
                i_v25 = i_v19;
            } else {
                if (i_v19 == 2047 || i_v19 < 2047) {
                    // 0xc500
                    i_v10 = 2;
                    i_v23 = i_v19;
                    i_v24 = i_v19 / 64;
                } else {
                    if (i_v19 >= 0xffff == (i_v19 != 0xffff)) {
                        // 0xc518
                        *(char *)(i_v6 + 3) = (char)i_v19 % 64 | -128;
                        i_v9 = 4;
                        i_v20 = i_v19 / 64;
                        i_v22 = i_v19 / 0x1000;
                        i_v21 = i_v19 / 0x40000;
                    } else {
                        // 0xc498
                        i_v9 = 3;
                        i_v20 = i_v19;
                        i_v22 = i_v19 / 64;
                        i_v21 = i_v19 / 0x1000;
                    }
                    // 0xc4a4
                    *(char *)(i_v6 + 2) = i_v20 % 64 | -128;
                    i_v10 = i_v9;
                    i_v23 = i_v22;
                    i_v24 = i_v21;
                }
                // 0xc4b8
                *(char *)(i_v6 + 1) = i_v23 % 64 | -128;
                i_v11 = i_v10;
                i_v25 = i_v24;
            }
            // 0xc4cc
            i_v36 = *(char *)(i_v11 + (int32_t)&p_g9);
            *(char *)i_v6 = i_v36 | i_v25;
            i_v12 = i_v13;
            i_v17 = *(char *)(i_v13 + 1);
            i_v7 = i_v11 + i_v6;
            goto lab_0xc404;
        }
        }
        int32_t i_v49; // 0xc244
        while (true) {
        lab_0xc27c:
            // 0xc27c
            i_v49 = i_v47;
            i_v2 = i_v46 + 1;
            if (i_v48 != 92) {
                // break -> 0xc26c
                break;
            }
            // 0xc28c
            i_v47 = i_v49 + 2;
            i_v48 = *(char *)i_v47;
            i_v46 = i_v2;
            i_v8 = i_v2;
            switch (i_v48) {
            case 34: {
                goto lab_0xc2a0;
            }
            case 0: {
                goto lab_0xc2a0;
            }
            default: {
                goto lab_0xc27c;
            }
            }
        }
        // 0xc26c
        i_v3 = i_v49 + 1;
    }
lab_0xc2a0:
    // 0xc2a0
    p_v42 = malloc(i_v8 + 1);
    i_v43 = (int32_t)p_v42;
    if (p_v42 == NULL) {
        // 0xc37c
        return i_v43;
    }
    // 0xc2b8
    i_v15 = *(char *)i_v1;
    i_v27 = i_v1;
    i_v5 = i_v43;
    while (true) {
    lab_0xc2d0_2:
        // 0xc2d0
        i_v6 = i_v5;
        i_v28 = i_v27;
        i_v16 = i_v15;
        switch (i_v16) {
        case 34: {
            goto lab_0xc360;
        }
        case 0: {
            goto lab_0xc360;
        }
        case 92: {
            // 0xc2f8
            i_v29 = i_v28 + 1;
            i_v30 = *(char *)i_v29;
            i_g122 = (int32_t)i_v30 - 98;
            switch (i_v30) {
            case 98: {
                // 0xc434
                *(char *)i_v6 = 8;
                i_v12 = i_v29;
                i_v17 = *(char *)(i_v28 + 2);
                i_v7 = i_v6 + 1;
                goto lab_0xc404;
            }
            case 117: {
                // 0xc388
                i_v31 = function_c130(i_v28 + 2);
                i_v32 = i_v28 + 5;
                if (i_v31 == 0) {
                    goto lab_0xc460;
                } else {
                    i_v33 = i_v31 - 0xdc00;
                    if (i_v33 == 1023 || i_v33 < 1023) {
                        goto lab_0xc460;
                    } else {
                        // 0xc3b0
                        i_v34 = i_v31 - (int32_t)&i_g120;
                        i_v13 = i_v32;
                        i_v18 = i_v31;
                        if (i_v34 >= 1023 == (i_v34 != 1023)) {
                            goto lab_0xc478;
                        } else {
                            // 0xc3bc
                            i_v35 = *(char *)(i_v28 + 6);
                            i_v12 = i_v32;
                            i_v17 = i_v35;
                            i_v7 = i_v6;
                            if (i_v35 == 92) {
                                // 0xc3c8
                                i_v12 = i_v32;
                                i_v17 = 92;
                                i_v7 = i_v6;
                                if (*(char *)(i_v28 + 7) == 117) {
                                    // 0xc3d4
                                    i_v37 = function_c130(i_v28 + 8);
                                    i_v38 = i_v28 + 11;
                                    i_v39 = i_v37 - 0xdc00;
                                    if (i_v39 == 1023 || i_v39 < 1023) {
                                        // 0xc468
                                        i_v40 = __asm_ubfx(i_v31, 0, 10);
                                        i_v41 = __asm_ubfx(i_v37, 0, 10);
                                        i_v13 = i_v38;
                                        i_v18 = (i_v41 | 1024 * i_v40) +
                                                (int32_t)&i_g1;
                                        goto lab_0xc478;
                                    } else {
                                        // 0xc3f4
                                        i_v12 = i_v38;
                                        i_v17 = *(char *)(i_v28 + 12);
                                        i_v7 = i_v6;
                                        goto lab_0xc404;
                                    }
                                } else {
                                    goto lab_0xc404;
                                }
                            } else {
                                goto lab_0xc404;
                            }
                        }
                    }
                }
            }
            case 116: {
                // 0xc3fc
                *(char *)i_v6 = 9;
                i_v12 = i_v29;
                i_v17 = *(char *)(i_v28 + 2);
                i_v7 = i_v6 + 1;
                goto lab_0xc404;
            }
            case 114: {
                // 0xc40c
                *(char *)i_v6 = 13;
                i_v12 = i_v29;
                i_v17 = *(char *)(i_v28 + 2);
                i_v7 = i_v6 + 1;
                goto lab_0xc404;
            }
            case 102: {
                // 0xc428
                *(char *)i_v6 = 12;
                i_v12 = i_v29;
                i_v17 = *(char *)(i_v28 + 2);
                i_v7 = i_v6 + 1;
                goto lab_0xc404;
            }
            case 110: {
                // 0xc418
                *(char *)i_v6 = 10;
                i_v12 = i_v29;
                i_v17 = *(char *)(i_v28 + 2);
                i_v7 = i_v6 + 1;
                goto lab_0xc404;
            }
            default: {
                // 0xc444
                *(char *)i_v6 = i_v30;
                i_v12 = i_v29;
                i_v17 = *(char *)(i_v28 + 2);
                i_v7 = i_v6 + 1;
                goto lab_0xc404;
            }
            }
        }
        default: {
            *(char *)i_v6 = i_v16;
            i_v44 = i_v28 + 1;
            i_v26 = i_v44;
            i_v14 = *(char *)i_v44;
            i_v4 = i_v6 + 1;
            goto lab_0xc2d0;
        }
        }
    }
lab_0xc360:
    // 0xc360
    *(char *)i_v6 = 0;
    *(int32_t *)(i_a1 + 16) = i_v43;
    *(int32_t *)(i_a1 + 12) = 4;
    // 0xc37c
    return i_v28 + (int32_t)(*(char *)i_v28 == 34);
lab_0xc2d0:
    // 0xc2d0
    i_v15 = i_v14;
    i_v27 = i_v26;
    i_v5 = i_v4;
    goto lab_0xc2d0_2;
lab_0xc404:
    // 0xc404
    i_v26 = i_v12 + 1;
    i_v14 = i_v17;
    i_v4 = i_v7;
    goto lab_0xc2d0;
lab_0xc460:
    // 0xc460
    i_v12 = i_v32;
    i_v17 = *(char *)(i_v28 + 6);
    i_v7 = i_v6;
    goto lab_0xc404;
lab_0xc478:
    // 0xc478
    i_v19 = i_v18;
    if (i_v19 == 127 || i_v19 < 127) {
        // 0xc4f0
        i_v11 = 1;
        i_v25 = i_v19;
    } else {
        if (i_v19 == 2047 || i_v19 < 2047) {
            // 0xc500
            i_v10 = 2;
            i_v23 = i_v19;
            i_v24 = i_v19 / 64;
        } else {
            if (i_v19 >= 0xffff == (i_v19 != 0xffff)) {
                // 0xc518
                *(char *)(i_v6 + 3) = (char)i_v19 % 64 | -128;
                i_v9 = 4;
                i_v20 = i_v19 / 64;
                i_v22 = i_v19 / 0x1000;
                i_v21 = i_v19 / 0x40000;
            } else {
                // 0xc498
                i_v9 = 3;
                i_v20 = i_v19;
                i_v22 = i_v19 / 64;
                i_v21 = i_v19 / 0x1000;
            }
            // 0xc4a4
            *(char *)(i_v6 + 2) = i_v20 % 64 | -128;
            i_v10 = i_v9;
            i_v23 = i_v22;
            i_v24 = i_v21;
        }
        // 0xc4b8
        *(char *)(i_v6 + 1) = i_v23 % 64 | -128;
        i_v11 = i_v10;
        i_v25 = i_v24;
    }
    // 0xc4cc
    i_v36 = *(char *)(i_v11 + (int32_t)&p_g9);
    *(char *)i_v6 = i_v36 | i_v25;
    i_v12 = i_v13;
    i_v17 = *(char *)(i_v13 + 1);
    i_v7 = i_v11 + i_v6;
    goto lab_0xc404;
}

// Address range: 0xc540 - 0xc570
int32_t function_c540(void) {
    int32_t *p_v1 = malloc(40); // 0xc550
    if (p_v1 != NULL) {
        // 0xc55c
        memset(p_v1, 0, 40);
    }
    // 0xc568
    return (int32_t)p_v1;
}

// Address range: 0xc574 - 0xc5b0
int32_t function_c574(int32_t *p_a1) {
    int32_t i_v1 = strlen((char *)p_a1) + 1; // 0xc588
    int32_t *p_v2 = malloc(i_v1);            // 0xc590
    if (p_v2 != NULL) {
        // 0xc59c
        memcpy(p_v2, p_a1, i_v1);
    }
    // 0xc5a8
    return (int32_t)p_v2;
}

// Address range: 0xc5b4 - 0xc634
int32_t function_c5b4(int32_t i_a1) {
    int32_t i_v1 = function_c540(); // 0xc5bc
    if (i_v1 == 0) {
        return 0;
    }
    int32_t i_v2 = i_a1;
    int32_t i_v3 = i_v1;
    int32_t i_v4 = i_v2 + 16; // 0xc5e4
    *(int32_t *)i_v3 = *(int32_t *)i_v2;
    *(int32_t *)(i_v3 + 4) = *(int32_t *)(i_v2 + 4);
    *(int32_t *)(i_v3 + 8) = *(int32_t *)(i_v2 + 8);
    *(int32_t *)(i_v3 + 12) = *(int32_t *)(i_v2 + 12);
    int32_t i_v5 = i_v3 + 16; // 0xc5fc
    while (i_v2 != i_a1 + 16) {
        // 0xc5d4
        i_v2 = i_v4;
        i_v3 = i_v5;
        i_v4 = i_v2 + 16;
        *(int32_t *)i_v3 = *(int32_t *)i_v2;
        *(int32_t *)(i_v3 + 4) = *(int32_t *)(i_v2 + 4);
        *(int32_t *)(i_v3 + 8) = *(int32_t *)(i_v2 + 8);
        *(int32_t *)(i_v3 + 12) = *(int32_t *)(i_v2 + 12);
        i_v5 = i_v3 + 16;
    }
    // 0xc604
    *(int32_t *)i_v5 = *(int32_t *)i_v4;
    *(int32_t *)(i_v3 + 20) = *(int32_t *)(i_a1 + 36);
    int32_t *p_v6 = (int32_t *)(i_v1 + 12); // 0xc618
    *(int32_t *)(i_v1 + 32) = 0;
    *(int32_t *)(i_v1 + 4) = 0;
    *p_v6 = *p_v6 | 256;
    *(int32_t *)i_v1 = 0;
    return i_v1;
}

// Address range: 0xc634 - 0xc69c
int32_t function_c634(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    if (i_a1 == 0) {
        // 0xc688
        return (bool)(i_a2 != 0);
    }
    // 0xc644
    if (i_a2 == 0) {
        // 0xc694
        return 1;
    }
    int32_t i_v1 = (int32_t)*__ctype_tolower_loc(); // 0xc658
    int32_t i_v2 = i_a2 - 1;                        // 0xc65c
    int32_t i_v3 = i_a1 - 1;                        // 0xc65c
    i_v3++;
    unsigned char i_v4 = *(char *)i_v3; // 0xc668
    i_v2++;
    int32_t i_v5 = *(int32_t *)(4 * (int32_t)i_v4 + i_v1);            // 0xc670
    int32_t i_v6 = *(int32_t *)(4 * (int32_t) * (char *)i_v2 + i_v1); // 0xc674
    while (i_v5 == i_v6) {
        // 0xc660
        if (i_v4 == 0) {
            // 0xc694
            return 0;
        }
        i_v3++;
        i_v4 = *(char *)i_v3;
        i_v2++;
        i_v5 = *(int32_t *)(4 * (int32_t)i_v4 + i_v1);
        i_v6 = *(int32_t *)(4 * (int32_t) * (char *)i_v2 + i_v1);
    }
    // 0xc680
    return i_v5 - i_v6;
}

// Address range: 0xc69c - 0xc82c
int32_t function_c69c(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0xc69c
    if (i_a1 == 0) {
        // 0xc818
        return function_c574(&i_g8);
    }
    // 0xc6a8
    int32_t i_v1; // 0xc69c
    char i_v2 = i_v1;
    char i_v3 = i_v2;    // 0xc6b0
    int32_t i_v4 = 0;    // 0xc6b0
    int32_t i_v5 = i_a1; // 0xc6b0
    int32_t i_v6 = 3;    // 0xc6b0
    if (i_v2 != 0) {
        int32_t i_v7; // 0xc69c
        while (true) {
            int32_t i_v8 = i_v5;
            int32_t i_v9 = i_v4;
            unsigned char i_v10 = i_v3;
            if (strchr("\"\\\b\f\n\r\t", (int32_t)i_v10) == NULL) {
                int32_t i_v11 = i_v8 + 1;    // 0xc6e8
                char i_v12 = *(char *)i_v11; // 0xc6e8
                int32_t i_v13 = i_v9 + (int32_t)(i_v10 >= 31 == (i_v10 != 31));
                int32_t i_v14 = i_v10 == 31 | i_v10 < 31 ? i_v13 + 6 : i_v13;
                i_v3 = i_v12;
                i_v4 = i_v14;
                i_v5 = i_v11;
                i_v7 = i_v14;
                if (i_v12 == 0) {
                    // break -> 0xc6fc
                    break;
                }
            } else {
                int32_t i_v15 = i_v9 + 2;
                int32_t i_v16 = i_v8 + 1;    // 0xc6c0
                char i_v17 = *(char *)i_v16; // 0xc6c0
                i_v3 = i_v17;
                i_v4 = i_v15;
                i_v5 = i_v16;
                i_v7 = i_v15;
                if (i_v17 == 0) {
                    // break -> 0xc6fc
                    break;
                }
            }
        }
        // 0xc6fc
        i_v6 = i_v7 + 3;
    }
    int32_t *p_v18 = malloc(i_v6);  // 0xc708
    int32_t i_v19 = (int32_t)p_v18; // 0xc708
    if (p_v18 == NULL) {
        // 0xc7ac
        return i_v19;
    }
    // 0xc714
    *(char *)p_v18 = 34;
    int32_t i_v20 = i_v19 + 1;  // 0xc730
    char i_v21 = *(char *)i_a1; // 0xc734
    char i_v22 = i_v21;         // 0xc73c
    int32_t i_v23 = i_a1;       // 0xc73c
    int32_t i_v24 = i_v20;      // 0xc73c
    int32_t i_v25 = i_v20;      // 0xc73c
    char i_v26;                 // 0xc69c
    int32_t i_v27;              // 0xc69c
    int32_t i_v28;              // 0xc69c
    int32_t i_v29;              // 0xc69c
    int32_t i_v30;              // 0xc69c
    char *p_v31;                // 0xc69c
    if (i_v21 != 0) {
        while (true) {
        lab_0xc740_2:
            // 0xc740
            i_v26 = i_v22;
            i_v28 = i_v24;
            while (true) {
            lab_0xc740:
                // 0xc740
                i_v30 = i_v23;
                i_v29 = i_v28;
                unsigned char i_v32 = i_v26;
                i_v23 = i_v30 + 1;
                p_v31 = (char *)i_v29;
                if (i_v32 == 34 ? i_v32 < 34 : i_v32 < 31) {
                    goto lab_0xc758;
                } else {
                    switch (i_v32) {
                    case 92: {
                        goto lab_0xc758;
                    }
                    case 34: {
                        goto lab_0xc758;
                    }
                    case 31: {
                        goto lab_0xc758;
                    }
                    default: {
                        *p_v31 = i_v32;
                        i_v27 = i_v29 + 1;
                        goto lab_0xc734;
                    }
                    }
                }
            }
        lab_0xc7e4:
            // 0xc7e4
            *(char *)(i_v29 + 1) = 102;
            i_v27 = i_v29 + 2;
            goto lab_0xc734;
        }
    }
lab_0xc7a0_2:
    // 0xc7a0
    *(char *)(i_v25 + 1) = 0;
    *(char *)i_v25 = 34;
    // 0xc7ac
    return i_v19;
lab_0xc758:
    // 0xc758
    *p_v31 = 92;
    unsigned char i_v33 = *(char *)i_v30; // 0xc75c
    if (i_v33 == 12) {
        // break -> 0xc7e4
        goto lab_0xc7e4;
    }
    if (i_v33 < 12) {
        switch (i_v33) {
        case 9: {
            // 0xc80c
            *(char *)(i_v29 + 1) = 116;
            i_v27 = i_v29 + 2;
            goto lab_0xc734;
        }
        case 10: {
            // 0xc800
            *(char *)(i_v29 + 1) = 110;
            i_v27 = i_v29 + 2;
            goto lab_0xc734;
        }
        case 8: {
            // 0xc7f0
            *(char *)(i_v29 + 1) = 98;
            i_v27 = i_v29 + 2;
            goto lab_0xc734;
        }
        default: {
            goto lab_0xc784;
        }
        }
    } else {
        switch (i_v33) {
        case 92: {
            // 0xc7d8
            *(char *)(i_v29 + 1) = i_v33;
            i_v27 = i_v29 + 2;
            goto lab_0xc734;
        }
        case 34: {
            // 0xc7d8
            *(char *)(i_v29 + 1) = i_v33;
            i_v27 = i_v29 + 2;
            goto lab_0xc734;
        }
        case 13: {
            // 0xc7cc
            *(char *)(i_v29 + 1) = 114;
            i_v27 = i_v29 + 2;
            goto lab_0xc734;
        }
        default: {
            goto lab_0xc784;
        }
        }
    }
lab_0xc784:
    // 0xc784
    sprintf((char *)(i_v29 + 1), "u%04x", (int32_t)i_v33);
    char i_v34 = *(char *)i_v23; // 0xc790
    int32_t i_v35 = i_v29 + 6;   // 0xc794
    i_v26 = i_v34;
    i_v28 = i_v35;
    i_v25 = i_v35;
    if (i_v34 == 0) {
        // break (via goto) -> 0xc7a0
        goto lab_0xc7a0_2;
    }
    goto lab_0xc740;
lab_0xc734:
    // 0xc734
    i_v24 = i_v27;
    i_v22 = *(char *)i_v23;
    i_v25 = i_v24;
    if (i_v22 == 0) {
        // break -> 0xc7a0
        goto lab_0xc7a0_2;
    }
    goto lab_0xc740_2;
}

// Address range: 0xc83c - 0xd05c
int32_t function_c83c(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0xc83c
    float64_t f_v1;                     // 0xc83c
    float64_t f_v2 = __asm_vpush(f_v1); // 0xc840
    if (i_a1 == 0) {
        // 0xc8a0
        __asm_vpop(f_v2);
        return 0;
    }
    unsigned char i_v3 = *(char *)(i_a1 + 12); // 0xc858
    int32_t i_v4 = i_v3;                       // 0xc858
    i_g123 = i_v4;
    switch (i_v3) {
    case 0: {
        // 0xc8b0
        __asm_vpop(f_v2);
        return function_c574((int32_t *)"false");
    }
    case 1: {
        // 0xc8c4
        __asm_vpop(f_v2);
        return function_c574((int32_t *)"true");
    }
    case 2: {
        // 0xc8d8
        __asm_vpop(f_v2);
        return function_c574((int32_t *)"null");
    }
    case 3: {
        // 0xc8ec
        __asm_vldr(*(int32_t *)(i_a1 + 20));
        return i_a1;
    }
    case 4: {
        // 0xc958
        __asm_vpop(f_v2);
        return function_c69c(*(int32_t *)(i_a1 + 16), i_a2, i_a3, i_v4);
    }
    case 5: {
        int32_t *p_v5 = (int32_t *)(i_a1 + 8); // 0xc96c
        int32_t i_v6 = *p_v5;                  // 0xc96c
        int32_t i_v7 = i_v6;                   // 0xc974
        if (i_v6 == 0) {
            int32_t *p_v8 = malloc(3); // 0xc890
            int32_t i_v9 = 0;          // 0xc898
            if (p_v8 != NULL) {
                // 0xcd9c
                i_v9 = (int32_t)p_v8;
                *(int16_t *)p_v8 = 0x5d5b;
                *(char *)(i_v9 + 2) = 0;
            }
            // 0xc8a0
            __asm_vpop(f_v2);
            return i_v9;
        }
        int32_t i_v10 = 0;
        i_v7 = *(int32_t *)i_v7;
        int32_t i_v11 = i_v10 + 1; // 0xc988
        while (i_v7 != 0) {
            // 0xc984
            i_v10 = i_v11;
            i_v7 = *(int32_t *)i_v7;
            i_v11 = i_v10 + 1;
        }
        int32_t i_v12 = 4 * i_v11;      // 0xc998
        int32_t *p_v13 = malloc(i_v12); // 0xc9a4
        if (p_v13 == NULL) {
            // 0xc8a0
            __asm_vpop(f_v2);
            return 0;
        }
        int32_t i_v14 = (int32_t)p_v13; // 0xc9a4
        memset(p_v13, 0, i_v12);
        int32_t i_v15 = *p_v5; // 0xc9c0
        int32_t i_v16 = 5;     // 0xc9c8
        if (i_v15 != 0) {
            int32_t i_v17 = i_a3 == 0 ? 2 : 3;
            int32_t i_v18 = 5;         // 0xc9e8
            int32_t i_v19 = i_v14 - 4; // 0xc9e8
            int32_t i_v20 = i_v15;     // 0xc9e8
            int32_t i_v21 =
                function_c83c(i_v20, i_a2 + 1, i_a3, i_a2); // 0xca20
            i_v19 += 4;
            *(int32_t *)i_v19 = i_v21;
            while (i_v21 != 0) {
                int32_t i_v22 = strlen((char *)i_v21); // 0xc9ec
                i_v20 = *(int32_t *)i_v20;
                i_v18 = i_v18 + i_v17 + i_v22;
                i_v16 = i_v18;
                if (i_v20 == 0) {
                    goto lab_0xcde4;
                }
                i_v21 = function_c83c(i_v20, i_a2 + 1, i_a3, i_v17);
                i_v19 += 4;
                *(int32_t *)i_v19 = i_v21;
            }
            // 0xc8a0
            __asm_vpop(f_v2);
            return 0;
        }
    lab_0xcde4:;
        int32_t *p_v23 = malloc(i_v16); // 0xcde8
        if (p_v23 == NULL) {
            // 0xc8a0
            __asm_vpop(f_v2);
            return 0;
        }
        int32_t i_v24 = (int32_t)p_v23; // 0xcde8
        *(char *)p_v23 = 91;
        int32_t i_v25 = i_v24 + 1; // 0xce0c
        *(char *)i_v25 = 0;
        int32_t i_v26 = i_v14; // 0xce10
        int32_t i_v27 = 0;     // 0xce10
        char i_v28 = i_g24;
        int32_t *p_v29 = (int32_t *)i_v26; // 0xce14
        strcpy((char *)i_v25, (char *)*p_v29);
        int32_t i_v30 = strlen((char *)*p_v29) + i_v25; // 0xce30
        char i_v31 = i_v28;                             // 0xce34
        int32_t i_v32 = i_v30;                          // 0xce34
        char i_v33;                                     // 0xc83c
        int32_t i_v34;                                  // 0xc83c
        if (i_v10 != i_v27) {
            // 0xce38
            *(char *)i_v30 = 44;
            i_v34 = i_v30 + (int32_t)(i_a3 == 0);
            i_v33 = i_a3 == 0 ? i_v28 : 32;
            if (i_a3 != 0) {
                *(char *)(i_v34 + 1) = i_v33;
            }
            i_v32 = i_a3 == 0 ? i_v34 : i_v34 + 2;
            *(char *)i_v32 = 0;
            i_v31 = i_v33;
        }
        int32_t i_v35 = i_v32;
        i_v27++;
        i_v26 += 4;
        int32_t i_v36 = i_v35; // 0xce74
        while (i_v27 < i_v11) {
            // 0xce14
            i_v28 = i_v31;
            p_v29 = (int32_t *)i_v26;
            strcpy((char *)i_v36, (char *)*p_v29);
            i_v30 = strlen((char *)*p_v29) + i_v36;
            i_v31 = i_v28;
            i_v32 = i_v30;
            if (i_v10 != i_v27) {
                // 0xce38
                *(char *)i_v30 = 44;
                i_v34 = i_v30 + (int32_t)(i_a3 == 0);
                i_v33 = i_a3 == 0 ? i_v28 : 32;
                if (i_a3 != 0) {
                    *(char *)(i_v34 + 1) = i_v33;
                }
                i_v32 = i_a3 == 0 ? i_v34 : i_v34 + 2;
                *(char *)i_v32 = 0;
                i_v31 = i_v33;
            }
            // 0xce60
            i_v35 = i_v32;
            i_v27++;
            i_v26 += 4;
            i_v36 = i_v35;
        }
        // 0xce78
        free(p_v13);
        *(char *)i_v35 = 93;
        *(char *)(i_v35 + 1) = 0;
        // 0xc8a0
        __asm_vpop(f_v2);
        return i_v24;
    }
    case 6: {
        int32_t *p_v37 = (int32_t *)(i_a1 + 8); // 0xca6c
        int32_t i_v38 = *p_v37;                 // 0xca6c
        if (i_v38 != 0) {
            int32_t i_v39 = 0;
            int32_t i_v40 = *(int32_t *)i_v38; // 0xca84
            int32_t i_v41 = i_v39 + 1;         // 0xca88
            int32_t i_v42 = i_v40;             // 0xca90
            while (i_v40 != 0) {
                // 0xca84
                i_v39 = i_v41;
                i_v40 = *(int32_t *)i_v42;
                i_v41 = i_v39 + 1;
                i_v42 = i_v40;
            }
            int32_t i_v43 = 4 * i_v41;      // 0xca98
            int32_t *p_v44 = malloc(i_v43); // 0xcaa4
            if (p_v44 == NULL) {
                // 0xc8a0
                __asm_vpop(f_v2);
                return 0;
            }
            int32_t *p_v45 = malloc(i_v43); // 0xcabc
            if (p_v45 == NULL) {
                // 0xc8a0
                __asm_vpop(f_v2);
                return 0;
            }
            int32_t i_v46 = (int32_t)p_v44; // 0xcaa4
            int32_t i_v47 = (int32_t)p_v45; // 0xcabc
            char i_v48 = (char)i_a2 + 1;    // 0xcae0
            memset(p_v44, 0, i_v43);
            memset(p_v45, 0, i_v43);
            int32_t i_v49 = *p_v37; // 0xcafc
            int32_t i_v50 = i_a3 == 0 ? 7 : i_a2 + 8;
            int32_t i_v51 = i_v50; // 0xcb10
            if (i_v49 != 0) {
                int32_t i_v52 = i_v48;                    // 0xcb2c
                int32_t i_v53 = i_a3 == 0 ? 2 : i_a2 + 5; // 0xcb38
                int32_t i_v54 = 0x1000000 * i_v53 >> 24;
                int32_t i_v55 = i_v49; // 0xcb48
                int32_t i_v56 = 0;     // 0xcb48
                int32_t i_v57 = function_c69c(*(int32_t *)(i_v55 + 32), 0, i_a2,
                                              i_v53); // 0xcb50
                *(int32_t *)(i_v56 + i_v47) = i_v57;
                int32_t i_v58 =
                    function_c83c(i_v55, i_v52, i_a3, i_v53); // 0xcb68
                bool i_v59 = i_v57 == 0 | i_v58 == 0;
                *(int32_t *)(i_v56 + i_v46) = i_v58;
                int32_t i_v60 = 1;     // 0xcb84
                int32_t i_v61 = i_v50; // 0xcb84
                int32_t i_v62;         // 0xcb88
                if (!i_v59) {
                    // 0xcb88
                    i_v62 = strlen((char *)i_v58);
                    i_v60 = i_v54;
                    i_v61 = i_v50 + i_v54 + i_v62 + strlen((char *)i_v57);
                }
                int32_t i_v63 = i_v59 ? 1 : 0;
                int32_t i_v64 = i_v61;
                int32_t i_v65 = i_v60;
                i_v55 = *(int32_t *)i_v55;
                int32_t i_v66 = i_v63; // 0xcbb4
                int32_t i_v67 = i_v52; // 0xcbb4
                int32_t i_v68 = i_a3;  // 0xcbb4
                i_v56 += 4;
                while (i_v55 != 0) {
                    int32_t i_v69 = i_v64;
                    i_v57 = function_c69c(*(int32_t *)(i_v55 + 32), i_v67,
                                          i_v68, i_v65);
                    *(int32_t *)(i_v56 + i_v47) = i_v57;
                    i_v58 = function_c83c(i_v55, i_v52, i_a3, i_v65);
                    i_v59 = i_v57 == 0 | i_v58 == 0;
                    *(int32_t *)(i_v56 + i_v46) = i_v58;
                    i_v60 = 1;
                    i_v61 = i_v69;
                    if (!i_v59) {
                        // 0xcb88
                        i_v62 = strlen((char *)i_v58);
                        i_v60 = i_v54;
                        i_v61 = i_v69 + i_v54 + i_v62 + strlen((char *)i_v57);
                    }
                    // 0xcba8
                    i_v63 = i_v59 ? 1 : i_v66;
                    i_v64 = i_v61;
                    i_v65 = i_v60;
                    i_v55 = *(int32_t *)i_v55;
                    i_v66 = i_v63;
                    i_v67 = i_v52;
                    i_v68 = i_a3;
                    i_v56 += 4;
                }
                // 0xcbb8
                i_v51 = i_v64;
                if (i_v63 != 0) {
                    // 0xc8a0
                    __asm_vpop(f_v2);
                    return 0;
                }
            }
            // 0xcea4
            if (i_v51 == 0) {
                // 0xc8a0
                __asm_vpop(f_v2);
                return 0;
            }
            int32_t i_v70 = i_v51 + 1;
            *(char *)i_v51 = 123;
            if (i_a3 != 0) {
                *(char *)i_v70 = 10;
            }
            int32_t i_v71 = i_a3 == 0 ? i_v70 : i_v51 + 2;
            *(char *)i_v71 = 0;
            int32_t i_v72 = 0x1000000 * i_v39 >> 24;
            int32_t i_v73 = i_v46 - 4; // 0xcf04
            int32_t i_v74 = 0;         // 0xcf04
            int32_t i_v75;             // 0xc83c
            int32_t i_v76;             // 0xc83c
            int32_t *p_v77;            // 0xd024
            int32_t i_v78;             // 0xd03c
            int32_t *p_v79;            // 0xcf2c
            int32_t i_v80;             // 0xcf44
            int32_t i_v81;             // 0xcf1c
            int32_t i_v82;             // 0xcf20
            if (i_a3 == 0) {
                // 0xd024
                p_v77 = (int32_t *)i_v47;
                strcpy((char *)i_v71, (char *)*p_v77);
                i_v78 = strlen((char *)*p_v77) + i_v71;
                *(char *)i_v78 = 58;
                i_v76 = i_v78 + 1;
            } else {
                // 0xcf10
                i_v75 = i_v71;
                if (i_v48 >= 1) {
                    // 0xcf1c
                    i_v81 = i_v71 + (int32_t)i_v48;
                    i_v82 = i_v71;
                    *(char *)i_v82 = 9;
                    i_v82++;
                    i_v75 = i_v81;
                    while (i_v82 != i_v81) {
                        // 0xcf20
                        *(char *)i_v82 = 9;
                        i_v82++;
                        i_v75 = i_v81;
                    }
                }
                // 0xcf2c
                p_v79 = (int32_t *)i_v47;
                strcpy((char *)i_v75, (char *)*p_v79);
                i_v80 = strlen((char *)*p_v79) + i_v75;
                *(char *)i_v80 = 58;
                *(char *)(i_v80 + 1) = 9;
                i_v76 = i_v80 + 2;
            }
            // 0xcf54
            i_v73 += 4;
            int32_t *p_v83 = (int32_t *)i_v73; // 0xcf54
            strcpy((char *)i_v76, (char *)*p_v83);
            int32_t i_v84 = strlen((char *)*p_v83) + i_v76; // 0xcf78
            if (i_v74 != i_v72) {
                *(char *)i_v84 = 44;
            }
            int32_t i_v85 = i_v84 + (int32_t)(i_v74 != i_v72);
            int32_t i_v86 = i_v85; // 0xcf90
            if (i_a3 != 0) {
                *(char *)i_v85 = 10;
                i_v86 = i_v85 + 1;
            }
            i_v74++;
            int32_t i_v87 = i_v86;
            char *p_v88 = (char *)i_v87;
            *p_v88 = 0;
            int32_t i_v89 = i_v47 + 4; // 0xcfbc
            while (i_v74 < i_v41) {
                int32_t i_v90 = i_v89;
                int32_t i_v91 = i_v87;
                if (i_a3 == 0) {
                    // 0xd024
                    p_v77 = (int32_t *)i_v90;
                    strcpy((char *)i_v91, (char *)*p_v77);
                    i_v78 = strlen((char *)*p_v77) + i_v91;
                    *(char *)i_v78 = 58;
                    i_v76 = i_v78 + 1;
                } else {
                    // 0xcf10
                    i_v75 = i_v91;
                    if (i_v48 >= 1) {
                        // 0xcf1c
                        i_v81 = i_v91 + (int32_t)i_v48;
                        i_v82 = i_v91;
                        *(char *)i_v82 = 9;
                        i_v82++;
                        i_v75 = i_v81;
                        while (i_v82 != i_v81) {
                            // 0xcf20
                            *(char *)i_v82 = 9;
                            i_v82++;
                            i_v75 = i_v81;
                        }
                    }
                    // 0xcf2c
                    p_v79 = (int32_t *)i_v90;
                    strcpy((char *)i_v75, (char *)*p_v79);
                    i_v80 = strlen((char *)*p_v79) + i_v75;
                    *(char *)i_v80 = 58;
                    *(char *)(i_v80 + 1) = 9;
                    i_v76 = i_v80 + 2;
                }
                // 0xcf54
                i_v73 += 4;
                p_v83 = (int32_t *)i_v73;
                strcpy((char *)i_v76, (char *)*p_v83);
                i_v84 = strlen((char *)*p_v83) + i_v76;
                if (i_v74 != i_v72) {
                    *(char *)i_v84 = 44;
                }
                i_v85 = i_v84 + (int32_t)(i_v74 != i_v72);
                i_v86 = i_v85;
                if (i_a3 != 0) {
                    *(char *)i_v85 = 10;
                    i_v86 = i_v85 + 1;
                }
                i_v74++;
                i_v87 = i_v86;
                p_v88 = (char *)i_v87;
                *p_v88 = 0;
                i_v89 = i_v90 + 4;
            }
            char *p_v92 = p_v88;   // 0xcfec
            int32_t i_v93 = i_v87; // 0xcfec
            if (i_a2 >= 1 && i_a3 != 0) {
                // 0xcffc
                i_v93 = i_v87 + i_a2;
                int32_t i_v94 = i_v87; // 0xd000
                *(char *)i_v94 = 9;
                i_v94++;
                while (i_v94 != i_v93) {
                    // 0xd004
                    *(char *)i_v94 = 9;
                    i_v94++;
                }
                // 0xd010
                p_v92 = (char *)i_v93;
            }
            // 0xd010
            *p_v92 = 125;
            *(char *)(i_v93 + 1) = 0;
            // 0xc8a0
            __asm_vpop(f_v2);
            return i_v51;
        }
        // break -> 0xcd1c
        break;
    }
    default: {
        // 0xc8a0
        __asm_vpop(f_v2);
        return 0;
    }
    }
    int32_t *p_v95 = malloc(i_a3 == 0 ? 3 : i_a2 + 4); // 0xcd34
    if (p_v95 == NULL) {
        // 0xc8a0
        __asm_vpop(f_v2);
        return 0;
    }
    int32_t i_v96 = (int32_t)p_v95; // 0xcd34
    *(char *)p_v95 = 123;
    int32_t i_v97 = i_v96 + 1;
    int32_t i_v98 = i_v97; // 0xcd50
    if (i_a3 != 0) {
        // 0xcd54
        *(char *)i_v97 = 10;
        int32_t i_v99 = i_v96 + 2; // 0xcd64
        i_v98 = i_v99;
        if (i_a2 >= 2) {
            int32_t i_v100 = i_a2 - 1 + i_v99; // 0xcd78
            int32_t i_v101 = i_v99;            // 0xcd78
            *(char *)i_v101 = 9;
            i_v101++;
            i_v98 = i_v100;
            while (i_v101 != i_v100) {
                // 0xcd7c
                *(char *)i_v101 = 9;
                i_v101++;
                i_v98 = i_v100;
            }
        }
    }
    // 0xcd88
    *(char *)i_v98 = 125;
    *(char *)(i_v98 + 1) = 0;
    // 0xc8a0
    __asm_vpop(f_v2);
    return i_v96;
}

// Address range: 0xd05c - 0xd7ec
int32_t function_d05c(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0xd05c
    float64_t f_v1;                     // 0xd05c
    float64_t f_v2 = __asm_vpush(f_v1); // 0xd060
    if (i_a2 == 0) {
        // 0xd158
        __asm_vpop(f_v2);
        return 0;
    }
    char *p_v3 = (char *)i_a2;
    if (strncmp(p_v3, "null", 4) == 0) {
        // 0xd164
        *(int32_t *)(i_a1 + 12) = 2;
        // 0xd158
        __asm_vpop(f_v2);
        return i_a2 + 4;
    }
    // 0xd088
    if (strncmp(p_v3, "false", 5) == 0) {
        // .thread
        *(int32_t *)(i_a1 + 12) = 0;
        // 0xd158
        __asm_vpop(f_v2);
        return i_a2 + 5;
    }
    int32_t i_v4 = strncmp(p_v3, "true", 4); // 0xd0b4
    if (i_v4 == 0) {
        // 0xd174
        *(int32_t *)(i_a1 + 12) = 1;
        *(int32_t *)(i_a1 + 20) = 1;
        // 0xd158
        __asm_vpop(f_v2);
        return i_a2 + 4;
    }
    unsigned char i_v5 = *p_v3; // 0xd0c0
    if (i_v5 == 34) {
        // 0xd560
        __asm_vpop(f_v2);
        return function_c244(i_a1, i_a2);
    }
    uint32_t i_v6 = (int32_t)i_v5 - 48; // 0xd0d8
    int32_t i_v7 = i_v6 >= 9 == (i_v6 != 9) ? (int32_t)(i_v5 == 45) : i_v6;
    if (i_v7 == 0 != (i_v6 != 9 && i_v6 >= 9)) {
        // 0xd198
        return i_v4;
    }
    int32_t i_v8;        // 0xd05c
    int32_t i_v9;        // 0xd05c
    int32_t i_v10;       // 0xd05c
    int32_t i_v11;       // 0xd05c
    int32_t i_v12;       // 0xd05c
    unsigned char i_v13; // 0xd10c
    switch (i_v5) {
    case 91: {
        int32_t i_v14 = i_a2 + 1; // 0xd5ec
        *(int32_t *)(i_a1 + 12) = 5;
        unsigned char i_v15 = *(char *)i_v14; // 0xd5f8
        int32_t i_v16 = i_v15;                // 0xd5f8
        i_v8 = i_v16;
        i_v11 = 0;
        if (i_v14 == 0) {
            goto lab_0xd638_2;
        } else {
            // 0xd600
            i_v12 = i_v14;
            if (i_v15 == 0) {
                goto lab_0xd640;
            } else {
                // 0xd608
                i_v8 = i_v16;
                i_v11 = i_v14;
                if (i_v15 >= 32 != i_v15 != 32) {
                    int32_t i_v17 = i_a2 + 2;
                    unsigned char i_v18 = *(char *)i_v17;
                    while (i_v17 != 0) {
                        // 0xd618
                        i_v12 = i_v17;
                        if (i_v18 == 0) {
                            goto lab_0xd640;
                        }
                        // 0xd624
                        if (i_v18 >= 32 == (i_v18 != 32)) {
                            // 0xd638
                            i_v8 = i_v18;
                            i_v11 = i_v17;
                            goto lab_0xd638_2;
                        }
                        i_v17++;
                        i_v18 = *(char *)i_v17;
                    }
                    // 0xd634
                    i_v8 = i_v18;
                    i_v11 = 0;
                }
                goto lab_0xd638_2;
            }
        }
    }
    case 123: {
        int32_t i_v19 = i_a2 + 1; // 0xd100
        *(int32_t *)(i_a1 + 12) = 6;
        i_v13 = *(char *)i_v19;
        i_v9 = 0;
        if (i_v19 == 0) {
            goto lab_0xd14c_2;
        } else {
            // 0xd114
            i_v10 = i_v19;
            if (i_v13 == 0) {
                goto lab_0xd2b0;
            } else {
                // 0xd11c
                i_v9 = i_v19;
                if (i_v13 >= 32 != i_v13 != 32) {
                    // branch -> 0xd14c
                }
                goto lab_0xd14c_2;
            }
        }
    }
    default: {
        // 0xd188
        i_g33 = i_a2;
        // 0xd158
        __asm_vpop(f_v2);
        return 0;
    }
    }
lab_0xd7bc:
    // 0xd158
    __asm_vpop(f_v2);
    int32_t i_v20; // 0xd05c
    return i_v20 + 1;
lab_0xd7dc:;
    // 0xd7dc
    int32_t i_v21; // 0xd05c
    i_g33 = i_v21;
    // 0xd158
    __asm_vpop(f_v2);
    return 0;
lab_0xd340:;
    // 0xd340
    int32_t i_v22;                            // 0xd2b0
    int32_t *p_v23 = (int32_t *)(i_v22 + 16); // 0xd340
    *p_v23 = 0;
    *(int32_t *)(i_v22 + 32) = *p_v23;
    char *p_v24;   // 0xd05c
    int32_t i_v25; // 0xd05c
    if (*p_v24 != 58) {
        // 0xd78c
        i_g33 = i_v25;
        // 0xd158
        __asm_vpop(f_v2);
        return 0;
    }
    int32_t i_v26 = i_v25 + 1; // 0xd35c
    int32_t i_v27 = 0;         // 0xd360
    int32_t i_v28;             // 0xd05c
    int32_t i_v29 = i_v28;     // 0xd360
    int32_t i_v30 = 58;        // 0xd360
    if (i_v26 != 0) {
        unsigned char i_v31 = *(char *)i_v26; // 0xd364
        i_v27 = i_v26;
        i_v29 = i_v28;
        i_v30 = 0;
        if (i_v31 != 0) {
            // 0xd370
            i_v27 = i_v26;
            i_v29 = i_v28;
            i_v30 = i_v31;
            if (i_v31 >= 32 != i_v31 != 32) {
                int32_t i_v32 = i_v25 + 2; // 0xd378
                int32_t i_v33 = i_v32;     // 0xd39c
                i_v27 = 0;
                i_v29 = i_v28;
                i_v30 = 0;
                if (i_v32 != 0) {
                    unsigned char i_v34 = *(char *)i_v33; // 0xd380
                    int32_t i_v35 = i_v33 + 1;            // 0xd380
                    int32_t i_v36 = i_v33;                // 0xd388
                    while (i_v34 != 0) {
                        // 0xd38c
                        i_v36 = i_v33;
                        if (i_v34 >= 32 == (i_v34 != 32)) {
                            // break -> 0xd3a0
                            break;
                        }
                        // 0xd394
                        i_v33 = i_v35;
                        i_v36 = 0;
                        if (i_v35 == 0) {
                            // break -> 0xd3a0
                            break;
                        }
                        i_v34 = *(char *)i_v33;
                        i_v35 = i_v33 + 1;
                        i_v36 = i_v33;
                    }
                    // 0xd3a0
                    i_v27 = i_v36;
                    i_v29 = i_v34;
                    i_v30 = i_v35;
                }
            }
        }
    }
    int32_t i_v37 = function_d05c(i_v22, i_v27, i_v29, i_v30); // 0xd3a4
    if (i_v37 == 0) {
        // 0xd158
        __asm_vpop(f_v2);
        return 0;
    }
    unsigned char i_v38 = *(char *)i_v37; // 0xd3b0
    char i_v39 = 0;                       // 0xd3b8
    int32_t i_v40 = i_v37;                // 0xd3b8
    if (i_v38 != 0) {
        // 0xd3bc
        i_v39 = i_v38;
        i_v40 = i_v37;
        if (i_v38 >= 32 != i_v38 != 32) {
            int32_t i_v41 = i_v37 + 1;
            while (i_v41 != 0) {
                unsigned char i_v42 = *(char *)i_v41; // 0xd3cc
                i_v39 = 0;
                i_v40 = i_v41;
                if (i_v42 == 0) {
                    goto lab_0xd3f0_2;
                }
                // 0xd3d8
                i_v39 = i_v42;
                i_v40 = i_v41;
                if (i_v42 >= 32 == (i_v42 != 32)) {
                    goto lab_0xd3f0_2;
                }
                i_v41++;
            }
            // 0xd158
            __asm_vpop(f_v2);
            return 0;
        }
    }
lab_0xd3f0_2:;
    char i_v43 = i_v39;    // 0xd3f0
    int32_t i_v44 = i_v29; // 0xd3f0
    int32_t i_v45 = i_v40; // 0xd3f0
    int32_t i_v46 = i_v22; // 0xd3f0
    char *p_v47;           // 0xd05c
    int32_t i_v48;         // 0xd05c
    int32_t i_v49;         // 0xd05c
    int32_t i_v50;         // 0xd3fc
    while (true) {
    lab_0xd3f4:;
        int32_t i_v51 = i_v45;
        i_v20 = i_v51;
        i_v21 = i_v51;
        switch (i_v43) {
        case 44: {
            // 0xd3fc
            i_v50 = function_c540();
            if (i_v50 == 0) {
                // 0xd158
                __asm_vpop(f_v2);
                return 0;
            }
            int32_t i_v52 = i_v44;
            int32_t i_v53 = i_v51 + 1; // 0xd408
            *(int32_t *)i_v46 = i_v50;
            *(int32_t *)(i_v50 + 4) = i_v46;
            int32_t i_v54 = 0;     // 0xd414
            int32_t i_v55 = i_v52; // 0xd414
            if (i_v53 != 0) {
                unsigned char i_v56 = *(char *)i_v53; // 0xd418
                i_v54 = i_v53;
                i_v55 = i_v52;
                if (i_v56 != 0) {
                    // 0xd424
                    i_v54 = i_v53;
                    i_v55 = i_v52;
                    if (i_v56 >= 32 != i_v56 != 32) {
                        int32_t i_v57 = i_v51 + 2; // 0xd42c
                        int32_t i_v58 = i_v57;     // 0xd450
                        i_v54 = 0;
                        i_v55 = i_v52;
                        if (i_v57 != 0) {
                            int32_t i_v59 = i_v58;
                            unsigned char i_v60 = *(char *)i_v59; // 0xd434
                            int32_t i_v61 = i_v59;                // 0xd43c
                            while (i_v60 != 0) {
                                // 0xd440
                                i_v61 = i_v59;
                                if (i_v60 >= 32 == (i_v60 != 32)) {
                                    // break -> 0xd454
                                    break;
                                }
                                int32_t i_v62 = i_v59 + 1; // 0xd434
                                i_v58 = i_v62;
                                i_v61 = 0;
                                if (i_v62 == 0) {
                                    // break -> 0xd454
                                    break;
                                }
                                i_v59 = i_v58;
                                i_v60 = *(char *)i_v59;
                                i_v61 = i_v59;
                            }
                            // 0xd454
                            i_v54 = i_v61;
                            i_v55 = i_v60;
                        }
                    }
                }
            }
            int32_t i_v63 = function_c244(i_v50, i_v54); // 0xd458
            if (i_v63 == 0) {
                // 0xd158
                __asm_vpop(f_v2);
                return 0;
            }
            int32_t i_v64 = i_v55;
            char *p_v65 = (char *)i_v63;
            unsigned char i_v66 = *p_v65; // 0xd464
            p_v47 = p_v65;
            i_v48 = i_v63;
            i_v49 = i_v64;
            if (i_v66 != 0) {
                int32_t i_v67 = i_v63; // 0xd474
                p_v47 = p_v65;
                i_v48 = i_v63;
                i_v49 = i_v64;
                if (i_v66 >= 32 != i_v66 != 32) {
                    int32_t i_v68 = i_v67 + 1;
                    if (i_v68 == 0) {
                        // 0xd158
                        __asm_vpop(f_v2);
                        return 0;
                    }
                    char *p_v69 = (char *)i_v68;
                    unsigned char i_v70 = *p_v69; // 0xd480
                    p_v47 = p_v69;
                    i_v48 = i_v68;
                    i_v49 = 0;
                    while (i_v70 != 0) {
                        // 0xd48c
                        i_v67 = i_v68;
                        if (i_v70 >= 32 == (i_v70 != 32)) {
                            // 0xd4a4
                            p_v47 = p_v69;
                            i_v48 = i_v68;
                            i_v49 = i_v70;
                            goto lab_0xd4a4_2;
                        }
                        i_v68 = i_v67 + 1;
                        if (i_v68 == 0) {
                            // 0xd158
                            __asm_vpop(f_v2);
                            return 0;
                        }
                        // 0xd480
                        p_v69 = (char *)i_v68;
                        i_v70 = *p_v69;
                        p_v47 = p_v69;
                        i_v48 = i_v68;
                        i_v49 = 0;
                    }
                }
            }
            goto lab_0xd4a4_2;
        }
        case 125: {
            goto lab_0xd7bc;
        }
        default: {
            goto lab_0xd7dc;
        }
        }
    }
    goto lab_0xd7dc;
lab_0xd4a4_2:;
    int32_t i_v71 = i_v49;
    int32_t i_v72 = i_v48;
    int32_t *p_v73 = (int32_t *)(i_v50 + 16); // 0xd4a4
    *p_v73 = 0;
    *(int32_t *)(i_v50 + 32) = *p_v73;
    if (*p_v47 != 58) {
        // 0xd7c4
        i_g33 = i_v72;
        goto lab_0xd158;
    }
    int32_t i_v74 = i_v72 + 1; // 0xd4bc
    int32_t i_v75 = 0;         // 0xd4c0
    int32_t i_v76 = i_v71;     // 0xd4c0
    int32_t i_v77 = 58;        // 0xd4c0
    if (i_v74 != 0) {
        unsigned char i_v78 = *(char *)i_v74; // 0xd4c4
        i_v75 = i_v74;
        i_v76 = i_v71;
        i_v77 = 0;
        if (i_v78 != 0) {
            // 0xd4d0
            i_v75 = i_v74;
            i_v76 = i_v71;
            i_v77 = i_v78;
            if (i_v78 >= 32 != i_v78 != 32) {
                int32_t i_v79 = i_v72 + 2; // 0xd4d8
                int32_t i_v80 = i_v79;     // 0xd4fc
                i_v75 = 0;
                i_v76 = i_v71;
                i_v77 = 0;
                if (i_v79 != 0) {
                    int32_t i_v81 = i_v80;
                    unsigned char i_v82 = *(char *)i_v81; // 0xd4e0
                    int32_t i_v83 = i_v81 + 1;            // 0xd4e0
                    int32_t i_v84 = i_v81;                // 0xd4e8
                    while (i_v82 != 0) {
                        // 0xd4ec
                        i_v84 = i_v81;
                        if (i_v82 >= 32 == (i_v82 != 32)) {
                            // break -> 0xd500
                            break;
                        }
                        // 0xd4f4
                        i_v80 = i_v83;
                        i_v84 = 0;
                        if (i_v83 == 0) {
                            // break -> 0xd500
                            break;
                        }
                        i_v81 = i_v80;
                        i_v82 = *(char *)i_v81;
                        i_v83 = i_v81 + 1;
                        i_v84 = i_v81;
                    }
                    // 0xd500
                    i_v75 = i_v84;
                    i_v76 = i_v82;
                    i_v77 = i_v83;
                }
            }
        }
    }
    int32_t i_v85 = i_v76;
    int32_t i_v86 = function_d05c(i_v50, i_v75, i_v85, i_v77); // 0xd504
    if (i_v86 == 0) {
        // 0xd158
        __asm_vpop(f_v2);
        return 0;
    }
    unsigned char i_v87 = *(char *)i_v86; // 0xd510
    char i_v88 = 0;                       // 0xd518
    int32_t i_v89 = i_v85;                // 0xd518
    int32_t i_v90 = i_v86;                // 0xd518
    if (i_v87 != 0) {
        // 0xd51c
        i_v88 = i_v87;
        i_v89 = i_v85;
        i_v90 = i_v86;
        if (i_v87 >= 32 != i_v87 != 32) {
            int32_t i_v91 = i_v86 + 1;
            if (i_v91 == 0) {
                // 0xd158
                __asm_vpop(f_v2);
                return 0;
            }
            unsigned char i_v92 = *(char *)i_v91; // 0xd52c
            int32_t i_v93 = i_v91 + 1;            // 0xd52c
            i_v88 = 0;
            i_v89 = i_v93;
            i_v90 = i_v91;
            while (i_v92 != 0) {
                // 0xd538
                i_v88 = i_v92;
                i_v89 = i_v93;
                i_v90 = i_v91;
                if (i_v92 >= 32 == (i_v92 != 32)) {
                    // break -> 0xd550
                    break;
                }
                i_v91 = i_v93;
                if (i_v91 == 0) {
                    // 0xd158
                    __asm_vpop(f_v2);
                    return 0;
                }
                // 0xd52c
                i_v92 = *(char *)i_v91;
                i_v93 = i_v91 + 1;
                i_v88 = 0;
                i_v89 = i_v93;
                i_v90 = i_v91;
            }
        }
    }
    // 0xd550
    i_v43 = i_v88;
    i_v44 = i_v89;
    i_v45 = i_v90;
    i_v46 = i_v50;
    goto lab_0xd3f4;
lab_0xd640:;
    int32_t i_v94 = function_c540(); // 0xd640
    *(int32_t *)(i_a1 + 8) = i_v94;
    int32_t i_v95 = i_v12; // 0xd650
    if (i_v94 == 0) {
        // 0xd158
        __asm_vpop(f_v2);
        return 0;
    }
    unsigned char i_v96 = *(char *)i_v95; // 0xd65c
    int32_t i_v97 = i_v95 + 1;            // 0xd65c
    int32_t i_v98 = i_v95;                // 0xd664
    while (i_v96 != 0) {
        // 0xd668
        i_v98 = i_v95;
        if (i_v96 >= 32 == (i_v96 != 32)) {
            // break -> 0xd67c
            break;
        }
        // 0xd670
        i_v95 = i_v97;
        i_v98 = 0;
        if (i_v97 == 0) {
            // break -> 0xd67c
            break;
        }
        i_v96 = *(char *)i_v95;
        i_v97 = i_v95 + 1;
        i_v98 = i_v95;
    }
    int32_t i_v99 =
        function_d05c(i_v94, i_v98, (int32_t)i_v96, i_v97); // 0xd680
    if (i_v99 == 0) {
        // 0xd158
        __asm_vpop(f_v2);
        return 0;
    }
    unsigned char i_v100 = *(char *)i_v99; // 0xd68c
    char i_v101 = 0;                       // 0xd694
    int32_t i_v102 = i_v97;                // 0xd694
    int32_t i_v103 = i_v99;                // 0xd694
    if (i_v100 != 0) {
        // 0xd698
        i_v101 = i_v100;
        i_v102 = i_v97;
        i_v103 = i_v99;
        if (i_v100 >= 32 != i_v100 != 32) {
            int32_t i_v104 = i_v99 + 1;
            while (i_v104 != 0) {
                unsigned char i_v105 = *(char *)i_v104; // 0xd6a8
                int32_t i_v106 = i_v104 + 1;            // 0xd6a8
                i_v101 = 0;
                i_v102 = i_v106;
                i_v103 = i_v104;
                if (i_v105 == 0) {
                    goto lab_0xd6d0_3;
                }
                // 0xd6b4
                i_v101 = i_v105;
                i_v102 = i_v106;
                i_v103 = i_v104;
                if (i_v105 >= 32 == (i_v105 != 32)) {
                    goto lab_0xd6d0_3;
                }
                i_v104 = i_v106;
            }
            // 0xd158
            __asm_vpop(f_v2);
            return 0;
        }
    }
lab_0xd6d0_3:;
    char i_v107 = i_v101;    // 0xd05c
    int32_t i_v108 = i_v102; // 0xd05c
    int32_t i_v109 = i_v103; // 0xd05c
    int32_t i_v110 = i_v94;  // 0xd05c
    while (true) {
    lab_0xd6d0:
        // 0xd6d0
        i_v20 = i_v109;
        i_v21 = i_v109;
        switch (i_v107) {
        case 44: {
            int32_t i_v111 = function_c540(); // 0xd6d8
            if (i_v111 == 0) {
                // 0xd158
                __asm_vpop(f_v2);
                return 0;
            }
            int32_t i_v112 = i_v109 + 1; // 0xd6e4
            *(int32_t *)i_v110 = i_v111;
            *(int32_t *)(i_v111 + 4) = i_v110;
            int32_t i_v113 = 0;      // 0xd6f0
            int32_t i_v114 = i_v108; // 0xd6f0
            if (i_v112 != 0) {
                unsigned char i_v115 = *(char *)i_v112; // 0xd6f4
                i_v113 = i_v112;
                i_v114 = 0;
                if (i_v115 != 0) {
                    // 0xd700
                    i_v113 = i_v112;
                    i_v114 = i_v115;
                    if (i_v115 >= 32 != i_v115 != 32) {
                        // 0xd708
                        int32_t i_v116;              // 0xd05c
                        int32_t i_v117 = i_v116 + 2; // 0xd708
                        int32_t i_v118 = i_v117;     // 0xd72c
                        i_v113 = 0;
                        i_v114 = 0;
                        if (i_v117 != 0) {
                            int32_t i_v119 = i_v118;
                            unsigned char i_v120 = *(char *)i_v119; // 0xd710
                            int32_t i_v121 = i_v119 + 1;            // 0xd710
                            int32_t i_v122 = i_v119;                // 0xd718
                            while (i_v120 != 0) {
                                // 0xd71c
                                i_v122 = i_v119;
                                if (i_v120 >= 32 == (i_v120 != 32)) {
                                    // break -> 0xd730
                                    break;
                                }
                                // 0xd724
                                i_v118 = i_v121;
                                i_v122 = 0;
                                if (i_v121 == 0) {
                                    // break -> 0xd730
                                    break;
                                }
                                i_v119 = i_v118;
                                i_v120 = *(char *)i_v119;
                                i_v121 = i_v119 + 1;
                                i_v122 = i_v119;
                            }
                            // 0xd730
                            i_v113 = i_v122;
                            i_v114 = i_v121;
                        }
                    }
                }
            }
            int32_t i_v123 = i_v114;
            int32_t i_v124 =
                function_d05c(i_v111, i_v113, 44, i_v123); // 0xd734
            if (i_v124 == 0) {
                // 0xd158
                __asm_vpop(f_v2);
                return 0;
            }
            unsigned char i_v125 = *(char *)i_v124; // 0xd740
            char i_v126 = 0;                        // 0xd748
            int32_t i_v127 = i_v123;                // 0xd748
            int32_t i_v128 = i_v124;                // 0xd748
            if (i_v125 != 0) {
                // 0xd74c
                i_v126 = i_v125;
                i_v127 = i_v123;
                i_v128 = i_v124;
                if (i_v125 >= 32 != i_v125 != 32) {
                    int32_t i_v129 = i_v124 + 1;
                    if (i_v129 == 0) {
                        // 0xd158
                        __asm_vpop(f_v2);
                        return 0;
                    }
                    unsigned char i_v130 = *(char *)i_v129; // 0xd75c
                    int32_t i_v131 = i_v129 + 1;            // 0xd75c
                    i_v126 = 0;
                    i_v127 = i_v131;
                    i_v128 = i_v129;
                    while (i_v130 != 0) {
                        // 0xd768
                        i_v126 = i_v130;
                        i_v127 = i_v131;
                        i_v128 = i_v129;
                        if (i_v130 >= 32 == (i_v130 != 32)) {
                            // break -> 0xd6cc
                            break;
                        }
                        i_v129 = i_v131;
                        if (i_v129 == 0) {
                            // 0xd158
                            __asm_vpop(f_v2);
                            return 0;
                        }
                        // 0xd75c
                        i_v130 = *(char *)i_v129;
                        i_v131 = i_v129 + 1;
                        i_v126 = 0;
                        i_v127 = i_v131;
                        i_v128 = i_v129;
                    }
                }
            }
            // 0xd6cc
            i_v107 = i_v126;
            i_v108 = i_v127;
            i_v109 = i_v128;
            i_v110 = i_v111;
            goto lab_0xd6d0;
        }
        case 93: {
            goto lab_0xd7bc;
        }
        default: {
            goto lab_0xd7dc;
        }
        }
    }
    goto lab_0xd7dc;
lab_0xd2b0:
    // 0xd2b0
    i_v22 = function_c540();
    *(int32_t *)(i_a1 + 8) = i_v22;
    int32_t i_v132 = i_v10; // 0xd2c0
    if (i_v22 == 0) {
        // 0xd158
        __asm_vpop(f_v2);
        return 0;
    }
    unsigned char i_v133 = *(char *)i_v132; // 0xd2cc
    int32_t i_v134 = i_v132;                // 0xd2d4
    while (i_v133 != 0) {
        // 0xd2d8
        i_v134 = i_v132;
        if (i_v133 >= 32 == (i_v133 != 32)) {
            // break -> 0xd2ec
            break;
        }
        int32_t i_v135 = i_v132 + 1; // 0xd2cc
        i_v132 = i_v135;
        i_v134 = 0;
        if (i_v135 == 0) {
            // break -> 0xd2ec
            break;
        }
        i_v133 = *(char *)i_v132;
        i_v134 = i_v132;
    }
    int32_t i_v136 = function_c244(i_v22, i_v134); // 0xd2f0
    if (i_v136 == 0) {
        // 0xd158
        __asm_vpop(f_v2);
        return 0;
    }
    int32_t i_v137 = i_v133; // 0xd2cc
    char *p_v138 = (char *)i_v136;
    unsigned char i_v139 = *p_v138; // 0xd2fc
    p_v24 = p_v138;
    i_v25 = i_v136;
    i_v28 = i_v137;
    if (i_v139 != 0) {
        // 0xd308
        p_v24 = p_v138;
        i_v25 = i_v136;
        i_v28 = i_v137;
        if (i_v139 >= 32 != i_v139 != 32) {
            int32_t i_v140 = i_v136 + 1;
            while (i_v140 != 0) {
                char *p_v141 = (char *)i_v140;
                unsigned char i_v142 = *p_v141; // 0xd318
                p_v24 = p_v141;
                i_v25 = i_v140;
                i_v28 = 0;
                if (i_v142 == 0) {
                    goto lab_0xd340;
                }
                // 0xd324
                if (i_v142 >= 32 == (i_v142 != 32)) {
                    // 0xd340
                    p_v24 = p_v141;
                    i_v25 = i_v140;
                    i_v28 = i_v142;
                    goto lab_0xd340;
                }
                i_v140++;
            }
        lab_0xd158:
            // 0xd158
            __asm_vpop(f_v2);
            return 0;
        }
    }
    goto lab_0xd340;
lab_0xd638_2:
    // 0xd638
    i_v12 = i_v11;
    if (i_v8 == 93) {
        // 0xd158
        __asm_vpop(f_v2);
        return i_v11 + 1;
    }
    goto lab_0xd640;
lab_0xd14c_2:
    // 0xd14c
    i_v10 = i_v9;
    if ((int32_t)i_v13 == 125) {
        // 0xd158
        __asm_vpop(f_v2);
        return i_v9 + 1;
    }
    goto lab_0xd2b0;
}

// Address range: 0xd7ec - 0xd7f0
int32_t function_d7ec(void) {
    // 0xd7ec
    return unknown_40de30();
}

// Address range: 0xd800 - 0xd810
int32_t function_d800(void) {
    // 0xd800
    return i_g33;
}

// Address range: 0xd810 - 0xd858
int32_t function_d810(int32_t i_a1) {
    if (i_a1 == 0) {
        // 0xd844
        i_g24 = 0x9e68;
        i_g25 = 0x9b20;
        return 0;
    }
    int32_t i_v1 = *(int32_t *)(i_a1 + 4); // 0xd818
    i_g24 = i_a1;
    i_g25 = i_v1 == 0 ? 0x9b20 : i_v1;
    return 0x9b20;
}

// Address range: 0xd858 - 0xd864
int32_t function_d858(int32_t i_a1, int32_t i_a2) {
    // 0xd858
    return i_a1;
}

// Address range: 0xd864 - 0xd8e0
int32_t function_d864(int32_t i_a1) {
    // 0xd864
    if (i_a1 == 0) {
        // 0xd8dc
        return 0;
    }
    int32_t i_v1 = i_a1;
    int32_t i_v2 = *(int32_t *)i_v1; // 0xd878
    int32_t i_v3;                    // 0xd884
    if ((*(int32_t *)(i_v1 + 12) & 256) == 0) {
        // 0xd884
        i_v3 = *(int32_t *)(i_v1 + 8);
        if (i_v3 != 0) {
            // 0xd890
            function_d864(i_v3);
        }
    }
    // 0xd8b4
    while (i_v2 != 0) {
        // 0xd874
        i_v1 = i_v2;
        i_v2 = *(int32_t *)i_v1;
        if ((*(int32_t *)(i_v1 + 12) & 256) == 0) {
            // 0xd884
            i_v3 = *(int32_t *)(i_v1 + 8);
            if (i_v3 != 0) {
                // 0xd890
                function_d864(i_v3);
            }
        }
    }
    // 0xd8dc
    return i_v1;
}

// Address range: 0xd8e4 - 0xd9d4
int32_t function_d8e4(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    // 0xd8e4
    int32_t i_v1; // 0xd8e4
    uint32_t i_v2 = i_v1;
    int32_t i_v3 = function_c540(); // 0xd8f4
    i_g33 = 0;
    if (i_v3 == 0) {
        // 0xd9a8
        return 0;
    }
    int32_t i_v4 = 0; // 0xd910
    int32_t i_v5 = 0; // 0xd910
    if (i_a1 != 0) {
        unsigned char i_v6 = (char)i_v2;
        i_v4 = 0;
        i_v5 = i_a1;
        if (i_v6 != 0) {
            // 0xd920
            i_v4 = i_v2 % 256;
            i_v5 = i_a1;
            if (i_v6 >= 32 != i_v6 != 32) {
                int32_t i_v7 = i_a1 + 1;
                i_v4 = 0;
                i_v5 = 0;
                while (i_v7 != 0) {
                    unsigned char i_v8 = *(char *)i_v7; // 0xd930
                    int32_t i_v9 = i_v7 + 1;            // 0xd930
                    i_v4 = i_v9;
                    i_v5 = i_v7;
                    if (i_v8 == 0) {
                        // break -> 0xd950
                        break;
                    }
                    // 0xd93c
                    i_v4 = i_v9;
                    i_v5 = i_v7;
                    if (i_v8 >= 32 == (i_v8 != 32)) {
                        // break -> 0xd950
                        break;
                    }
                    i_v7 = i_v9;
                    i_v4 = 0;
                    i_v5 = 0;
                }
            }
        }
    }
    int32_t i_v10 = function_d05c(i_v3, i_v5, i_a3, i_v4); // 0xd958
    if (i_v10 == 0) {
        // 0xd9c4
        function_d864(i_v3);
        // 0xd9a8
        return 0;
    }
    int32_t i_v11 = i_v10; // 0xd96c
    int32_t i_v12 = i_v10; // 0xd96c
    int32_t i_v13;         // 0xd8e4
    if (i_a3 != 0) {
        unsigned char i_v14 = *(char *)i_v11; // 0xd978
        i_v12 = i_v11;
        while (i_v14 != 0) {
            // 0xd984
            i_v13 = i_v11;
            if (i_v14 >= 32 == (i_v14 != 32)) {
                goto lab_0xd9b0_2;
            }
            // 0xd98c
            i_v11++;
            i_v13 = 0;
            if (i_v11 == 0) {
                goto lab_0xd9b0_2;
            }
            i_v14 = *(char *)i_v11;
            i_v12 = i_v11;
        }
    }
    int32_t i_v15 = i_v3; // 0xd9a4
    if (i_a2 != 0) {
        *(int32_t *)i_a2 = i_v12;
        i_v15 = i_v3;
    }
    // 0xd9a8
    return i_v15;
lab_0xd9b0_2:
    // 0xd9b0
    function_d864(i_v3);
    i_g33 = i_v13;
    i_v15 = 0;
    return i_v15;
}

// Address range: 0xd9d8 - 0xd9e4
int32_t function_d9d8(int32_t i_a1) {
    // 0xd9d8
    return function_d8e4(i_a1, 0, 0);
}

// Address range: 0xd9e4 - 0xd9f0
int32_t function_d9e4(int32_t i_a1) {
    // 0xd9e4
    int32_t i_v1; // 0xd9e4
    return function_c83c(i_a1, 0, 1, i_v1);
}

// Address range: 0xd9f0 - 0xd9fc
int32_t function_d9f0(void) {
    // 0xd9f0
    int32_t i_v1; // 0xd9f0
    return function_c83c(i_v1, 0, 0, i_v1);
}

// Address range: 0xd9fc - 0xda28
int32_t function_d9fc(int32_t i_a1) {
    int32_t i_v1 = *(int32_t *)(i_a1 + 8); // 0xd9fc
    int32_t i_v2 = 0;                      // 0xda04
    if (i_v1 == 0) {
        // 0xda1c
        return 0;
    }
    int32_t i_v3 = i_v1; // 0xda04
    i_v3 = *(int32_t *)i_v3;
    i_v2++;
    while (i_v3 != 0) {
        // 0xda0c
        i_v3 = *(int32_t *)i_v3;
        i_v2++;
    }
    // 0xda1c
    return i_v2;
}

// Address range: 0xda28 - 0xda50
int32_t function_da28(int32_t i_a1, int32_t i_a2) {
    int32_t i_v1 = *(int32_t *)(i_a1 + 8); // 0xda28
    if (i_v1 <= 0) {
        // 0xda4c
        return i_v1;
    }
    int32_t i_v2 = i_v1; // 0xda34
    i_v2 = *(int32_t *)i_v2;
    while (i_v2 > 0) {
        // 0xda38
        i_v2 = *(int32_t *)i_v2;
    }
    // 0xda4c
    return i_v2;
}

// Address range: 0xda50 - 0xda90
int32_t function_da50(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    int32_t i_v1 = *(int32_t *)(i_a1 + 8); // 0xda58
    if (i_v1 == 0) {
        // 0xda88
        return 0;
    }
    int32_t i_v2 = i_v1; // 0xda60
    int32_t i_v3 = i_v2; // 0xda84
    while (function_c634(*(int32_t *)(i_v2 + 32), i_a2, i_a3, i_a4) != 0) {
        // 0xda68
        i_v2 = *(int32_t *)i_v2;
        i_v3 = 0;
        if (i_v2 == 0) {
            // break -> 0xda88
            break;
        }
        i_v3 = i_v2;
    }
    // 0xda88
    return i_v3;
}

// Address range: 0xda90 - 0xdac8
int32_t function_da90(int32_t i_a1, int32_t i_a2) {
    if (i_a2 == 0) {
        return i_a1;
    }
    int32_t *p_v1 = (int32_t *)(i_a1 + 8); // 0xda94
    int32_t i_v2 = *p_v1;                  // 0xda94
    if (i_v2 == 0) {
        *p_v1 = i_a2;
        return i_a1;
    }
    int32_t i_v3 = i_v2;
    int32_t *p_v4 = (int32_t *)i_v3; // 0xdab0
    int32_t i_v5 = *p_v4;            // 0xdab0
    while (i_v5 != 0) {
        // 0xdab0
        i_v3 = i_v5;
        p_v4 = (int32_t *)i_v3;
        i_v5 = *p_v4;
    }
    // 0xdabc
    *p_v4 = i_a2;
    *(int32_t *)(i_a2 + 4) = i_v3;
    return i_a1;
}

// Address range: 0xdac8 - 0xdb30
int32_t function_dac8(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    // 0xdac8
    if (i_a3 == 0) {
        // 0xdb10
        return i_a1;
    }
    int32_t i_v1 = function_c574((int32_t *)i_a2); // 0xdaf8
    int32_t *p_v2 = (int32_t *)(i_a1 + 8);         // 0xdafc
    int32_t i_v3 = *p_v2;                          // 0xdafc
    if (i_v3 == 0) {
        *p_v2 = i_a3;
        *(int32_t *)(i_a3 + 32) = i_v1;
        // 0xdb10
        return i_v1;
    }
    // 0xdb18
    *(int32_t *)(i_a3 + 32) = i_v1;
    int32_t i_v4 = i_v3;
    int32_t *p_v5 = (int32_t *)i_v4; // 0xdb18
    int32_t i_v6 = *p_v5;            // 0xdb18
    while (i_v6 != 0) {
        // 0xdb18
        i_v4 = i_v6;
        p_v5 = (int32_t *)i_v4;
        i_v6 = *p_v5;
    }
    // 0xdb24
    *p_v5 = i_a3;
    *(int32_t *)(i_a3 + 4) = i_v4;
    return i_v1;
}

// Address range: 0xdb34 - 0xdb7c
int32_t function_db34(int32_t i_a1, int32_t i_a2) {
    int32_t i_v1 = function_c5b4(i_a2); // 0xdb40
    if (i_v1 == 0) {
        return i_v1;
    }
    int32_t *p_v2 = (int32_t *)(i_a1 + 8); // 0xdb44
    int32_t i_v3 = *p_v2;                  // 0xdb44
    if (i_v3 == 0) {
        *p_v2 = i_v1;
        return i_v1;
    }
    int32_t i_v4 = i_v3;
    int32_t *p_v5 = (int32_t *)i_v4; // 0xdb64
    int32_t i_v6 = *p_v5;            // 0xdb64
    while (i_v6 != 0) {
        // 0xdb64
        i_v4 = i_v6;
        p_v5 = (int32_t *)i_v4;
        i_v6 = *p_v5;
    }
    // 0xdb70
    *p_v5 = i_v1;
    *(int32_t *)(i_v1 + 4) = i_v4;
    return i_v1;
}

// Address range: 0xdb7c - 0xdba4
int32_t function_db7c(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0xdb7c
    return function_dac8(i_a1, i_a2, function_c5b4(i_a3));
}

// Address range: 0xdba4 - 0xdc0c
int32_t function_dba4(int32_t i_a1, int32_t i_a2) {
    int32_t *p_v1 = (int32_t *)(i_a1 + 8); // 0xdba4
    int32_t i_v2 = *p_v1;                  // 0xdba4
    int32_t i_v3 = i_v2;                   // 0xdbb4
    int32_t i_v4 = i_v2;                   // 0xdbb4
    if (i_v2 > 0) {
        i_v3 = *(int32_t *)i_v3;
        i_v4 = i_v3;
        while (i_v3 > 0) {
            // 0xdbb8
            i_v3 = *(int32_t *)i_v3;
            i_v4 = i_v3;
        }
    }
    // 0xdbcc
    if (i_v4 == 0) {
        // 0xdc04
        return i_v4;
    }
    int32_t *p_v5 = (int32_t *)(i_v4 + 4); // 0xdbd4
    int32_t i_v6 = *p_v5;                  // 0xdbd4
    int32_t *p_v7 = (int32_t *)i_v4;
    if (i_v6 != 0) {
        *(int32_t *)i_v6 = *p_v7;
    }
    int32_t i_v8 = *p_v7; // 0xdbe4
    if (i_v8 != 0) {
        *(int32_t *)(i_v8 + 4) = i_v6;
    }
    if (i_v4 == i_v2) {
        *p_v1 = i_v8;
    }
    *p_v7 = 0;
    *p_v5 = 0;
    // 0xdc04
    return i_v4;
}

// Address range: 0xdc0c - 0xdc1c
int32_t function_dc0c(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0xdc0c
    return function_d864(function_dba4(i_a1, i_a2));
}

// Address range: 0xdc1c - 0xdc78
int32_t function_dc1c(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    int32_t i_v1 = *(int32_t *)(i_a1 + 8); // 0xdc24
    int32_t i_v2 = i_v1;                   // 0xdc34
    if (i_v1 == 0) {
        // 0xdc70
        return 0;
    }
    int32_t i_v3 = 0;
    while (function_c634(*(int32_t *)(i_v2 + 32), i_a2, i_a3, i_a4) != 0) {
        // 0xdc3c
        i_v2 = *(int32_t *)i_v2;
        if (i_v2 == 0) {
            // 0xdc70
            return 0;
        }
        i_v3++;
    }
    // 0xdc60
    return function_dba4(i_a1, i_v3);
}

// Address range: 0xdc78 - 0xdc88
int32_t function_dc78(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0xdc78
    return function_d864(function_dc1c(i_a1, i_a2, i_a3, i_a4));
}

// Address range: 0xdc88 - 0xdcfc
int32_t function_dc88(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    int32_t *p_v1 = (int32_t *)(i_a1 + 8); // 0xdc88
    int32_t i_v2 = *p_v1;                  // 0xdc88
    int32_t i_v3 = i_v2;                   // 0xdc9c
    int32_t i_v4 = i_v2;                   // 0xdc9c
    if (i_v2 > 0) {
        i_v3 = *(int32_t *)i_v3;
        i_v4 = i_v3;
        while (i_v3 > 0) {
            // 0xdca0
            i_v3 = *(int32_t *)i_v3;
            i_v4 = i_v3;
        }
    }
    // 0xdcb4
    if (i_v4 == 0) {
        // 0xdcf4
        return i_a1;
    }
    int32_t *p_v5 = (int32_t *)i_v4;       // 0xdcbc
    int32_t i_v6 = *p_v5;                  // 0xdcbc
    int32_t *p_v7 = (int32_t *)(i_v4 + 4); // 0xdcbc
    *(int32_t *)i_a3 = i_v6;
    int32_t *p_v8 = (int32_t *)(i_a3 + 4); // 0xdcc4
    *p_v8 = *p_v7;
    if (i_v6 != 0) {
        *(int32_t *)(i_v6 + 4) = i_a3;
    }
    if (i_v4 == i_v2) {
        // .thread
        *p_v1 = i_a3;
    } else {
        *(int32_t *)*p_v8 = i_a3;
    }
    *p_v7 = 0;
    *p_v5 = 0;
    return function_d864(i_v4);
}

// Address range: 0xdcfc - 0xdd68
int32_t function_dcfc(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    int32_t i_v1 = *(int32_t *)(i_a1 + 8); // 0xdd04
    int32_t i_v2 = i_v1;                   // 0xdd14
    if (i_v1 == 0) {
        // 0xdd64
        return i_a1;
    }
    int32_t i_v3 = 0;
    int32_t i_v4; // 0xdcfc
    int32_t i_v5 =
        function_c634(*(int32_t *)(i_v2 + 32), i_a2, i_a3, i_v4); // 0xdd38
    while (i_v5 != 0) {
        // 0xdd20
        i_v2 = *(int32_t *)i_v2;
        int32_t i_v6 = i_v5; // 0xdd2c
        if (i_v2 == 0) {
            // 0xdd64
            return i_v6;
        }
        i_v3++;
        i_v5 = function_c634(*(int32_t *)(i_v2 + 32), i_a2, i_a3, i_v4);
    }
    // 0xdd44
    *(int32_t *)(i_a3 + 32) = function_c574((int32_t *)i_a2);
    return function_dc88(i_a1, i_v3, i_a3);
}

// Address range: 0xdd68 - 0xdd80
int32_t function_dd68(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    int32_t i_v1 = function_c540(); // 0xdd6c
    if (i_v1 != 0) {
        *(int32_t *)(i_v1 + 12) = 2;
    }
    return i_v1;
}

// Address range: 0xdd80 - 0xdd98
int32_t function_dd80(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    int32_t i_v1 = function_c540(); // 0xdd84
    if (i_v1 != 0) {
        *(int32_t *)(i_v1 + 12) = 1;
    }
    return i_v1;
}

// Address range: 0xdd98 - 0xddb0
int32_t function_dd98(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    int32_t i_v1 = function_c540(); // 0xdd9c
    if (i_v1 != 0) {
        *(int32_t *)(i_v1 + 12) = 0;
    }
    return i_v1;
}

// Address range: 0xddb0 - 0xddd4
int32_t function_ddb0(int32_t i_a1) {
    int32_t i_v1 = function_c540(); // 0xddb8
    if (i_v1 == 0) {
        return 0;
    }
    // 0xddc4
    *(int32_t *)(i_v1 + 12) = (int32_t)(i_a1 != 0);
    return i_v1;
}

// Address range: 0xddd4 - 0xddd5
int32_t function_ddd4(void) {
    // 0xddd4
    int32_t i_v1; // 0xddd4
    return i_v1;
}

// Address range: 0xddd6 - 0xddde
int32_t function_ddd6(void) {
    // 0xddd6
    int32_t i_v1; // 0xddd6
    bool i_v2;    // 0xddd6
    if (i_v2 == !i_v2) {
        function_c8292();
        i_v1 = function_1049296();
    }
    // 0xddde
    return i_v1;
}

// Address range: 0xdde0 - 0xddec
int32_t function_dde0(void) {
    int32_t i_v1 = function_c540(); // 0xdde0
    if (i_v1 != 0) {
        float64_t f_v2; // 0xdde0
        __asm_vstrne(f_v2, *(int32_t *)(i_v1 + 24));
    }
    return i_v1;
}

// Address range: 0xddee - 0xddfe
int32_t function_ddee(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    bool i_v1 = true; // 0xddee
    bool i_v2;        // 0xddee
    if (!i_v2) {
        *(int32_t *)i_a4 = i_a2;
        *(int32_t *)(i_a4 + 4) = i_a3;
        i_v1 = (i_a1 & 64) != 0;
    }
    int32_t i_v3 = i_a1; // 0xddf6
    if (!i_v2) {
        i_v3 = function_1533fe();
    }
    int32_t i_v4 = i_v3; // 0xddfa
    if (i_v1 == !i_v2) {
        i_v4 = function_95502();
    }
    // 0xddfe
    return i_v4;
}

// Address range: 0xde00 - 0xde04
int32_t function_de00(int32_t i_a1) {
    // 0xde00
    int32_t i_v1; // 0xde00
    return i_v1;
}

// Address range: 0xde04 - 0xde34
int32_t function_de04(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    int32_t i_v1 = function_c540(); // 0xde0c
    if (i_v1 != 0) {
        // 0xde18
        *(int32_t *)(i_v1 + 12) = 4;
        *(int32_t *)(i_v1 + 16) = function_c574((int32_t *)i_a1);
    }
    // 0xde2c
    return i_v1;
}

// Address range: 0xde34 - 0xde4c
int32_t function_de34(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    int32_t i_v1 = function_c540(); // 0xde38
    if (i_v1 != 0) {
        *(int32_t *)(i_v1 + 12) = 5;
    }
    return i_v1;
}

// Address range: 0xde4c - 0xde64
int32_t function_de4c(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    int32_t i_v1 = function_c540(); // 0xde50
    if (i_v1 != 0) {
        *(int32_t *)(i_v1 + 12) = 6;
    }
    return i_v1;
}

// Address range: 0xde64 - 0xdec8
int32_t function_de64(int32_t i_a1, int32_t i_a2) {
    // 0xde64
    int32_t i_v1;                                         // 0xde64
    int32_t i_v2 = function_de34(i_a1, i_a2, i_v1, i_v1); // 0xde70
    if (i_v2 <= 0) {
        // 0xdec0
        return i_v2;
    }
    // 0xde84
    __asm_vmov_112(*(int32_t *)i_a1);
    return i_v2;
}

// Address range: 0xdec8 - 0xdf24
int32_t function_dec8(int32_t i_a1, int32_t i_a2) {
    // 0xdec8
    int32_t i_v1;                                         // 0xdec8
    int32_t i_v2 = function_de34(i_a1, i_a2, i_v1, i_v1); // 0xded4
    if (i_v2 <= 0) {
        // 0xdf1c
        return i_v2;
    }
    // 0xdef0
    float32_t f_v3; // 0xdec8
    __asm_vldmia(i_a1, f_v3);
    return i_v2;
}

// Address range: 0xdf24 - 0xdf7c
int32_t function_df24(int32_t i_a1, uint32_t i_a2) {
    // 0xdf24
    int32_t i_v1;                                          // 0xdf24
    uint32_t i_v2 = function_de34(i_a1, i_a2, i_v1, i_v1); // 0xdf30
    if (i_v2 <= 0) {
        // 0xdf74
        return i_v2;
    }
    int32_t i_v3 = 0;    // 0xdf58
    int32_t i_v4 = 0;    // 0xdf24
    int32_t i_v5 = i_a1; // 0xdf4c
    float64_t f_v6;      // 0xdf24
    i_v5 = __asm_vldmia_113(i_v5, f_v6);
    int32_t i_v7 = function_ddd4(); // 0xdf50
    if (i_v3 == 0) {
        // .critedge1
        *(int32_t *)(i_v2 + 8) = i_v7;
    } else {
        // .critedge
        *(int32_t *)i_v4 = i_v7;
        *(int32_t *)(i_v7 + 4) = i_v4;
    }
    i_v3++;
    i_v4 = i_v7;
    while (i_v3 < i_a2) {
        // 0xdf4c
        i_v5 = __asm_vldmia_113(i_v5, f_v6);
        i_v7 = function_ddd4();
        if (i_v3 == 0) {
            // .critedge1
            *(int32_t *)(i_v2 + 8) = i_v7;
        } else {
            // .critedge
            *(int32_t *)i_v4 = i_v7;
            *(int32_t *)(i_v7 + 4) = i_v4;
        }
        i_v3++;
        i_v4 = i_v7;
    }
    // 0xdf74
    return i_v2;
}

// Address range: 0xdf7c - 0xdfd8
int32_t function_df7c(int32_t i_a1, uint32_t i_a2) {
    // 0xdf7c
    int32_t i_v1;                                          // 0xdf7c
    uint32_t i_v2 = function_de34(i_a1, i_a2, i_v1, i_v1); // 0xdf88
    if (i_v2 <= 0) {
        // 0xdfd0
        return i_v2;
    }
    int32_t i_v3 = 0;        // 0xdfa4
    int32_t i_v4 = 0;        // 0xdfa4
    int32_t i_v5 = i_a1 - 4; // 0xdfa4
    i_v5 += 4;
    int32_t i_v6 = function_de04(*(int32_t *)i_v5, i_a2, i_v1, i_v1); // 0xdfac
    if (i_v3 == 0) {
        // .critedge1
        *(int32_t *)(i_v2 + 8) = i_v6;
    } else {
        // .critedge
        *(int32_t *)i_v4 = i_v6;
        *(int32_t *)(i_v6 + 4) = i_v4;
    }
    i_v3++;
    i_v4 = i_v6;
    while (i_v3 < i_a2) {
        // 0xdfa8
        i_v5 += 4;
        i_v6 = function_de04(*(int32_t *)i_v5, i_a2, i_v1, i_v1);
        if (i_v3 == 0) {
            // .critedge1
            *(int32_t *)(i_v2 + 8) = i_v6;
        } else {
            // .critedge
            *(int32_t *)i_v4 = i_v6;
            *(int32_t *)(i_v6 + 4) = i_v4;
        }
        i_v3++;
        i_v4 = i_v6;
    }
    // 0xdfd0
    return i_v2;
}

// Address range: 0xdfd8 - 0xe0bc
int32_t function_dfd8(int32_t i_a1, int32_t i_a2) {
    // 0xdfd8
    if (i_a1 == 0) {
        // 0xe0ac
        return 0;
    }
    int32_t i_v1 = function_c540(); // 0xdfe8
    if (i_v1 == 0) {
        // 0xe0ac
        return 0;
    }
    uint64_t i_v2 = *(int64_t *)(i_a1 + 24); // 0xdff4
    int32_t i_v3 = *(int32_t *)(i_a1 + 16);  // 0xdff8
    *(int32_t *)(i_v1 + 24) = (int32_t)(i_v2 / 0x100000000);
    *(int32_t *)(i_v1 + 28) = (int32_t)i_v2;
    *(int32_t *)(i_v1 + 20) = *(int32_t *)(i_a1 + 20);
    *(int32_t *)(i_v1 + 12) = *(int32_t *)(i_a1 + 12) & -257;
    if (i_v3 != 0) {
        int32_t i_v4 = function_c574((int32_t *)i_v3); // 0xe01c
        *(int32_t *)(i_v1 + 16) = i_v4;
        if (i_v4 == 0) {
            // 0xe0a0
            function_d864(i_v1);
            // 0xe0ac
            return 0;
        }
    }
    int32_t i_v5 = *(int32_t *)(i_a1 + 32); // 0xe030
    if (i_v5 != 0) {
        int32_t i_v6 = function_c574((int32_t *)i_v5); // 0xe03c
        *(int32_t *)(i_v1 + 32) = i_v6;
        if (i_v6 == 0) {
            // 0xe0a0
            function_d864(i_v1);
            // 0xe0ac
            return 0;
        }
    }
    // 0xe050
    if (i_a2 == 0) {
        // 0xe0ac
        return i_v1;
    }
    int32_t i_v7 = *(int32_t *)(i_a1 + 8); // 0xe058
    if (i_v7 == 0) {
        // 0xe0ac
        return i_v1;
    }
    int32_t i_v8 = i_v7;
    int32_t i_v9 = 0;                       // 0xdfd8
    int32_t i_v10 = function_dfd8(i_v8, 1); // 0xe094
    while (i_v10 != 0) {
        int32_t i_v11 = i_v9;
        if (i_v11 == 0) {
            // .critedge
            *(int32_t *)(i_v1 + 8) = i_v10;
        } else {
            *(int32_t *)i_v11 = i_v10;
            *(int32_t *)(i_v10 + 4) = i_v11;
        }
        i_v8 = *(int32_t *)i_v8;
        i_v9 = i_v10;
        if (i_v8 == 0) {
            // 0xe0ac
            return i_v1;
        }
        i_v10 = function_dfd8(i_v8, 1);
    }
    // 0xe0a0
    function_d864(i_v1);
    // 0xe0ac
    return 0;
}

// Address range: 0xe0bc - 0xe1f4
int32_t function_e0bc(int32_t i_a1) {
    int32_t i_v1 = i_a1; // 0xe0c4
    char i_v2 = i_a1;    // 0xe0c4
    int32_t i_v3 = i_a1; // 0xe0c4
    int32_t i_v4;        // 0xe0bc
    int32_t i_v5;        // 0xe0bc
    int32_t i_v6;        // 0xe0bc
    int32_t i_v7;        // 0xe0bc
    int32_t i_v8;        // 0xe0bc
    int32_t i_v9;        // 0xe0bc
    while (true) {
        // 0xe104
        i_v4 = i_v3;
        i_v5 = i_v1;
        i_v9 = i_v2;
        int32_t i_v10; // 0xe0bc
        char i_v11;    // 0xe0bc
        int32_t i_v12; // 0xe0bc
        while (true) {
        lab_0xe104_3:
            // 0xe104
            i_v12 = i_v9;
            i_v6 = i_v5;
            i_v10 = i_v6;
            i_v3 = i_v4;
            switch (i_v12) {
            case 0: {
                goto lab_0xe10c;
            }
            case 32: {
                goto lab_0xe104_2;
            }
            case 13: {
                goto lab_0xe104_2;
            }
            case 10: {
                goto lab_0xe104_2;
            }
            case 9: {
                goto lab_0xe104_2;
            }
            case 47: {
                int32_t i_v13 = i_v6 + 1; // 0xe114
                i_v11 = 47;
                int32_t i_v14 = i_v13; // 0xe0bc
                int32_t i_v15 = i_v6;  // 0xe0bc
                int32_t i_v16 = 47;    // 0xe0bc
                int32_t i_v17 = i_v6;  // 0xe0bc
                switch (*(char *)i_v13) {
                case 47: {
                    while (true) {
                    lab_0xe1dc:;
                        int32_t i_v18 = i_v17;
                        int32_t i_v19 = i_v18 + 1; // 0xe1dc
                        i_v7 = i_v19;
                        i_v8 = i_v16;
                        int32_t i_v20; // 0xe0bc
                        switch ((char)i_v20) {
                        case 10: {
                            goto lab_0xe104;
                        }
                        case 0: {
                            goto lab_0xe104;
                        }
                        default: {
                            // 0xe1d4
                            i_v16 = (int32_t) * (char *)(i_v18 + 2);
                            i_v17 = i_v19;
                            goto lab_0xe1dc;
                        }
                        }
                    }
                    goto lab_0xe104;
                }
                case 42: {
                    int32_t i_v21 = i_v15;
                    int32_t i_v22 = i_v14;
                    int32_t i_v23 = i_v22 + 1;
                    // 0xe174
                    if (*(char *)i_v23 == 47) {
                        // break -> 0xe13c
                        break;
                    }
                    char i_v24 = *(char *)(i_v21 + 2); // 0xe154
                    int32_t i_v25 = i_v22;             // 0xe168
                    int32_t i_v26 = i_v23;             // 0xe168
                    i_v15 = i_v21 + 1;
                    while (i_v24 != 0) {
                        // 0xe16c
                        i_v21 = i_v15;
                        i_v22 = i_v23;
                        i_v23 = i_v22 + 1;
                        if (i_v24 == 42) {
                            // 0xe174
                            i_v25 = i_v21;
                            i_v26 = i_v22;
                            if (*(char *)i_v23 == 47) {
                                // break -> 0xe13c
                                break;
                            }
                        }
                        // 0xe154
                        i_v24 = *(char *)(i_v21 + 2);
                        i_v25 = i_v22;
                        i_v26 = i_v23;
                        i_v15 = i_v21 + 1;
                    }
                    // 0xe13c
                    i_v7 = i_v26 + 2;
                    i_v8 = (int32_t) * (char *)(i_v25 + 3);
                    goto lab_0xe104;
                }
                default: {
                    goto lab_0xe0f8;
                }
                }
            }
            default: {
                goto lab_0xe0f0;
            }
            }
        }
    lab_0xe0f0:;
        char i_v27 = i_v12;
        i_v11 = i_v27;
        if (i_v12 == 34) {
            // 0xe178
            *(char *)i_v4 = i_v27;
            int32_t i_v28 = i_v4 + 1;    // 0xe178
            int32_t i_v29 = i_v6 + 1;    // 0xe17c
            char i_v30 = *(char *)i_v29; // 0xe180
            int32_t i_v31 = i_v29;       // 0xe0bc
            char i_v32 = i_v30;          // 0xe0bc
            int32_t i_v33 = i_v28;       // 0xe0bc
            int32_t i_v34 = i_v29;       // 0xe0bc
            char i_v35 = i_v30;          // 0xe0bc
            int32_t i_v36 = i_v28;       // 0xe0bc
            switch (i_v30) {
            default: {
                while (true) {
                lab_0xe190:;
                    int32_t i_v37 = i_v33;
                    int32_t i_v38 = i_v37; // 0xe19c
                    if (i_v32 == 92) {
                        *(char *)i_v37 = 92;
                        i_v38 = i_v37 + 1;
                    }
                    int32_t i_v39 = i_v31 + (int32_t)(i_v32 == 92);
                    int32_t i_v40 = i_v39 + 1; // 0xe1a4
                    *(char *)i_v38 = *(char *)i_v39;
                    int32_t i_v41 = i_v38 + 1;   // 0xe1a8
                    char i_v42 = *(char *)i_v40; // 0xe1ac
                    i_v31 = i_v40;
                    i_v32 = i_v42;
                    i_v33 = i_v41;
                    i_v34 = i_v40;
                    i_v35 = i_v42;
                    i_v36 = i_v41;
                    switch (i_v42) {
                    case 34: {
                        goto lab_0xe1bc;
                    }
                    case 0: {
                        goto lab_0xe1bc;
                    }
                    default: {
                        goto lab_0xe190;
                    }
                    }
                }
            }
            case 34: {
            }
            case 0: {
            lab_0xe1bc:
                // 0xe1bc
                *(char *)i_v36 = i_v35;
                i_v10 = i_v34;
                i_v3 = i_v36 + 1;
                // break -> 0xe104
                break;
            }
            }
        } else {
        lab_0xe0f8:
            // 0xe0f8
            *(char *)i_v4 = i_v11;
            i_v10 = i_v6;
            i_v3 = i_v4 + 1;
        }
    lab_0xe104_2:
        // 0xe104
        i_v1 = i_v10 + 1;
        i_v2 = *(char *)i_v1;
    }
lab_0xe10c:
    // 0xe10c
    *(char *)i_v4 = 0;
    return i_v6;
lab_0xe104:
    // 0xe104
    i_v5 = i_v7;
    i_v9 = i_v8;
    goto lab_0xe104_3;
}

// Address range: 0xe1f4 - 0xe1f8
int32_t function_e1f4(void) {
    // 0xe1f4
    return unknown_40e838();
}

// Address range: 0xe1f8 - 0xe280
int32_t function_e1f8(int32_t *p_a1) {
    int32_t i_v1 = (int32_t)p_a1;
    int32_t i_v2; // bp-16, 0xe1f8
    gettimeofday((struct timeval *)&i_v2, NULL);
    int32_t i_v3; // bp-24, 0xe1f8
    int32_t i_v4; // 0xe1f8
    sprintf((char *)&i_v3, "%ld", i_v4);
    *(char *)p_a1 = 0;
    *(char *)(i_v1 + 1) = 0;
    *(char *)(i_v1 + 2) = 0;
    *(char *)(i_v1 + 3) = 0;
    *(char *)(i_v1 + 4) = 0;
    *(char *)(i_v1 + 5) = 0;
    *(char *)(i_v1 + 6) = 0;
    uint32_t i_v5 = (6 - strlen((char *)&i_v3)) % 256; // 0xe254
    if (i_v5 != 0) {
        // 0xe25c
        memset(p_a1, 48, i_v5);
    }
    // 0xe268
    strcat((char *)p_a1, (char *)&i_v3);
    return i_v1;
}

// Address range: 0xe284 - 0xe338
int32_t function_e284(char *p_a1, int32_t *p_a2) {
    struct in_addr x_v1;                                    // 0xe2f0
    int32_t i_v2 = socket(AF_INET, SOCK_DGRAM, IPPROTO_IP); // 0xe2a0
    if (i_v2 == -1) {
        // 0xe314
        perror("socket");
        // 0xe30c
        return -1;
    }
    // 0xe2b0
    int32_t i_v3; // bp-48, 0xe284
    strncpy((char *)&i_v3, p_a1, 20);
    int32_t i_v4; // 0xe284
    if (ioctl(i_v2, (int32_t)&i_g109) < 0) {
        // 0xe324
        printf(":No Such Device %s/n", p_a1);
        i_v4 = -1;
    } else {
        // 0xe2e0
        x_v1 = (struct { int32_t e0; }){.e0 = 0};
        int32_t i_v5; // 0xe284
        x_v1.e0 = i_v5;
        strcpy((char *)p_a2, inet_ntoa(x_v1));
        close(i_v2);
        i_v4 = 1;
    }
    // 0xe30c
    return i_v4;
}

// Address range: 0xe340 - 0xe430
int32_t function_e340(int32_t i_a1, char *p_a2) {
    int32_t *p_v1 = calloc(40, 1);                           // 0xe358
    int32_t i_v2 = socket(AF_INET, SOCK_STREAM, IPPROTO_IP); // 0xe36c
    if (i_v2 < 0) {
        // 0xe410
        perror("socket");
        exit(0);
        // UNREACHABLE
    }
    // 0xe378
    int32_t i_v3; // bp-56, 0xe340
    strcpy((char *)&i_v3, p_a2);
    if (ioctl(i_v2, (int32_t)&i_g110) < 0) {
        // 0xe420
        perror("ioctl");
        exit(0);
        return &i_g125;
    }
    // 0xe39c
    close(i_v2);
    char i_v4; // 0xe340
    sprintf((char *)p_v1, "%02X:%02X:%02X:%02X:%02X:%02X", (int32_t)i_v4,
            (int32_t)(unsigned char)i_v4, (int32_t)i_v4, (int32_t)i_v4,
            (int32_t)i_v4, (int32_t)i_v4);
    *(int32_t *)i_a1 = 0x3d43414d;
    *(int16_t *)stpcpy((char *)(i_a1 + 4), (char *)p_v1) = 44;
    free(p_v1);
    return i_a1;
}

// Address range: 0xe444 - 0xe49c
int32_t function_e444(int32_t *p_a1, int32_t *p_a2) {
    int32_t *p_v1 = malloc((int32_t) "oconf"); // 0xe454
    *p_a1 = (int32_t)p_v1;
    if (p_v1 == NULL) {
        // 0xe494
        exit(0);
        // UNREACHABLE
    }
    int32_t i_v2 = (int32_t)p_a1;
    *(int32_t *)(i_v2 + 8) = 0;
    *(int32_t *)(i_v2 + 4) = 0;
    int32_t *p_v3 = malloc((int32_t) "oconf"); // 0xe474
    *p_a2 = (int32_t)p_v3;
    if (p_v3 == NULL) {
        // 0xe494
        exit(0);
        // UNREACHABLE
    }
    int32_t i_v4 = (int32_t)p_a2;
    *(int32_t *)(i_v4 + 8) = 0;
    *(int32_t *)(i_v4 + 4) = 0;
    return 1;
}

// Address range: 0xe49c - 0xe4cc
int32_t function_e49c(int32_t i_a1) {
    int32_t *p_v1 = (int32_t *)i_a1;
    if (i_a1 != 0) {
        // 0xe4b0
        free(p_v1);
    }
    // 0xe4b4
    *p_v1 = 0;
    *(int32_t *)(i_a1 + 8) = 0;
    *(int32_t *)(i_a1 + 4) = 0;
    return 1;
}

// Address range: 0xe4cc - 0xe4e4
int32_t function_e4cc(int32_t *p_a1) {
    int32_t i_v1 = (int32_t)p_a1;
    *(int32_t *)(i_v1 + 8) = 0;
    *(int32_t *)(i_v1 + 4) = 0;
    return 1;
}

// Address range: 0xe4e4 - 0xe50c
int32_t function_e4e4(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    // 0xe4e4
    return (bool)(i_a2 == i_a3);
}

// Address range: 0xe50c - 0xe54c
int32_t function_e50c(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    int32_t i_v1 = i_a3 - i_a2 + 9; // 0xe52c
    return -9 * (((int32_t)((int64_t)i_v1 *
                            (int64_t)((int32_t)&i_g112 & 0xffff | 0x38e30000) /
                            0x100000000) >>
                  1) -
                 (i_v1 >> 31)) +
           i_v1;
}

// Address range: 0xe54c - 0xe598
int32_t function_e54c(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    int32_t i_v1 = 0; // 0xe56c
    if (i_a3 != i_a2) {
        // 0xe570
        memcpy((int32_t *)i_a4, (int32_t *)(0x100f * i_a2 + i_a1), 0x100f);
        i_v1 = 1;
    }
    // 0xe590
    return i_v1;
}

// Address range: 0xe598 - 0xe62c
int32_t function_e598(int32_t *p_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    int32_t i_v1 = (int32_t)p_a1;
    int32_t *p_v2 = (int32_t *)(i_v1 + 8); // 0xe5a4
    int32_t i_v3 = *p_v2;                  // 0xe5a4
    int32_t i_v4 = i_v3 + 1;               // 0xe5b4
    int32_t i_v5 = i_a2;                   // bp-12, 0xe5bc
    int32_t i_v6 =
        -9 * (((int32_t)((int64_t)i_v4 *
                         (int64_t)((int32_t)&i_g112 & 0xffff | 0x38e30000) /
                         0x100000000) >>
               1) -
              (i_v4 >> 31)) +
        i_v4;         // 0xe5d0
    int32_t i_v7 = 0; // 0xe5dc
    if (i_v6 != *(int32_t *)(i_v1 + 4)) {
        // 0xe5e0
        memcpy((int32_t *)(i_v6 + 0x100f * i_v3), &i_v5, 0x100f);
        int32_t i_v8 = *p_v2 + 1; // 0xe604
        *p_v2 =
            -9 * (((int32_t)((int64_t)i_v8 *
                             (int64_t)((int32_t)&i_g112 & 0xffff | 0x38e30000) /
                             0x100000000) >>
                   1) -
                  (i_v8 >> 31)) +
            i_v8;
        i_v7 = 1;
    }
    // 0xe620
    return i_v7;
}

// Address range: 0xe62c - 0xe698
int32_t function_e62c(int32_t *p_a1, int32_t *p_a2) {
    int32_t i_v1 = (int32_t)p_a1;
    int32_t *p_v2 = (int32_t *)(i_v1 + 4); // 0xe62c
    int32_t i_v3 = *p_v2;                  // 0xe62c
    if (i_v3 == *(int32_t *)(i_v1 + 8)) {
        // 0xe690
        return 0;
    }
    // 0xe644
    memcpy(p_a2, (int32_t *)(0x100f * i_v3 + i_v1), 0x100f);
    int32_t i_v4 = *p_v2 + 1; // 0xe66c
    *p_v2 = -9 * (((int32_t)((int64_t)i_v4 *
                             (int64_t)((int32_t)&i_g112 & 0xffff | 0x38e30000) /
                             0x100000000) >>
                   1) -
                  (i_v4 >> 31)) +
            i_v4;
    return 1;
}

// Address range: 0xe698 - 0xe75c
int32_t function_e698(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    if (i_a2 == i_a3) {
        // 0xe744
        putchar(10);
        return 1;
    }
    // 0xe6dc
    int32_t i_v1; // bp-4152, 0xe698
    memcpy(&i_v1, (int32_t *)(i_a1 + 16 + 0x100f * i_a2), 4095);
    int32_t i_v2 = i_a2 + 1; // 0xe724
    int32_t i_v3 =
        -9 * (((int32_t)((int64_t)i_v2 *
                         (int64_t)((int32_t)&i_g112 & 0xffff | 0x38e30000) /
                         0x100000000) >>
               1) -
              (i_v2 >> 31)) +
        i_v2; // 0xe738
    while (i_v3 != i_a3) {
        // 0xe6dc
        memcpy(&i_v1, (int32_t *)(i_a1 + 16 + 0x100f * i_v3), 4095);
        i_v2 = i_v3 + 1;
        i_v3 =
            -9 * (((int32_t)((int64_t)i_v2 *
                             (int64_t)((int32_t)&i_g112 & 0xffff | 0x38e30000) /
                             0x100000000) >>
                   1) -
                  (i_v2 >> 31)) +
            i_v2;
    }
    // 0xe744
    putchar(10);
    return 1;
}

// Address range: 0xe75c - 0xe7a4
int32_t function_e75c(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    int32_t i_v1 = i_a1; // bp-16, 0xe778
    int32_t i_v2 = i_a3; // bp-8, 0xe778
    int32_t i_v3;        // bp-10, 0xe75c
    int32_t i_v4;        // bp-13, 0xe75c
    int32_t i_v5 = printf("first_2byte=%s  ser_cmd=%s ser_len=%s body=%s\n",
                          &i_v1, &i_v4, &i_v3, &i_v2); // 0xe790
    return i_v5;
}

// Address range: 0xe7a4 - 0xe7d8
int32_t function_e7a4(int32_t i_a1) {
    int32_t i_v1 = *(int32_t *)(i_a1 + 4);     // 0xe7b0
    int32_t i_v2 = *(int32_t *)(i_a1 + 8) + 1; // 0xe7b4
    int32_t i_v3 =
        -9 * (((int32_t)((int64_t)i_v2 *
                         (int64_t)((int32_t)&i_g112 & 0xffff | 0x38e30000) /
                         0x100000000) >>
               1) -
              (i_v2 >> 31)) +
        i_v2; // 0xe7c8
    return i_v3 == i_v1 ? i_v3 - i_v1 : 1;
}

// Address range: 0xe7d8 - 0xe7ec
int32_t function_e7d8(int32_t *p_a1) {
    int32_t i_v1 = (int32_t)p_a1;
    int32_t i_v2 = *(int32_t *)(i_v1 + 4); // 0xe7d8
    int32_t i_v3 = *(int32_t *)(i_v1 + 8); // 0xe7dc
    return i_v2 == i_v3 ? i_v2 - i_v3 : 1;
}

// Address range: 0xe7ec - 0xe7f4
int32_t function_e7ec(void) {
    // 0xe7ec
    int32_t i_v1; // 0xe7ec
    return fwrite((int32_t *)i_v1, i_v1, i_v1, (struct _IO_FILE *)i_v1);
}

// Address range: 0xe7f4 - 0xe8dc
int32_t function_e7f4(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    int32_t i_v1 = i_a3; // bp-8, 0xe820
    *(int16_t *)&p_g86 = 0;
    *(char *)&i_g87 = 0;
    *(int16_t *)&p_g90 = 0;
    *(char *)&i_g91 = 0;
    *(int16_t *)&p_g84 = 0;
    memset((int32_t *)&p_g89, 0, 0x1000);
    int32_t *p_v2 = memset(&i_v1, 0, 0x1000); // 0xe894
    i_g93 = 0;
    *(int32_t *)&p_g92 = 0;
    i_g94 = 0;
    i_g95 = 0;
    i_g96 = 0;
    i_g97 = 0;
    i_g98 = 0;
    i_g99 = 0;
    i_g100 = 0;
    i_g101 = 0;
    return (int32_t)p_v2;
}

// Address range: 0xe8dc - 0xeb30
int32_t function_e8dc(void) {
    // 0xe8dc
    int32_t i_v1; // bp-140, 0xe8dc
    memset(&i_v1, 0, 100);
    printf("r_connect = %d.\n", i_g26);
    i_g107 = i_g108;
    if (i_g108 == -1) {
        // 0xea54
        puts("recv data failed1.");
        i_g26 = 0;
        int32_t i_v2; // bp-4240, 0xe8dc
        memcpy(&i_v2, &i_g52, 4095);
        function_e7f4(i_g48, i_g49, i_g50, i_g51);
        function_e4cc(&i_g34);
        function_e4cc(&i_g56);
        // 0xe974
        return 0;
    }
    // 0xe944
    printf("recv package.pkg_head:%s.\n", (char *)&p_g72);
    *(char *)(i_g107 + (int32_t)&p_g72) = 0;
    if (i_g107 == 0) {
        // 0xea98
        puts("the first two byte not 00   it is 0");
        // 0xe974
        return 0;
    }
    // 0xe964
    if (*(char *)&p_g72 == 48 != (i_g73 == 48) || i_g74 != 0) {
        // 0xe974
        return -1;
    }
    // 0xe998
    i_g107 = i_g108;
    int32_t i_v3 = -1; // 0xe8dc
    switch (i_g108) {
    case -1: {
        goto lab_0xeaa8;
    }
    case 0: {
        // 0xe974
        return 0;
    }
    case 2: {
        // 0xe9d0
        *(char *)&i_g77 = 0;
        printf("rev from server cmd = \n%s\n", (char *)&p_g75);
        i_g107 = i_g108;
        i_v3 = -1;
        switch (i_g108) {
        case -1: {
            goto lab_0xeaa8;
        }
        case 0: {
            // 0xe974
            return 0;
        }
        case 2: {
            // 0xea14
            char i_v4;    // 0xe8dc
            int32_t i_v5; // 0xe8dc
            int32_t i_v6 =
                256 * i_v5 & 0xff00 | (int32_t)(unsigned char)i_v4; // 0xea28
            printf("rev from server sum=\n%d\n", i_v6);
            if (i_v6 == 0) {
                // 0xe974
                return 1;
            }
            int32_t i_v7 = i_g108; // 0xeabc
            i_g107 = i_v7;
            int32_t i_v8 = i_v7 == -1 ? 0 : i_v7;
            if (i_v7 == -1) {
                i_g26 = i_v8;
                // 0xe974
                return 0;
            }
            // 0xeae4
            *(char *)(i_v6 + (int32_t)&p_g72 + 0x1008) = 0;
            printf("recvbytes:%d,sum:%d,pkgnonce=%s\n", i_v8, i_v6,
                   (char *)&p_g80);
            if (i_g107 == 0) {
                i_g26 = 0;
                // 0xe974
                return 0;
            }
            // 0xeb18
            i_v3 = 1;
            if (i_v6 != i_g107) {
                // 0xeb24
                puts("PAKGE ERROR!!!!!");
                i_v3 = -1;
            }
            // 0xe974
            return i_v3;
        }
        default: {
            return i_v3;
        }
        }
    }
    default: {
        return i_v3;
    }
    }
lab_0xeaa8:
    // 0xeaa8
    i_g26 = i_g74;
    // 0xe974
    return 0;
}

// Address range: 0xeb78 - 0xeca4
int32_t function_eb78(void) {
    // 0xeb78
    if (*(char *)&p_g38 != 102) {
        // 0xeb8c
        printf("respond rev : %s", (char *)&p_g38);
        exit(0);
        // UNREACHABLE
    }
    // 0xeba0
    switch (i_g39) {
    case 49: {
        // 0xebd0
        if (i_g40 == 0) {
            // 0xebdc
            puts("Server respond  F1\n");
            exit(0);
            // UNREACHABLE
        }
        // 0xeb8c
        printf("respond rev : %s", (char *)&p_g38);
        exit(0);
        // UNREACHABLE
    }
    case 50: {
        // 0xebb4
        if (i_g40 == 0) {
            // 0xebc0
            puts("Server respond  F2\n");
            exit(0);
            // UNREACHABLE
        }
        // 0xeb8c
        printf("respond rev : %s", (char *)&p_g38);
        exit(0);
        // UNREACHABLE
    }
    case 51: {
        // 0xebf4
        if (i_g40 == 0) {
            // 0xec00
            puts("Server respond  F3\n");
            exit(0);
            // UNREACHABLE
        }
        // 0xeb8c
        printf("respond rev : %s", (char *)&p_g38);
        exit(0);
        // UNREACHABLE
    }
    case 52: {
        // 0xec18
        if (i_g40 == 0) {
            // 0xec24
            puts("Server respond  F4\n");
            exit(0);
            // UNREACHABLE
        }
        // 0xeb8c
        printf("respond rev : %s", (char *)&p_g38);
        exit(0);
        // UNREACHABLE
    }
    case 53: {
        // 0xec3c
        if (i_g40 == 0) {
            // 0xec48
            return puts("Server respond  F5\n");
        }
        // 0xeb8c
        printf("respond rev : %s", (char *)&p_g38);
        exit(0);
        // UNREACHABLE
    }
    case 54: {
        // 0xec5c
        if (i_g40 != 0) {
            // 0xeb8c
            printf("respond rev : %s", (char *)&p_g38);
            exit(0);
            // UNREACHABLE
        }
        // 0xec68
        puts("Server respond  F6\n");
        puts("F6 exit!!!!!!");
        exit(0);
        // UNREACHABLE
    }
    case 55: {
        // 0xec88
        if (i_g40 == 0) {
            // 0xec94
            puts("Server respond  F7\n");
            exit(0);
            return &i_g125;
        }
        // 0xeb8c
        printf("respond rev : %s", (char *)&p_g38);
        exit(0);
        // UNREACHABLE
    }
    }
    // 0xeb8c
    printf("respond rev : %s", (char *)&p_g38);
    exit(0);
    // UNREACHABLE
}

// Address range: 0xecd0 - 0xedd8
int32_t function_ecd0(int32_t i_a1, uint32_t i_a2) {
    // 0xecd0
    printf("body_len1=%d\n", i_a2 / 256 % 256);
    printf("body_len2=%d\n", i_a2 % 256);
    i_g106 = i_g108;
    if (i_g108 == -1) {
        // 0xedc8
        perror("send head");
        exit(1);
        return &i_g125;
    }
    // 0xed38
    strlen((char *)i_a1);
    i_g106 = i_g108;
    if (i_g108 != -1) {
        // 0xedac
        i_g106 = i_g108;
        return 1;
    }
    // 0xedb8
    perror("send");
    exit(1);
    // UNREACHABLE
}

// Address range: 0xedfc - 0xf028
int32_t function_edfc(char *p_a1) {
    // 0xedfc
    int32_t i_v1; // bp-100, 0xedfc
    memset(&i_v1, 0, 60);
    int32_t i_v2 = 0;              // bp-152, 0xee24
    int32_t i_v3 = 0;              // bp-140, 0xee30
    int32_t *p_v4 = calloc(30, 1); // 0xee58
    int32_t *p_v5 = calloc(25, 1); // 0xee68
    int32_t *p_v6 = calloc(60, 1); // 0xee78
    if (function_e284("eth0", &i_v3) == 0) {
        // 0xf008
        puts("get ip error!");
    }
    int32_t i_v7 = (int32_t)p_v6; // 0xee78
    sprintf((char *)p_v5, "IP=%s,", &i_v3);
    *(char *)(i_v7 + 4) = 0;
    *p_v6 = 0x3d444955;
    int32_t i_v8 = function_fa50((int32_t)p_g17, "api-uid", &i_v1,
                                 (int32_t *)"UID="); // 0xeec4
    char *p_v9 =
        stpcpy((char *)(strlen((char *)p_v6) + i_v7), (char *)i_v8); // 0xeedc
    *(int16_t *)p_v9 = 44;
    sprintf((char *)&i_v2, "TYPE=%d", 7);
    int32_t i_v10 = strlen((char *)function_e1f8((int32_t *)&p_g71)); // 0xef04
    int32_t i_v11 =
        strlen((char *)function_e340((int32_t)p_v4, "eth0")); // 0xef18
    int32_t i_v12 = strlen((char *)p_v5);                     // 0xef24
    int32_t i_v13 = strlen((char *)p_v6);                     // 0xef34
    uint32_t i_v14 =
        (i_v11 + i_v10 + i_v12 + i_v13 + strlen((char *)&i_v2)) % 256; // 0xef54
    function_ecd0((int32_t)p_a1, i_v14);
    int32_t *p_v15 = calloc(i_v14 + 4, 1); // 0xef68
    char *p_v16 =
        stpcpy(stpcpy((char *)p_v15, (char *)&p_g71), (char *)p_v4); // 0xef7c
    strcpy(stpcpy(stpcpy(p_v16, (char *)p_v5), (char *)p_v6), (char *)&i_v2);
    i_g106 = i_g108;
    if (i_g108 == -1) {
        // 0xf01c
        perror("send");
    }
    // 0xefcc
    printf("send pakge str :%s\n", p_v15);
    free(p_v4);
    free(p_v5);
    free(p_v6);
    if (p_v15 == NULL) {
        // 0xf014
        return &i_g125;
    }
    // 0xeff8
    free(p_v15);
    return &i_g125;
}

// Address range: 0xf064 - 0xf0e8
int32_t function_f064(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    int32_t i_v1 = strlen((char *)&p_g89); // 0xf070
    printf("02revbody_size=%d\n", i_v1);
    function_ecd0(i_a1, i_v1);
    i_g106 = i_g108;
    if (i_g108 != -1) {
        // 0xf0c4
        printf("send what I rev:\n%s\n", (char *)&p_g89);
        return 1;
    }
    // 0xf0d8
    perror("send");
    exit(1);
    return &i_g125;
}

// Address range: 0xf108 - 0xf3c8
int32_t function_f108(char *p_a1) {
    int32_t i_v1 = (int32_t)&x_g21; // 0xf118
    int32_t i_v2 = 0;
    while (strcmp(p_a1, (char *)*(int32_t *)(i_v1 + 4)) != 0) {
        // 0xf11c
        i_v1 += 4;
        int32_t i_v3 = i_v2 + 1; // 0xf130
        if (i_v3 == 7) {
            goto lab_0xf13c;
        }
        i_v2 = i_v3;
    }
    int32_t i_v4 = 4 * i_v2;                           // 0xf300
    char *p_v5 = (char *)*(int32_t *)(i_v4 + 0x1b2fc); // 0xf308
    int32_t i_v6 = strlen(p_v5) + 1;                   // 0xf30c
    int32_t *p_v7 = malloc(i_v6);                      // 0xf314
    memset(p_v7, 0, i_v6);
    strcpy((char *)p_v7, p_v5);
    char *p_v8 = (char *)*(int32_t *)(i_v4 + (int32_t)&x_g20); // 0xf340
    int32_t i_v9 = strlen(p_v8) + 1;                           // 0xf344
    int32_t *p_v10 = malloc(i_v9);                             // 0xf34c
    memset(p_v10, 0, i_v9);
    strcpy((char *)p_v10, p_v8);
    char *p_v11 = (char *)*(int32_t *)(i_v4 + (int32_t)&x_g22); // 0xf378
    int32_t i_v12 = strlen(p_v11) + 1;                          // 0xf37c
    int32_t *p_v13 = malloc(i_v12);                             // 0xf384
    memset(p_v13, 0, i_v12);
    strcpy((char *)p_v13, p_v11);
    int32_t i_v14 = (int32_t)p_v10; // 0xf3a4
    int32_t i_v15 = (int32_t)p_v7;  // 0xf3a4
    int32_t i_v16 = (int32_t)p_v13; // 0xf3a4
lab_0xf13c:;
    int32_t *p_v17 = calloc(0x1000, 1);                               // 0xf144
    int32_t i_v18 = strlen((char *)function_e1f8((int32_t *)&p_g71)); // 0xf154
    int32_t i_v19; // bp-92, 0xf108
    int32_t i_v20 =
        function_f990((int32_t)p_g17, "port_local", &i_v19); // 0xf16c
    uint32_t i_v21 = strtol((char *)i_v20, NULL, 10);        // 0xf178
    int32_t i_v22;                                           // bp-80, 0xf108
    if (function_e284("eth0", &i_v22) == 0) {
        // 0xf2ec
        puts("get IP error");
    }
    int32_t i_v23 = __asm_sxth(i_v21 % 0x10000);         // 0xf194
    int32_t i_v24 = function_bea4(i_v14, &i_v22, i_v23); // 0xf1a0
    char *p_v25 = (char *)i_v24;                         // 0xf1a4
    if (*p_v25 == 0) {
        // 0xf2dc
        printf("nothing returned form callapi\n\n\n ");
        // 0xf2d4
        return 0;
    }
    // 0xf1b4
    printf("result of callapi:%s\n ", p_v25);
    int32_t i_v26 =
        strlen((char *)function_bc44(i_v15, (int32_t)p_v17, i_v24)) +
        i_v18; // 0xf1dc
    printf("state_len=%d\n", i_v26);
    function_ecd0(i_v16, i_v26);
    i_g106 = i_g108;
    int32_t i_v27; // 0xf108
    if (i_g108 == -1) {
        // 0xf240
        perror("send");
        i_g106 = i_g108;
        i_v27 = i_g108;
        if (i_g108 == -1) {
            // 0xf3a8
            perror("send");
            i_v27 = i_g106;
        }
    } else {
        // 0xf240
        i_g106 = i_g108;
        i_v27 = i_g108;
    }
    // 0xf27c
    printf("sendbytes=%d\n", i_v27);
    printf("send pakge str :%s\n", p_v17);
    if (i_v16 != 0) {
        // 0xf298
        free((int32_t *)i_v16);
    }
    if (i_v15 != 0) {
        // 0xf2a8
        free((int32_t *)i_v15);
    }
    if (i_v14 != 0) {
        // 0xf2b8
        free((int32_t *)i_v14);
    }
    // 0xf2c0
    free((int32_t *)i_v24);
    free(p_v17);
    // 0xf2d4
    return 1;
}

// Address range: 0xf410 - 0xf470
int32_t function_f410(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    int32_t i_v1 = i_a3;                         // bp-8, 0xf424
    int32_t i_v2 = function_feb0(&i_v1, &i_g88); // 0xf434
    int32_t i_v3 =
        function_10004(*(int32_t *)&x_g23, &i_g104, i_a3, i_a4); // 0xf448
    int32_t i_v4 = function_10474(i_v2, i_v3, i_a3, i_a4);       // 0xf454
    function_10210(i_v4, *(int32_t *)&x_g23, i_a3, i_a4);
    return 1;
}

// Address range: 0xf470 - 0xf4c0
int32_t function_f470(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    int32_t i_v1 = i_a3;                         // bp-8, 0xf47c
    int32_t i_v2 = function_feb0(&i_v1, &i_g88); // 0xf48c
    int32_t i_v3 = function_10710(&i_g102);      // 0xf49c
    function_10a34(function_108b4(i_v2, i_v3, i_a3, i_a4), i_v3, i_a3, i_a4);
    return 1;
}

// Address range: 0xf4c0 - 0xf670
int32_t function_f4c0(void) {
    // 0xf4c0
    int32_t i_v1; // bp-212, 0xf4c0
    int32_t i_v2 = function_f990((int32_t)p_g17, "port_local", &i_v1); // 0xf4d8
    int32_t i_v3 = strtol((char *)i_v2, NULL, 10);                     // 0xf4e4
    int32_t i_v4; // bp-184, 0xf4c0
    if (function_e284("eth0", &i_v4) == 0) {
        // 0xf614
        puts("get IP error");
    }
    // 0xf500
    int32_t i_v5; // bp-144, 0xf4c0
    sigemptyset((struct _TYPEDEF_sigset_t *)&i_v5);
    sigaddset((struct _TYPEDEF_sigset_t *)&i_v5, SIGPIPE);
    sigprocmask(SIG_BLOCK, (struct _TYPEDEF_sigset_t *)&i_v5, NULL);
    system("/etc/init.d/cgminer restart");
    sigprocmask(SIG_UNBLOCK, (struct _TYPEDEF_sigset_t *)&i_v5, NULL);
    sleep(5);
    if (gethostbyname((char *)&i_v4) == NULL) {
        // 0xf660
        puts("Failed to resolve host ");
        // 0xf60c
        return 0;
    }
    int32_t i_v6 = socket(AF_INET, SOCK_STREAM, IPPROTO_IP); // 0xf560
    if (i_v6 == -1) {
        // 0xf620
        printf("Socket initialisation failed: %s\n",
               strerror(*__errno_location()));
        // 0xf60c
        return 0;
    }
    // 0xf570
    __asm_ubfx(i_v3, 8, 8);
    int32_t i_v7 = 2; // bp-200, 0xf598
    if (connect(i_v6, (struct sockaddr *)&i_v7, 16) >= 0) {
        // 0xf640
        close(i_v6);
    lab_0xf650:
        // 0xf650
        puts("restart OK!");
        // 0xf60c
        return 1;
    }
    int32_t i_v8 = 6;
    while (i_v8 != 0) {
        // 0xf5b0
        printf("Cgminer!Socket connect failed: %s\n",
               strerror(*__errno_location()));
        puts("restart not well!!\nwait next 5s......");
        sleep(5);
        if (connect(i_v6, (struct sockaddr *)&i_v7, 16) >= 0) {
            // 0xf640
            close(i_v6);
            if (i_v8 < 2) {
                goto lab_0xf600;
            } else {
                goto lab_0xf650;
            }
        }
        i_v8--;
    }
    // 0xf5f8
    close(i_v6);
lab_0xf600:
    // 0xf600
    puts("restart timeout!");
    // 0xf60c
    return 255;
}

// Address range: 0xf69c - 0xf770
int32_t function_f69c(char *p_a1, int32_t *p_a2) {
    int32_t *p_v1 = calloc(60, 1); // 0xf6b0
    char *p_v2 = stpcpy((char *)p_v1,
                        (char *)function_e1f8((int32_t *)&p_g71)); // 0xf6c8
    *(int32_t *)p_v2 = 0x3d4449;
    char *p_v3 = stpcpy((char *)((int32_t)p_v2 + 3), (char *)&p_g92); // 0xf6e4
    int32_t i_v4 = (int32_t)p_v3;                                     // 0xf6e4
    *(int32_t *)p_v3 = 0x7365722c;
    *(int32_t *)(i_v4 + 4) = 0x3d746c75;
    function_ecd0((int32_t)p_a1,
                  (int32_t)stpcpy((char *)(i_v4 + 8), (char *)p_a2) -
                      (int32_t)p_v1);
    i_g106 = i_g108;
    if (i_g108 == -1) {
        // 0xf764
        perror("send");
    }
    // 0xf74c
    printf("send cgminer state :%s\n", p_v1);
    free(p_v1);
    return &i_g125;
}

// Address range: 0xf798 - 0xf838
int32_t function_f798(void) {
    int32_t i_v1 = -0x1a604000; // bp-32, 0xf7b4
    int32_t i_v2;               // bp-16, 0xf798
    function_10fc4(&i_v1, &i_v2);
    int32_t i_v3 = curl_easy_init(curl_global_init(3)); // 0xf7d4
    curl_easy_setopt(i_v3, 0x2712, "www.baidu.com");
    if (fopen("save.txt", "w") == NULL) {
        // 0xf828
        curl_easy_cleanup(i_v3);
        exit(1);
        return &i_g125;
    }
    // 0xf800
    curl_easy_setopt(i_v3, 0x4e2b, (char *)&i_v1);
    curl_easy_perform(i_v3);
    return curl_easy_cleanup(i_v3);
}

// Address range: 0xf84c - 0xf854
int32_t function_f84c(void) {
    // 0xf84c
    return 1;
}

// Address range: 0xf854 - 0xf974
int32_t function_f854(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0xf854
    int32_t i_v1; // 0xf854
    int32_t i_v2; // bp-4128, 0xf854
    char i_v3;    // 0xf854
    if (i_v3 == 48) {
        switch ((char)i_a2) {
        case 49: {
            if (i_v3 == 0) {
                // 0xf93c
                function_edfc("10");
                // 0xf898
                memcpy(&i_v2, &i_v1, 4095);
                function_e7f4(i_a1, i_a2, i_a3, i_a4);
                // 0xf8b4
                return 1;
            }
            // break -> 0xf87c
            break;
        }
        case 54: {
            if (i_v3 == 0) {
                // 0xf8e8
                memcpy(&i_v2, &i_v1, 4095);
                function_f410(i_a1, i_a2, i_a3, i_a4);
                if (function_f4c0() != 1) {
                    // 0xf918
                    function_f69c("60", &i_g11);
                    puts("restart cgminer FAILD ");
                    // 0xf8b4
                    return 0;
                }
                // 0xf960
                function_f69c("60", &i_g10);
                puts("restart cgminer OK OK ");
                // 0xf898
                memcpy(&i_v2, &i_v1, 4095);
                function_e7f4(i_a1, i_a2, i_a3, i_a4);
                // 0xf8b4
                return 1;
            }
            // break -> 0xf87c
            break;
        }
        }
    }
    // 0xf87c
    char i_v4; // bp-13, 0xf854
    if (function_f108(&i_v4) == 0) {
        // 0xf950
        puts("after send_getstatus_res()");
        // 0xf8b4
        return 0;
    }
    // 0xf898
    memcpy(&i_v2, &i_v1, 4095);
    function_e7f4(i_a1, i_a2, i_a3, i_a4);
    // 0xf8b4
    return 1;
}

// Address range: 0xf990 - 0xfa48
int32_t function_f990(int32_t i_a1, char *p_a2, int32_t *p_a3) {
    struct _IO_FILE *p_v1 = fopen((char *)i_a1, "rb+"); // 0xf9a0
    if (p_v1 == NULL) {
        // 0xfa3c
        puts("open error1111");
    }
    // 0xf9ac
    fseek(p_v1, 0, SEEK_END);
    int32_t i_v2 = ftell(p_v1); // 0xf9c0
    int32_t i_v3 = i_v2 == 0 ? 0 : (int32_t)p_a3;
    if (i_v2 != 0) {
        // 0xf9d0
        fseek(p_v1, 0, SEEK_SET);
        int32_t *p_v4 = malloc(i_v2 + 100); // 0xf9e4
        fread(p_v4, 1, i_v2, p_v1);
        fclose(p_v1);
        int32_t i_v5 = function_d9d8((int32_t)p_v4); // 0xfa08
        int32_t i_v6 =
            function_da50(i_v5, (int32_t)p_a2, i_v2, (int32_t)p_v1); // 0xfa14
        strcpy((char *)i_v3, (char *)*(int32_t *)(i_v6 + 16));
        function_d864(i_v5);
        free(p_v4);
    }
    // 0xfa34
    return i_v3;
}

// Address range: 0xfa50 - 0xfa54
int32_t function_fa50(int32_t i_a1, char *p_a2, int32_t *p_a3, int32_t *p_a4) {
    // 0xfa50
    return function_f990(i_a1, p_a2, p_a3);
}

// Address range: 0xfa54 - 0xfc5c
int32_t function_fa54(int32_t i_a1, int32_t i_a2) {
    char *p_v1 = (char *)i_a1;                  // 0xfa68
    struct _IO_FILE *p_v2 = fopen(p_v1, "rb+"); // 0xfa68
    if (p_v2 == NULL) {
        // 0xfc4c
        puts("open error");
        exit(1);
        return &i_g125;
    }
    // 0xfa74
    fseek(p_v2, 0, SEEK_END);
    int32_t i_v3 = ftell(p_v2); // 0xfa84
    if (i_v3 == 0) {
        // 0xfa94
        return 0;
    }
    int32_t i_v4 = (int32_t)p_v2; // 0xfa68
    fseek(p_v2, 0, SEEK_SET);
    int32_t *p_v5 = malloc(i_v3 + 100); // 0xfab0
    fread(p_v5, 1, i_v3, p_v2);
    fclose(p_v2);
    int32_t i_v6 = function_d9d8((int32_t)p_v5); // 0xfad4
    int32_t i_v7 =
        *(int32_t *)(function_da50(i_v6, (int32_t) "api-switch", i_v3, i_v4) +
                     16); // 0xfae4
    int32_t i_v8;         // bp-120, 0xfa54
    strcpy((char *)&i_v8, (char *)i_v7);
    int32_t i_v9 =
        function_da50(i_v6, (int32_t) "api-uid", i_v3, i_v4); // 0xfaf8
    int32_t i_v10;                                            // bp-84, 0xfa54
    strcpy((char *)&i_v10, (char *)*(int32_t *)(i_v9 + 16));
    int32_t i_v11 =
        *(int32_t *)(function_da50(i_v6, (int32_t) "ip_server", i_v3, i_v4) +
                     16); // 0xfb14
    int32_t i_v12;        // bp-104, 0xfa54
    strcpy((char *)&i_v12, (char *)i_v11);
    int32_t i_v13 =
        *(int32_t *)(function_da50(i_v6, (int32_t) "port_server", i_v3, i_v4) +
                     16); // 0xfb2c
    int32_t i_v14;        // bp-144, 0xfa54
    strcpy((char *)&i_v14, (char *)i_v13);
    int32_t i_v15 =
        *(int32_t *)(function_da50(i_v6, (int32_t) "port_local", i_v3, i_v4) +
                     16); // 0xfb44
    int32_t i_v16;        // bp-132, 0xfa54
    strcpy((char *)&i_v16, (char *)i_v15);
    function_d864(i_v6);
    struct _IO_FILE *p_v17 = fopen(p_v1, "w+"); // 0xfb60
    int32_t i_v18 = (int32_t)p_v17;             // 0xfb68
    if (p_v17 == NULL) {
        // 0xfc40
        i_v18 = puts("open error");
    }
    int32_t i_v19 = function_de4c(i_v18, (int32_t) "w+", i_v3, i_v4); // 0xfb6c
    int32_t i_v20 =
        function_de04((int32_t)&i_v8, (int32_t) "w+", i_v3, i_v4); // 0xfb78
    function_dac8(i_v19, (int32_t) "api-switch", i_v20);
    int32_t i_v21 = function_de04((int32_t)&i_v10, (int32_t) "api-switch",
                                  i_v20, i_v4); // 0xfb90
    function_dac8(i_v19, (int32_t) "api-uid", i_v21);
    int32_t i_v22 =
        function_de04(i_a2, (int32_t) "api-uid", i_v21, i_v4); // 0xfba8
    function_dac8(i_v19, (int32_t) "auth", i_v22);
    int32_t i_v23 =
        function_de04((int32_t)&i_v12, (int32_t) "auth", i_v22, i_v4); // 0xfbc0
    function_dac8(i_v19, (int32_t) "ip_server", i_v23);
    int32_t i_v24 = function_de04((int32_t)&i_v14, (int32_t) "ip_server", i_v23,
                                  i_v4); // 0xfbd8
    function_dac8(i_v19, (int32_t) "port_server", i_v24);
    int32_t i_v25 = function_de04((int32_t)&i_v16, (int32_t) "port_server",
                                  i_v24, i_v4); // 0xfbf0
    function_dac8(i_v19, (int32_t) "port_local", i_v25);
    int32_t i_v26 = function_d9e4(i_v19); // 0xfc08
    fputs((char *)i_v26, p_v17);
    fclose(p_v17);
    function_d864(i_v19);
    free((int32_t *)i_v26);
    free(p_v5);
    // 0xfa94
    return 1;
}

// Address range: 0xfc80 - 0xfc84
int32_t function_fc80(int32_t i_a1, int32_t *p_a2, char i_a3, char i_a4) {
    // 0xfc80
    return function_fa54(i_a1, (int32_t)p_a2);
}

// Address range: 0xfc84 - 0xfe88
int32_t function_fc84(int32_t i_a1) {
    char *p_v1 = (char *)i_a1;                  // 0xfc94
    struct _IO_FILE *p_v2 = fopen(p_v1, "rb+"); // 0xfc94
    if (p_v2 == NULL) {
        // 0xfe70
        puts("open error");
    }
    // 0xfca0
    fseek(p_v2, 0, SEEK_END);
    int32_t i_v3 = ftell(p_v2); // 0xfcb4
    if (i_v3 == 0) {
        // 0xfcc4
        return 0;
    }
    int32_t i_v4 = (int32_t)p_v2; // 0xfc94
    fseek(p_v2, 0, SEEK_SET);
    int32_t *p_v5 = malloc(i_v3 + 100); // 0xfce0
    fread(p_v5, 1, i_v3, p_v2);
    fclose(p_v2);
    int32_t i_v6 = function_d9d8((int32_t)p_v5); // 0xfd04
    int32_t i_v7 =
        *(int32_t *)(function_da50(i_v6, (int32_t) "auth", i_v3, i_v4) +
                     16); // 0xfd14
    int32_t i_v8;         // bp-120, 0xfc84
    strcpy((char *)&i_v8, (char *)i_v7);
    int32_t i_v9 =
        function_da50(i_v6, (int32_t) "api-uid", i_v3, i_v4); // 0xfd28
    int32_t i_v10;                                            // bp-84, 0xfc84
    strcpy((char *)&i_v10, (char *)*(int32_t *)(i_v9 + 16));
    int32_t i_v11 =
        *(int32_t *)(function_da50(i_v6, (int32_t) "ip_server", i_v3, i_v4) +
                     16); // 0xfd44
    int32_t i_v12;        // bp-104, 0xfc84
    strcpy((char *)&i_v12, (char *)i_v11);
    int32_t i_v13 =
        *(int32_t *)(function_da50(i_v6, (int32_t) "port_server", i_v3, i_v4) +
                     16); // 0xfd5c
    int32_t i_v14;        // bp-144, 0xfc84
    strcpy((char *)&i_v14, (char *)i_v13);
    int32_t i_v15 =
        *(int32_t *)(function_da50(i_v6, (int32_t) "port_local", i_v3, i_v4) +
                     16); // 0xfd74
    int32_t i_v16;        // bp-132, 0xfc84
    strcpy((char *)&i_v16, (char *)i_v15);
    function_d864(i_v6);
    struct _IO_FILE *p_v17 = fopen(p_v1, "w+"); // 0xfd90
    int32_t i_v18 = (int32_t)p_v17;             // 0xfd98
    if (p_v17 == NULL) {
        // 0xfe7c
        i_v18 = puts("open error");
    }
    int32_t i_v19 = function_de4c(i_v18, (int32_t) "w+", i_v3, i_v4); // 0xfd9c
    int32_t i_v20 =
        function_de04((int32_t) "off", (int32_t) "w+", i_v3, i_v4); // 0xfda8
    function_dac8(i_v19, (int32_t) "api-switch", i_v20);
    int32_t i_v21 = function_de04((int32_t)&i_v10, (int32_t) "api-switch",
                                  i_v20, i_v4); // 0xfdc0
    function_dac8(i_v19, (int32_t) "api-uid", i_v21);
    int32_t i_v22 = function_de04((int32_t)&i_v8, (int32_t) "api-uid", i_v21,
                                  i_v4); // 0xfdd8
    function_dac8(i_v19, (int32_t) "auth", i_v22);
    int32_t i_v23 =
        function_de04((int32_t)&i_v12, (int32_t) "auth", i_v22, i_v4); // 0xfdf0
    function_dac8(i_v19, (int32_t) "ip_server", i_v23);
    int32_t i_v24 = function_de04((int32_t)&i_v14, (int32_t) "ip_server", i_v23,
                                  i_v4); // 0xfe08
    function_dac8(i_v19, (int32_t) "port_server", i_v24);
    int32_t i_v25 = function_de04((int32_t)&i_v16, (int32_t) "port_server",
                                  i_v24, i_v4); // 0xfe20
    function_dac8(i_v19, (int32_t) "port_local", i_v25);
    int32_t i_v26 = function_d9e4(i_v19); // 0xfe38
    fputs((char *)i_v26, p_v17);
    fclose(p_v17);
    function_d864(i_v19);
    free((int32_t *)i_v26);
    free(p_v5);
    // 0xfcc4
    return 1;
}

// Address range: 0xfeb0 - 0xfffc
int32_t function_feb0(int32_t *p_a1, int32_t *p_a2) {
    int32_t i_v1 = (int32_t)p_a2;
    char *p_v2 = strchr((char *)p_a1, 59); // 0xfec4
    *p_v2 = 0;
    strcpy((char *)&p_g92, (char *)p_a1);
    int32_t *p_v3 = (int32_t *)(i_v1 + 492);
    int32_t i_v4 = (int32_t)p_v2 + 1;
    int32_t i_v5 = 0;
    int32_t i_v6 = 0;
    char *p_v7 = (char *)i_v4;     // 0xfef4
    char *p_v8 = strchr(p_v7, 59); // 0xfef4
    int32_t i_v9 = (int32_t)p_v8;  // 0xfef4
    int32_t i_v10 = i_v9;          // 0xfefc
    if (p_v8 != NULL) {
        *p_v8 = 0;
        i_v10 = i_v9 + 1;
    }
    int32_t i_v11; // 0xfeb0
    int32_t i_v12; // 0xfeb0
    int32_t i_v13; // 0xfeb0
    int32_t i_v14; // 0xfeb0
    int32_t i_v15; // 0xfeb0
    int32_t i_v16; // 0xfeb0
    int32_t i_v17; // 0xfeb0
    int32_t i_v18; // 0xfeb0
    int32_t i_v19; // 0xfeb0
    int32_t i_v20; // 0xfeb0
    char *p_v21;   // 0xfeb0
    char *p_v22;   // 0xfeb0
    char *p_v23;   // 0xfeb0
    char *p_v24;   // 0xff28
    char *p_v25;   // 0xff28
    int32_t i_v26; // 0xff28
    int32_t i_v27; // 0xff14
    char *p_v28;   // 0xff1c
    if (*p_v7 != 0) {
        // 0xff0c
        i_v27 = 164 * i_v5 + i_v1;
        p_v28 = (char *)(i_v27 + 124);
        p_v21 = (char *)i_v27;
        p_v22 = (char *)(i_v27 + 84);
        p_v23 = (char *)(i_v27 + 4);
        i_v12 = i_v6;
        i_v11 = i_v4;
        while (true) {
            // 0xff20
            i_v13 = i_v12;
            p_v24 = (char *)i_v11;
            p_v25 = strchr(p_v24, 44);
            i_v26 = (int32_t)p_v25;
            i_v18 = i_v26;
            if (p_v25 != NULL) {
                *p_v25 = 0;
                i_v18 = i_v26 + 1;
            }
            i_v19 = i_v18;
            i_v14 = i_v13;
            if (*p_v24 == 0) {
                goto lab_0xff6c;
            } else {
                // 0xff40
                i_g124 = i_v13;
                switch (i_v13) {
                case 0: {
                    // 0xff7c
                    strcpy(p_v21, p_v24);
                    *p_v3 = *p_v3 + 1;
                    i_v15 = 1;
                    if (i_v19 == 0) {
                        // break -> 0xffa0
                        break;
                    }
                    goto lab_0xff74;
                }
                case 1: {
                    // 0xffcc
                    strcpy(p_v23, p_v24);
                    i_v14 = 2;
                    goto lab_0xff6c;
                }
                case 2: {
                    // 0xffb4
                    strcpy(p_v22, p_v24);
                    i_v14 = 3;
                    goto lab_0xff6c;
                }
                case 3: {
                    // 0xff5c
                    strcpy(p_v28, p_v24);
                    i_v14 = 0;
                    goto lab_0xff6c;
                }
                default: {
                    // 0xffe4
                    puts("Pools Config Data is Wrong");
                    i_v14 = i_v13;
                    goto lab_0xff6c;
                }
                }
            }
        }
        // 0xffa0
        i_v17 = i_v16;
        i_v20 = i_v5 + 1;
    }
    while (i_v10 != 0) {
        // 0xfeec
        i_v4 = i_v10;
        p_v7 = (char *)i_v4;
        p_v8 = strchr(p_v7, 59);
        i_v9 = (int32_t)p_v8;
        i_v10 = i_v9;
        if (p_v8 != NULL) {
            *p_v8 = 0;
            i_v10 = i_v9 + 1;
        }
        if (*p_v7 != 0) {
            // 0xff0c
            i_v27 = 164 * i_v5 + i_v1;
            p_v28 = (char *)(i_v27 + 124);
            p_v21 = (char *)i_v27;
            p_v22 = (char *)(i_v27 + 84);
            p_v23 = (char *)(i_v27 + 4);
            i_v12 = i_v6;
            i_v11 = i_v4;
            while (true) {
                // 0xff20
                i_v13 = i_v12;
                p_v24 = (char *)i_v11;
                p_v25 = strchr(p_v24, 44);
                i_v26 = (int32_t)p_v25;
                i_v18 = i_v26;
                if (p_v25 != NULL) {
                    *p_v25 = 0;
                    i_v18 = i_v26 + 1;
                }
                i_v19 = i_v18;
                i_v14 = i_v13;
                if (*p_v24 == 0) {
                    goto lab_0xff6c;
                } else {
                    // 0xff40
                    i_g124 = i_v13;
                    switch (i_v13) {
                    case 0: {
                        // 0xff7c
                        strcpy(p_v21, p_v24);
                        *p_v3 = *p_v3 + 1;
                        i_v15 = 1;
                        if (i_v19 == 0) {
                            // break -> 0xffa0
                            break;
                        }
                        goto lab_0xff74;
                    }
                    case 1: {
                        // 0xffcc
                        strcpy(p_v23, p_v24);
                        i_v14 = 2;
                        goto lab_0xff6c;
                    }
                    case 2: {
                        // 0xffb4
                        strcpy(p_v22, p_v24);
                        i_v14 = 3;
                        goto lab_0xff6c;
                    }
                    case 3: {
                        // 0xff5c
                        strcpy(p_v28, p_v24);
                        i_v14 = 0;
                        goto lab_0xff6c;
                    }
                    default: {
                        // 0xffe4
                        puts("Pools Config Data is Wrong");
                        i_v14 = i_v13;
                        goto lab_0xff6c;
                    }
                    }
                }
            }
            // 0xffa0
            i_v17 = i_v16;
            i_v20 = i_v5 + 1;
        }
    }
    // 0xfff0
    return i_v1;
lab_0xff6c:
    // 0xff6c
    i_v15 = i_v14;
    if (i_v19 == 0) {
        // break -> 0xffa0
        goto lab_0xffa0;
    }
    goto lab_0xff74;
lab_0xff74:
    // 0xff74
    i_v12 = i_v15;
    i_v11 = i_v19;
    goto lab_0xff20;
}

// Address range: 0x10004 - 0x101dc
int32_t function_10004(int32_t i_a1, int32_t *p_a2, int32_t i_a3,
                       int32_t i_a4) {
    struct _IO_FILE *p_v1 = fopen((char *)i_a1, "rb+"); // 0x10010
    if (p_v1 == NULL) {
        // 0x101d0
        puts("open error");
    }
    // 0x1001c
    fseek(p_v1, 0, SEEK_END);
    int32_t i_v2 = ftell(p_v1); // 0x10030
    int32_t i_v3 = i_v2 == 0 ? 0 : (int32_t)p_a2;
    if (i_v2 == 0) {
        // 0x101c8
        return i_v3;
    }
    int32_t i_v4 = (int32_t)p_v1; // 0x10010
    fseek(p_v1, 0, SEEK_SET);
    int32_t *p_v5 = malloc(i_v2 + 100); // 0x10054
    fread(p_v5, 1, i_v2, p_v1);
    fclose(p_v1);
    int32_t i_v6 = function_d9d8((int32_t)p_v5); // 0x10078
    int32_t i_v7 =
        function_da50(i_v6, (int32_t) "pools", i_v2, i_v4); // 0x10084
    function_d9fc(i_v7);
    int32_t i_v8 = *(int32_t *)(i_v7 + 8); // 0x10090
    int32_t i_v9 = i_v8;                   // 0x100a0
    int32_t i_v10 = 0;                     // 0x100a0
    if (i_v8 != 0) {
        int32_t i_v11 =
            function_da50(i_v9, (int32_t) "url", i_v2, i_v4);     // 0x100ac
        int32_t i_v12;                                            // 0x10004
        int32_t i_v13 = i_v10 * (i_v8 == 0 ? i_v12 : 164) + i_v3; // 0x100b8
        strcpy((char *)(i_v13 + 4), (char *)*(int32_t *)(i_v11 + 16));
        int32_t i_v14 =
            *(int32_t *)(function_da50(i_v9, (int32_t) "user", i_v2, i_v4) +
                         16); // 0x100e8
        strcpy((char *)(i_v13 + 84), (char *)i_v14);
        int32_t i_v15 =
            *(int32_t *)(function_da50(i_v9, (int32_t) "pass", i_v2, i_v4) +
                         16); // 0x10100
        strcpy((char *)(i_v13 + 124), (char *)i_v15);
        i_v9 = *(int32_t *)i_v9;
        i_v10++;
        while (i_v9 != 0) {
            // 0x100a4
            i_v11 = function_da50(i_v9, (int32_t) "url", i_v2, i_v4);
            i_v13 = i_v10 * (i_v8 == 0 ? i_v12 : 164) + i_v3;
            strcpy((char *)(i_v13 + 4), (char *)*(int32_t *)(i_v11 + 16));
            i_v14 =
                *(int32_t *)(function_da50(i_v9, (int32_t) "user", i_v2, i_v4) +
                             16);
            strcpy((char *)(i_v13 + 84), (char *)i_v14);
            i_v15 =
                *(int32_t *)(function_da50(i_v9, (int32_t) "pass", i_v2, i_v4) +
                             16);
            strcpy((char *)(i_v13 + 124), (char *)i_v15);
            i_v9 = *(int32_t *)i_v9;
            i_v10++;
        }
    }
    int32_t i_v16 =
        *(int32_t *)(function_da50(i_v6, (int32_t) "api-listen", i_v2, i_v4) +
                     20); // 0x10128
    *(int32_t *)(i_v3 + 492) = i_v16;
    int32_t i_v17 =
        *(int32_t *)(function_da50(i_v6, (int32_t) "api-network", i_v2, i_v16) +
                     20); // 0x1013c
    *(int32_t *)(i_v3 + 496) = i_v17;
    int32_t i_v18 =
        *(int32_t *)(function_da50(i_v6, (int32_t) "bitmain-nobeeper", i_v2,
                                   i_v17) +
                     20); // 0x10150
    *(int32_t *)(i_v3 + 500) = i_v18;
    int32_t i_v19 = function_da50(i_v6, (int32_t) "bitmain-notempoverctrl",
                                  i_v2, i_v18); // 0x1015c
    int32_t i_v20 = *(int32_t *)(i_v19 + 20);   // 0x10164
    *(int32_t *)(i_v3 + 504) = i_v20;
    int32_t i_v21 =
        *(int32_t *)(function_da50(i_v6, (int32_t) "api-allow", i_v2, i_v20) +
                     16); // 0x10174
    strcpy((char *)(i_v3 + 508), (char *)i_v21);
    int32_t i_v22 = *(
        int32_t *)(function_da50(i_v6, (int32_t) "bitmain-freq", i_v2, i_v20) +
                   16); // 0x1018c
    strcpy((char *)(i_v3 + 518), (char *)i_v22);
    int32_t i_v23 =
        *(int32_t *)(function_da50(i_v6, (int32_t) "bitmain-voltage", i_v2,
                                   i_v20) +
                     16); // 0x101a8
    strcpy((char *)(i_v3 + 533), (char *)i_v23);
    free(p_v5);
    function_d864(i_v6);
    // 0x101c8
    return i_v3;
}

// Address range: 0x10210 - 0x10440
int32_t function_10210(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    struct _IO_FILE *p_v1 = fopen((char *)i_a2, "w+"); // 0x10220
    int32_t i_v2 = (int32_t)p_v1;                      // 0x10228
    if (p_v1 == NULL) {
        // 0x10434
        i_v2 = puts("open error");
    }
    int32_t i_v3 = function_de4c(i_v2, (int32_t) "w+", i_a3, i_a4); // 0x1022c
    int32_t i_v4 = function_de34(i_v3, (int32_t) "w+", i_a3, i_a4); // 0x1023c
    int32_t i_v5 = function_dac8(i_v3, (int32_t) "pools", i_v4);    // 0x10250
    int32_t i_v6 = 0;
    int32_t i_v7 =
        function_de4c(i_v5, (int32_t) "pools", i_v4, i_a4); // 0x10254
    int32_t i_v8 = i_v6 + 1;                                // 0x1025c
    function_da90(i_v4, i_v7);
    int32_t i_v9 = 164 * i_v6 + i_a1;                          // 0x10270
    int32_t i_v10 = function_de04(i_v9 + 4, i_v7, i_v4, i_a4); // 0x10278
    function_dac8(i_v7, (int32_t) "url", i_v10);
    int32_t i_v11 =
        function_de04(i_v9 + 84, (int32_t) "url", i_v10, i_a4); // 0x10294
    function_dac8(i_v7, (int32_t) "user", i_v11);
    int32_t i_v12 =
        function_de04(i_v9 + 124, (int32_t) "user", i_v11, i_a4); // 0x102b0
    i_v5 = function_dac8(i_v7, (int32_t) "pass", i_v12);
    int32_t i_v13 = (int32_t) "pass"; // 0x102c8
    while (i_v8 != 3) {
        // 0x10254
        i_v6 = i_v8;
        i_v7 = function_de4c(i_v5, i_v13, i_v12, i_a4);
        i_v8 = i_v6 + 1;
        function_da90(i_v4, i_v7);
        i_v9 = 164 * i_v6 + i_a1;
        i_v10 = function_de04(i_v9 + 4, i_v7, i_v12, i_a4);
        function_dac8(i_v7, (int32_t) "url", i_v10);
        i_v11 = function_de04(i_v9 + 84, (int32_t) "url", i_v10, i_a4);
        function_dac8(i_v7, (int32_t) "user", i_v11);
        i_v12 = function_de04(i_v9 + 124, (int32_t) "user", i_v11, i_a4);
        i_v5 = function_dac8(i_v7, (int32_t) "pass", i_v12);
        i_v13 = (int32_t) "pass";
    }
    int32_t i_v14 = i_v5;             // 0x10210
    int32_t i_v15 = (int32_t) "pass"; // 0x10210
    int32_t i_v16 = i_v12;            // 0x1041c
    int32_t i_v17;                    // 0x10210
    int32_t i_v18;                    // 0x10210
    int32_t i_v19;                    // 0x10210
    int32_t i_v20;                    // 0x10210
    int32_t i_v21;                    // 0x10210
    int32_t i_v22;                    // 0x10210
    int32_t i_v23;                    // 0x10210
    switch (*(int32_t *)(i_a1 + 492)) {
    case 1: {
        // 0x1041c
        i_v16 = function_dd80(i_v5, (int32_t) "pass", i_v12, 1);
        i_v14 = function_dac8(i_v3, (int32_t) "api-listen", i_v16);
        i_v15 = (int32_t) "api-listen";
        goto lab_0x102e0;
    }
    case 0: {
        int32_t i_v24 =
            function_dd98(i_v5, (int32_t) "pass", i_v12, 0); // 0x1038c
        int32_t i_v25 =
            function_dac8(i_v3, (int32_t) "api-listen", i_v24); // 0x1039c
        int32_t i_v26 = *(int32_t *)(i_a1 + 496);               // 0x103a0
        i_v17 = i_v25;
        i_v19 = (int32_t) "api-listen";
        i_v21 = i_v24;
        i_v23 = i_v26;
        i_v18 = i_v25;
        i_v20 = (int32_t) "api-listen";
        i_v22 = i_v24;
        if (i_v26 == 1) {
            goto lab_0x103ac;
        } else {
            goto lab_0x102ec;
        }
    }
    default: {
        goto lab_0x102e0;
    }
    }
lab_0x102e0:;
    int32_t i_v27 = *(int32_t *)(i_a1 + 496); // 0x102e0
    i_v17 = i_v14;
    i_v19 = i_v15;
    i_v21 = i_v16;
    i_v23 = i_v27;
    i_v18 = i_v14;
    i_v20 = i_v15;
    i_v22 = i_v16;
    if (i_v27 == 1) {
        goto lab_0x103ac;
    } else {
        goto lab_0x102ec;
    }
lab_0x103ac:;
    int32_t i_v28 = function_dd80(i_v18, i_v20, i_v22, 1); // 0x103ac
    int32_t i_v29 =
        function_dac8(i_v3, (int32_t) "api-network", i_v28); // 0x103bc
    int32_t i_v30 = i_v29;                                   // 0x103c8
    int32_t i_v31 = (int32_t) "api-network";                 // 0x103c8
    int32_t i_v32 = i_v28;                                   // 0x103c8
    int32_t i_v33 = i_v29;                                   // 0x103c8
    int32_t i_v34 = (int32_t) "api-network";                 // 0x103c8
    int32_t i_v35 = i_v28;                                   // 0x103c8
    if (*(int32_t *)(i_a1 + 500) == 1) {
        goto lab_0x103cc;
    } else {
        goto lab_0x10300;
    }
lab_0x102ec:;
    int32_t i_v36 = i_v17; // 0x102f0
    int32_t i_v37 = i_v19; // 0x102f0
    int32_t i_v38 = i_v21; // 0x102f0
    if (i_v23 == 0) {
        int32_t i_v39 = function_dd98(i_v17, i_v19, i_v21, 0); // 0x10404
        i_v36 = function_dac8(i_v3, (int32_t) "api-network", i_v39);
        i_v37 = (int32_t) "api-network";
        i_v38 = i_v39;
    }
    // 0x102f4
    i_v30 = i_v36;
    i_v31 = i_v37;
    i_v32 = i_v38;
    i_v33 = i_v36;
    i_v34 = i_v37;
    i_v35 = i_v38;
    if (*(int32_t *)(i_a1 + 500) == 1) {
        goto lab_0x103cc;
    } else {
        goto lab_0x10300;
    }
lab_0x103cc:;
    int32_t i_v40 = function_dd80(i_v33, i_v34, i_v35, 1); // 0x103cc
    int32_t i_v41 =
        function_dac8(i_v3, (int32_t) "bitmain-nobeeper", i_v40); // 0x103dc
    int32_t i_v42 = *(int32_t *)(i_a1 + 504);                     // 0x103e0
    int32_t i_v43 = (int32_t) "bitmain-nobeeper";                 // 0x103e8
    int32_t i_v44 = i_v40;                                        // 0x103e8
    int32_t i_v45 = i_v42;                                        // 0x103e8
    int32_t i_v46 = i_v41;                                        // 0x103e8
    int32_t i_v47 = (int32_t) "bitmain-nobeeper";                 // 0x103e8
    int32_t i_v48 = i_v40;                                        // 0x103e8
    if (i_v42 == 1) {
        goto lab_0x103ec;
    } else {
        goto lab_0x1030c;
    }
lab_0x10300:;
    int32_t i_v49 = *(int32_t *)(i_a1 + 504); // 0x10300
    i_v43 = i_v31;
    i_v44 = i_v32;
    i_v45 = i_v49;
    i_v46 = i_v30;
    i_v47 = i_v31;
    i_v48 = i_v32;
    if (i_v49 == 1) {
        goto lab_0x103ec;
    } else {
        goto lab_0x1030c;
    }
lab_0x103ec:;
    int32_t i_v50 = function_dd80(i_v46, i_v47, i_v48, 1); // 0x103ec
    function_dac8(i_v3, (int32_t) "bitmain-notempoverctrl", i_v50);
    i_v43 = (int32_t) "bitmain-notempoverctrl";
    i_v44 = i_v50;
    i_v45 = 1;
    goto lab_0x1030c;
lab_0x1030c:;
    int32_t i_v51 = function_de04(i_a1 + 508, i_v43, i_v44, i_v45); // 0x10310
    function_dac8(i_v3, (int32_t) "api-allow", i_v51);
    int32_t i_v52 = function_de04(i_a1 + 518, (int32_t) "api-allow", i_v51,
                                  i_v45); // 0x1032c
    function_dac8(i_v3, (int32_t) "bitmain-freq", i_v52);
    function_dac8(
        i_v3, (int32_t) "bitmain-voltage",
        function_de04(i_a1 + 533, (int32_t) "bitmain-freq", i_v52, i_v45));
    int32_t i_v53 = function_d9e4(i_v3); // 0x10360
    fputs((char *)i_v53, p_v1);
    fclose(p_v1);
    function_d864(i_v3);
    free((int32_t *)i_v53);
    return &i_g125;
}

// Address range: 0x10474 - 0x1070c
int32_t function_10474(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    int32_t *p_v1 = (int32_t *)(i_a1 + 492); // 0x10484
    printf("change->pools_count = %d\n", *p_v1);
    switch (*p_v1) {
    case 1: {
        // 0x10524
        switch (strtol((char *)i_a1, NULL, 10)) {
        case 1: {
            // 0x10644
            strcpy((char *)(i_a2 + 168), (char *)(i_a1 + 4));
            strcpy((char *)(i_a2 + 248), (char *)(i_a1 + 84));
            strcpy((char *)(i_a2 + 288), (char *)(i_a1 + 124));
            // break -> 0x104a8
            break;
        }
        case 2: {
            // 0x1061c
            strcpy((char *)(i_a2 + 332), (char *)(i_a1 + 4));
            strcpy((char *)(i_a2 + 412), (char *)(i_a1 + 84));
            strcpy((char *)(i_a2 + 452), (char *)(i_a1 + 124));
            // break -> 0x104a8
            break;
        }
        case 0: {
            // 0x1054c
            strcpy((char *)(i_a2 + 4), (char *)(i_a1 + 4));
            strcpy((char *)(i_a2 + 84), (char *)(i_a1 + 84));
            strcpy((char *)(i_a2 + 124), (char *)(i_a1 + 124));
            // break -> 0x104a8
            break;
        }
        }
        // 0x104a8
        return i_a2;
    }
    case 2: {
        int32_t i_v2 = strtol((char *)i_a1, NULL, 10);         // 0x10580
        int32_t i_v3 = strtol((char *)(i_a1 + 164), NULL, 10); // 0x10594
        switch (i_v2) {
        case 1: {
            // 0x106e4
            strcpy((char *)(i_a2 + 168), (char *)(i_a1 + 4));
            strcpy((char *)(i_a2 + 248), (char *)(i_a1 + 84));
            strcpy((char *)(i_a2 + 288), (char *)(i_a1 + 124));
            // break -> 0x105b4
            break;
        }
        case 2: {
            // 0x106bc
            strcpy((char *)(i_a2 + 332), (char *)(i_a1 + 4));
            strcpy((char *)(i_a2 + 412), (char *)(i_a1 + 84));
            strcpy((char *)(i_a2 + 452), (char *)(i_a1 + 124));
            // break -> 0x105b4
            break;
        }
        case 0: {
            // 0x105f4
            strcpy((char *)(i_a2 + 4), (char *)(i_a1 + 4));
            strcpy((char *)(i_a2 + 84), (char *)(i_a1 + 84));
            strcpy((char *)(i_a2 + 124), (char *)(i_a1 + 124));
            // break -> 0x105b4
            break;
        }
        }
        switch (i_v3) {
        case 1: {
            // 0x10694
            strcpy((char *)(i_a2 + 168), (char *)(i_a1 + 168));
            strcpy((char *)(i_a2 + 248), (char *)(i_a1 + 248));
            strcpy((char *)(i_a2 + 288), (char *)(i_a1 + 288));
            // break -> 0x104a8
            break;
        }
        case 2: {
            // 0x1066c
            strcpy((char *)(i_a2 + 332), (char *)(i_a1 + 168));
            strcpy((char *)(i_a2 + 412), (char *)(i_a1 + 248));
            strcpy((char *)(i_a2 + 452), (char *)(i_a1 + 288));
            // break -> 0x104a8
            break;
        }
        case 0: {
            // 0x105cc
            strcpy((char *)(i_a2 + 4), (char *)(i_a1 + 168));
            strcpy((char *)(i_a2 + 84), (char *)(i_a1 + 248));
            strcpy((char *)(i_a2 + 124), (char *)(i_a1 + 288));
            // break -> 0x104a8
            break;
        }
        }
        // break -> 0x104a8
        break;
    }
    case 3: {
        // 0x104b0
        strcpy((char *)(i_a2 + 4), (char *)(i_a1 + 4));
        strcpy((char *)(i_a2 + 84), (char *)(i_a1 + 84));
        strcpy((char *)(i_a2 + 124), (char *)(i_a1 + 124));
        strcpy((char *)(i_a2 + 168), (char *)(i_a1 + 168));
        strcpy((char *)(i_a2 + 248), (char *)(i_a1 + 248));
        strcpy((char *)(i_a2 + 288), (char *)(i_a1 + 288));
        strcpy((char *)(i_a2 + 332), (char *)(i_a1 + 332));
        strcpy((char *)(i_a2 + 412), (char *)(i_a1 + 412));
        strcpy((char *)(i_a2 + 452), (char *)(i_a1 + 452));
        return i_a2;
    }
    }
    // 0x104a8
    return i_a2;
}

// Address range: 0x10710 - 0x108b4
int32_t function_10710(int32_t *p_a1) {
    int32_t i_v1 = (int32_t)p_a1;
    strcpy((char *)(i_v1 + 4), (char *)function_ba78("pool1url"));
    strcpy((char *)(i_v1 + 84), (char *)function_ba78("pool1user"));
    strcpy((char *)(i_v1 + 124), (char *)function_ba78("pool1pw"));
    strcpy((char *)(i_v1 + 168), (char *)function_ba78("pool2url"));
    strcpy((char *)(i_v1 + 248), (char *)function_ba78("pool2user"));
    strcpy((char *)(i_v1 + 288), (char *)function_ba78("pool2pw"));
    strcpy((char *)(i_v1 + 332), (char *)function_ba78("pool3url"));
    strcpy((char *)(i_v1 + 412), (char *)function_ba78("pool3user"));
    strcpy((char *)(i_v1 + 452), (char *)function_ba78("pool3pw"));
    strcpy((char *)(i_v1 + 492), (char *)function_ba78("api_allow"));
    strcpy((char *)(i_v1 + 512), (char *)function_ba78("more_options"));
    strcpy((char *)(i_v1 + 522), (char *)function_ba78("freq"));
    strcpy((char *)(i_v1 + 537), (char *)function_ba78("voltage"));
    strcpy((char *)(i_v1 + 547), (char *)function_ba78("pool_balance"));
    strcpy((char *)(i_v1 + 557), (char *)function_ba78("bitmain_nobeeper"));
    strcpy((char *)(i_v1 + 567),
           (char *)function_ba78("bitmain_notempoverctrl"));
    return i_v1;
}

// Address range: 0x108b4 - 0x10a34
int32_t function_108b4(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x108b4
    switch (*(int32_t *)(i_a1 + 492)) {
    case 1: {
        int32_t i_v1 = 164 * strtol((char *)i_a1, NULL, 10) + i_a2; // 0x10970
        strcpy((char *)(i_v1 + 4), (char *)(i_a1 + 4));
        strcpy((char *)(i_v1 + 84), (char *)(i_a1 + 84));
        strcpy((char *)(i_v1 + 124), (char *)(i_a1 + 124));
        // break -> 0x108dc
        break;
    }
    case 2: {
        int32_t i_v2 = strtol((char *)i_a1, NULL, 10);         // 0x109a8
        int32_t i_v3 = strtol((char *)(i_a1 + 164), NULL, 10); // 0x109c0
        int32_t i_v4 = 164 * i_v2 + i_a2;                      // 0x109d0
        strcpy((char *)(i_v4 + 4), (char *)(i_a1 + 4));
        strcpy((char *)(i_v4 + 84), (char *)(i_a1 + 84));
        strcpy((char *)(i_v4 + 124), (char *)(i_a1 + 124));
        int32_t i_v5 = 164 * i_v3 + i_a2; // 0x10a00
        strcpy((char *)(i_v5 + 4), (char *)(i_a1 + 168));
        strcpy((char *)(i_v5 + 84), (char *)(i_a1 + 248));
        strcpy((char *)(i_v5 + 124), (char *)(i_a1 + 288));
        // break -> 0x108dc
        break;
    }
    case 3: {
        // 0x108e4
        strcpy((char *)(i_a2 + 4), (char *)(i_a1 + 4));
        strcpy((char *)(i_a2 + 84), (char *)(i_a1 + 84));
        strcpy((char *)(i_a2 + 124), (char *)(i_a1 + 124));
        strcpy((char *)(i_a2 + 168), (char *)(i_a1 + 168));
        strcpy((char *)(i_a2 + 248), (char *)(i_a1 + 248));
        strcpy((char *)(i_a2 + 288), (char *)(i_a1 + 288));
        strcpy((char *)(i_a2 + 332), (char *)(i_a1 + 332));
        strcpy((char *)(i_a2 + 412), (char *)(i_a1 + 412));
        strcpy((char *)(i_a2 + 452), (char *)(i_a1 + 452));
        return i_a2;
    }
    }
    // 0x108dc
    return i_a2;
}

// Address range: 0x10a34 - 0x10ba8
int32_t function_10a34(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    struct _IO_FILE *p_v1 = fopen(p_g47, "rb+"); // 0x10a48
    if (p_v1 == NULL) {
        // 0x10b9c
        puts("open error");
    }
    // 0x10a54
    fwrite((int32_t *)"config cgminer 'default'\n", 1, 25, p_v1);
    fprintf(p_v1, "  option pool1url  '%s'\n", (char *)(i_a1 + 4));
    fprintf(p_v1, "\toption pool1user '%s'\n", (char *)(i_a1 + 84));
    fprintf(p_v1, "\toption pool1pw   '%s'\n", (char *)(i_a1 + 124));
    fprintf(p_v1, "\toption pool2url  '%s'\n", (char *)(i_a1 + 168));
    fprintf(p_v1, "\toption pool2user '%s'\n", (char *)(i_a1 + 248));
    fprintf(p_v1, "\toption pool2pw   '%s'\n", (char *)(i_a1 + 288));
    fprintf(p_v1, "\toption pool3url  '%s'\n", (char *)(i_a1 + 332));
    fprintf(p_v1, "\toption pool3user '%s'\n", (char *)(i_a1 + 412));
    fprintf(p_v1, "\toption pool3pw   '%s'\n", (char *)(i_a1 + 452));
    fprintf(p_v1, "\toption api_allow  '%s'\n", (char *)(i_a1 + 492));
    fprintf(p_v1, "\toption more_options '%s'\n", (char *)(i_a1 + 512));
    fprintf(p_v1, "\toption freq   '%s'\n", (char *)(i_a1 + 522));
    fprintf(p_v1, "\toption voltage   '%s'\n", (char *)(i_a1 + 537));
    fprintf(p_v1, "\toption pool_balance '%s'\n", (char *)(i_a1 + 547));
    fprintf(p_v1, "\toption bitmain_nobeeper   '%s'\n", (char *)(i_a1 + 557));
    fprintf(p_v1, "\toption bitmain_notempoverctrl '%s'\n",
            (char *)(i_a1 + 567));
    fwrite((int32_t *)"\t           ", 1, 12, p_v1);
    return fclose(p_v1);
}

// Address range: 0x10bfc - 0x10c78
int32_t function_10bfc(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    struct _IO_FILE *p_v1 = fopen("/etc/config/auth_tmp.txt", "w+"); // 0x10c0c
    if (p_v1 == NULL) {
        // 0x10c70
        return -1;
    }
    int32_t i_v2; // 0x10bfc
    if ((char)i_v2 != 102 || *(char *)(i_a1 + 1) != 53 ||
        *(char *)(i_a1 + 2) != 0) {
        // 0x10c4c
        fwrite((int32_t *)"fx", 1, 2, p_v1);
        // 0x10c60
        fclose(p_v1);
        return 1;
    }
    // 0x10c3c
    fputs((char *)i_a1, p_v1);
    // 0x10c60
    fclose(p_v1);
    return 1;
}

// Address range: 0x10c84 - 0x10ca8
int32_t function_10c84(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x10c84
    if (i_g26 == 1) {
        // 0x10c94
        return SSL_read();
    }
    // 0x10ca0
    return -1;
}

// Address range: 0x10cac - 0x10cd0
int32_t function_10cac(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x10cac
    if (i_g26 == 1) {
        // 0x10cbc
        return SSL_write();
    }
    // 0x10cc8
    return -1;
}

// Address range: 0x10cd4 - 0x10d00
int32_t function_10cd4(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x10cd4
    if (i_g26 == 1) {
        // 0x10ce4
        return recv(i_a2, (int32_t *)i_a3, i_a4, 0);
    }
    // 0x10cf8
    return -1;
}

// Address range: 0x10d04 - 0x10d30
int32_t function_10d04(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x10d04
    if (i_g26 == 1) {
        // 0x10d14
        return send(i_a2, (int32_t *)i_a3, i_a4, 0);
    }
    // 0x10d28
    return -1;
}

// Address range: 0x10d34 - 0x10d68
int32_t function_10d34(int32_t i_a1, int32_t i_a2, int32_t i_a3,
                       int32_t *p_a4) {
    int32_t *p_v1 = malloc(8);    // 0x10d3c
    int32_t i_v2 = (int32_t)p_v1; // 0x10d3c
    if (p_v1 == NULL) {
        // 0x10d64
        exit(i_v2);
        return &i_g125;
    }
    // 0x10d48
    *(int32_t *)(i_v2 + 4) = 0;
    i_g64 = 0;
    i_g60 = i_v2;
    return i_v2;
}

// Address range: 0x10d70 - 0x10d80
int32_t function_10d70(int32_t i_a1) {
    uint32_t i_v1 = *(int32_t *)(i_a1 + 4); // 0x10d70
    return (i_v1 > 1 ? i_v1 : 1) - i_v1;
}

// Address range: 0x10d80 - 0x10d90
int32_t function_10d80(int32_t i_a1) {
    uint32_t i_v1 = *(int32_t *)(i_a1 + 4); // 0x10d80
    return (i_v1 > 1 ? i_v1 : 1) - i_v1;
}

// Address range: 0x10d90 - 0x10ddc
int32_t function_10d90(int32_t *p_a1, int32_t i_a2, int32_t i_a3,
                       int32_t i_a4) {
    int32_t i_v1 = *(int32_t *)(i_a2 + 4); // 0x10d94
    if (i_v1 == 0) {
        // 0x10dd4
        return 0;
    }
    int32_t i_v2 = i_v1;             // 0x10da8
    int32_t i_v3 = *(int32_t *)i_v2; // 0x10db8
    int32_t i_v4 = i_v2;             // 0x10dd0
    while (strcmp((char *)(i_v3 + 0x1008), (char *)((int32_t)p_a1 + 0x1008)) !=
           0) {
        // 0x10dac
        i_v2 += 4;
        i_v4 = 0;
        if (i_v2 == 0) {
            // break -> 0x10dd4
            break;
        }
        i_v3 = *(int32_t *)i_v2;
        i_v4 = i_v2;
    }
    // 0x10dd4
    return i_v4;
}

// Address range: 0x10ddc - 0x10e24
int32_t function_10ddc(int32_t i_a1, int32_t i_a2) {
    int32_t i_v1 = i_a2;
    int32_t i_v2 = *(int32_t *)(i_v1 + 4); // 0x10df4
    while (i_v2 != 0) {
        // 0x10e04
        if (strcmp((char *)(*(int32_t *)i_v2 + 0x1008),
                   (char *)(i_a1 + 0x1008)) == 0) {
            // break -> 0x10e1c
            break;
        }
        i_v1 = i_v2;
        i_v2 = *(int32_t *)(i_v1 + 4);
    }
    // 0x10e1c
    return i_v1;
}

// Address range: 0x10e24 - 0x10e88
int32_t function_10e24(void) {
    // 0x10e24
    int32_t i_v1;                                                // 0x10e24
    int32_t *p_v2 = (int32_t *)(function_10ddc(i_v1, i_v1) + 4); // 0x10e2c
    int32_t i_v3 = *p_v2;                                        // 0x10e2c
    if (i_v3 == 0) {
        // 0x10e7c
        return puts("there is no cmd for this response.");
    }
    int32_t *p_v4 = (int32_t *)i_v3; // 0x10e3c
    int32_t i_v5 = *p_v4;            // 0x10e3c
    *p_v2 = *(int32_t *)(i_v3 + 4);
    printf("delete one cmd:%s,nonce:%s.\n", (char *)(i_v5 + 3),
           (char *)(i_v5 + 0x1008));
    free((int32_t *)*p_v4);
    free(p_v4);
    i_g64--;
    return &i_g125;
}

// Address range: 0x10e94 - 0x10ec0
int32_t function_10e94(int32_t i_a1, int32_t i_a2) {
    // 0x10e94
    if (i_a2 == 0) {
        // 0x10eb8
        return 0;
    }
    int32_t i_v1 = i_a2; // 0x10e98
    int32_t i_v2 = i_v1; // 0x10eb4
    while (*(int32_t *)i_v1 != i_a1) {
        // 0x10ea0
        i_v1 += 4;
        i_v2 = 0;
        if (i_v1 == 0) {
            // break -> 0x10eb8
            break;
        }
        i_v2 = i_v1;
    }
    // 0x10eb8
    return i_v2;
}

// Address range: 0x10ec0 - 0x10f40
int32_t function_10ec0(int32_t *p_a1, int32_t i_a2, int32_t i_a3,
                       int32_t *p_a4) {
    int32_t *p_v1 = malloc(8);    // 0x10ed0
    int32_t i_v2 = (int32_t)p_v1; // 0x10ed0
    if (p_v1 == NULL) {
        // 0x10f3c
        exit(i_v2);
        return &i_g125;
    }
    int32_t i_v3 = (int32_t)p_a1;
    int32_t i_v4 = (int32_t)malloc(0x100f); // 0x10ee0
    strcpy((char *)(i_v4 + 3), (char *)(i_v3 + 3));
    char *p_v5 =
        strcpy((char *)(i_v4 + 0x1008), (char *)(i_v3 + 0x1008)); // 0x10f04
    int32_t *p_v6 = (int32_t *)(i_a3 + 4);                        // 0x10f0c
    *p_v1 = i_v4;
    *(int32_t *)(i_v2 + 4) = *p_v6;
    int32_t i_v7 = i_g64 + 1; // 0x10f1c
    *p_v6 = i_v2;
    i_g64 = i_v7;
    if (i_v7 < 21) {
        return (int32_t)p_v5;
    }
    // 0x10f30
    return puts("L_cmd is full!");
}

// Address range: 0x10f48 - 0x10f88
int32_t function_10f48(int32_t i_a1) {
    int32_t *p_v1 = (int32_t *)(i_a1 + 4); // 0x10f50
    int32_t i_v2 = *p_v1;                  // 0x10f50
    *p_v1 = 0;
    int32_t i_v3 = i_v2; // 0x10f60
    if (i_v2 == 0) {
        // 0x10f7c
        free((int32_t *)i_a1);
        return &i_g125;
    }
    int32_t *p_v4 = (int32_t *)i_v3; // 0x10f64
    i_v3 += 4;
    free((int32_t *)*p_v4);
    free(p_v4);
    while (i_v3 != 0) {
        // 0x10f64
        p_v4 = (int32_t *)i_v3;
        i_v3 += 4;
        free((int32_t *)*p_v4);
        free(p_v4);
    }
    // 0x10f7c
    free((int32_t *)i_a1);
    return &i_g125;
}

// Address range: 0x10f88 - 0x10f8c
int32_t function_10f88(void) {
    // 0x10f88
    int32_t i_v1; // 0x10f88
    return i_v1;
}

// Address range: 0x10f8c - 0x10f9c
int32_t function_10f8c(int32_t i_a1) {
    // 0x10f8c
    return *(int32_t *)(i_a1 + 4);
}

// Address range: 0x10f9c - 0x10fb0
int32_t function_10f9c(int32_t i_a1) {
    if (i_a1 == 0) {
        // 0x10fac
        return 0;
    }
    // 0x10fa4
    return *(int32_t *)(i_a1 + 4);
}

// Address range: 0x10fb0 - 0x10fc4
int32_t function_10fb0(int32_t i_a1) {
    // 0x10fb0
    return i_a1;
}

// Address range: 0x10fc4 - 0x10fe0
int32_t function_10fc4(int32_t *p_a1, int32_t *p_a2) {
    // 0x10fc4
    __asm_svc(0);
    return (int32_t)p_a1;
}

// Address range: 0x10fe0 - 0x1103c
int32_t function_10fe0(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    int32_t i_v1 = _init(i_a1, i_a2, i_a3, i_a4); // 0x10ffc
    int32_t i_v2 = (int32_t)&i_g13 - (int32_t)&i_g12 >> 2 == 0 ? i_v1 : i_a1;
    return i_v2;
}

// Address range: 0x11044 - 0x11048
int32_t function_11044(void) {
    // 0x11044
    int32_t i_v1; // 0x11044
    return i_v1;
}

// Address range: 0x11048 - 0x11050
int32_t _fini(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x11048
    return i_a1;
}

// Address range: 0x48d36 - 0x48d37
int32_t function_48d36(void) {
    // 0x48d36
    int32_t i_v1; // 0x48d36
    return i_v1;
}

// Address range: 0x95502 - 0x95503
int32_t function_95502(void) {
    // 0x95502
    int32_t i_v1; // 0x95502
    return i_v1;
}

// Address range: 0xc8292 - 0xc8293
int32_t function_c8292(void) {
    // 0xc8292
    int32_t i_v1; // 0xc8292
    return i_v1;
}

// Address range: 0x148d6a - 0x148d6b
int32_t function_148d6a(void) {
    // 0x148d6a
    int32_t i_v1; // 0x148d6a
    return i_v1;
}

// Address range: 0x1533fe - 0x1533ff
int32_t function_1533fe(void) {
    // 0x1533fe
    int32_t i_v1; // 0x1533fe
    return i_v1;
}

// Address range: 0x1888c2 - 0x1888c3
int32_t function_1888c2(void) {
    // 0x1888c2
    int32_t i_v1; // 0x1888c2
    return i_v1;
}

// Address range: 0x1c84da - 0x1c84db
int32_t function_1c84da(void) {
    // 0x1c84da
    int32_t i_v1; // 0x1c84da
    return i_v1;
}

// Address range: 0x1c8e9e - 0x1c8e9f
int32_t function_1c8e9e(void) {
    // 0x1c8e9e
    int32_t i_v1; // 0x1c8e9e
    return i_v1;
}

// Address range: 0x64630a - 0x64630b
int32_t function_64630a(void) {
    // 0x64630a
    int32_t i_v1; // 0x64630a
    return i_v1;
}

// Address range: 0x6af476 - 0x6af477
int32_t function_6af476(void) {
    // 0x6af476
    int32_t i_v1; // 0x6af476
    return i_v1;
}

// Address range: 0x848b56 - 0x848b57
int32_t function_848b56(void) {
    // 0x848b56
    int32_t i_v1; // 0x848b56
    return i_v1;
}

// Address range: 0x888d56 - 0x888d57
int32_t function_888d56(void) {
    // 0x888d56
    int32_t i_v1; // 0x888d56
    return i_v1;
}

// Address range: 0x1049296 - 0x1049297
int32_t function_1049296(void) {
    // 0x1049296
    int32_t i_v1; // 0x1049296
    return i_v1;
}

// Address range: 0x1885f36 - 0x1885f37
int32_t function_1885f36(void) {
    // 0x1885f36
    int32_t i_v1; // 0x1885f36
    return i_v1;
}

// Address range: 0x18c91be - 0x18c91bf
int32_t function_18c91be(void) {
    // 0x18c91be
    int32_t i_v1; // 0x18c91be
    return i_v1;
}

// Address range: 0x1908afe - 0x1908aff
int32_t function_1908afe(void) {
    // 0x1908afe
    int32_t i_v1; // 0x1908afe
    return i_v1;
}

// Address range: 0x1988ee6 - 0x1988ee7
int32_t function_1988ee6(void) {
    // 0x1988ee6
    int32_t i_v1; // 0x1988ee6
    return i_v1;
}

// Address range: 0xfe3c5ec2 - 0xfe3c5ec3
int32_t function_fe3c5ec2(void) {
    // 0xfe3c5ec2
    int32_t i_v1; // 0xfe3c5ec2
    return i_v1;
}

// Address range: 0xfe448956 - 0xfe448957
int32_t function_fe448956(void) {
    // 0xfe448956
    int32_t i_v1; // 0xfe448956
    return i_v1;
}

// Address range: 0xfe44919a - 0xfe44919b
int32_t function_fe44919a(void) {
    // 0xfe44919a
    int32_t i_v1; // 0xfe44919a
    return i_v1;
}

// Address range: 0xfe8c8dba - 0xfe8c8dbb
int32_t function_fe8c8dba(void) {
    // 0xfe8c8dba
    int32_t i_v1; // 0xfe8c8dba
    return i_v1;
}

// Address range: 0xfe9491a2 - 0xfe9491a3
int32_t function_fe9491a2(void) {
    // 0xfe9491a2
    int32_t i_v1; // 0xfe9491a2
    return i_v1;
}

// Address range: 0xff048522 - 0xff048523
int32_t function_ff048522(void) {
    // 0xff048522
    int32_t i_v1; // 0xff048522
    return i_v1;
}

// Address range: 0xff048b46 - 0xff048b47
int32_t function_ff048b46(void) {
    // 0xff048b46
    int32_t i_v1; // 0xff048b46
    return i_v1;
}

// Address range: 0xff24807e - 0xff24807f
int32_t function_ff24807e(void) {
    // 0xff24807e
    int32_t i_v1; // 0xff24807e
    return i_v1;
}

// Address range: 0xff24883a - 0xff24883b
int32_t function_ff24883a(void) {
    // 0xff24883a
    int32_t i_v1; // 0xff24883a
    return i_v1;
}

// Address range: 0xff848096 - 0xff848097
int32_t function_ff848096(void) {
    // 0xff848096
    int32_t i_v1; // 0xff848096
    return i_v1;
}

// Address range: 0xff8480a6 - 0xff8480a7
int32_t function_ff8480a6(void) {
    // 0xff8480a6
    int32_t i_v1; // 0xff8480a6
    return i_v1;
}

// Address range: 0xff8484ca - 0xff8484cb
int32_t function_ff8484ca(void) {
    // 0xff8484ca
    int32_t i_v1; // 0xff8484ca
    return i_v1;
}

// Address range: 0xff848826 - 0xff848827
int32_t function_ff848826(void) {
    // 0xff848826
    int32_t i_v1; // 0xff848826
    return i_v1;
}

// Address range: 0xff8882ca - 0xff8882cb
int32_t function_ff8882ca(void) {
    // 0xff8882ca
    int32_t i_v1; // 0xff8882ca
    return i_v1;
}

// Address range: 0xff8883f6 - 0xff8883f7
int32_t function_ff8883f6(void) {
    // 0xff8883f6
    int32_t i_v1; // 0xff8883f6
    return i_v1;
}

// Address range: 0xff90690e - 0xff90690f
int32_t function_ff90690e(void) {
    // 0xff90690e
    int32_t i_v1; // 0xff90690e
    return i_v1;
}

// Address range: 0xffa0631a - 0xffa0631b
int32_t function_ffa0631a(void) {
    // 0xffa0631a
    int32_t i_v1; // 0xffa0631a
    return i_v1;
}

// Address range: 0xffa0652a - 0xffa0652b
int32_t function_ffa0652a(void) {
    // 0xffa0652a
    int32_t i_v1; // 0xffa0652a
    return i_v1;
}

// Address range: 0xffa45ae2 - 0xffa45ae3
int32_t function_ffa45ae2(void) {
    // 0xffa45ae2
    int32_t i_v1; // 0xffa45ae2
    return i_v1;
}

// Address range: 0xffb2f126 - 0xffb2f127
int32_t function_ffb2f126(void) {
    // 0xffb2f126
    int32_t i_v1; // 0xffb2f126
    return i_v1;
}

// Address range: 0xffbaf116 - 0xffbaf117
int32_t function_ffbaf116(void) {
    // 0xffbaf116
    int32_t i_v1; // 0xffbaf116
    return i_v1;
}

// Address range: 0xffcc7f66 - 0xffcc7f67
int32_t function_ffcc7f66(void) {
    // 0xffcc7f66
    int32_t i_v1; // 0xffcc7f66
    return i_v1;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.8.x)
// Detected functions: 304
