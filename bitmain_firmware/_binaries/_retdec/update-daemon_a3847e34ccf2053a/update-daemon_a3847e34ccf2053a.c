//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <arpa/inet.h>
#include <assert.h>
#include <ctype.h>
#include <pthread.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <unistd.h>

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct sockaddr {
    int32_t e0;
    char e1[14];
};

struct stat64 {
    int64_t e0;
    int64_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int64_t e6;
    int64_t e7;
    int64_t e8;
    int32_t e9;
    int32_t e10;
    int64_t e11;
    int32_t e12;
    int32_t e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int32_t e17;
    int32_t e18;
    int32_t e19;
};

// ------------------- Function Prototypes --------------------

int32_t entry_point(int32_t i_a1, int32_t i_a2);
int32_t function_107a0(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
char *function_107c0(char *haystack, char *needle);
int32_t function_107cc(char *format, ...);
int32_t function_107d8(int32_t fd, int32_t *buf, int32_t nbytes);
void function_107e4(char *s);
int32_t function_107f0(int32_t fd, struct sockaddr *addr, int32_t *addr_len);
int32_t function_107fc(int32_t *ptr, int32_t size, int32_t n,
                       struct _IO_FILE *s);
char *function_10808(char *dest, char *src);
int32_t function_10814(int32_t *newthread, int32_t *attr,
                       int32_t *(*start_routine)(int32_t *), int32_t *arg);
int32_t function_10820(char *s);
int32_t function_1082c(int32_t main, int32_t argc, char **ubp_av,
                       void (*init)(), void (*fini)(), void (*rtld_fini)());
int32_t function_10838(char *command);
void function_10844(void);
int16_t **function_10850(void);
void function_1085c(int32_t status);
int32_t function_10868(char *s);
int32_t function_10874(int32_t fd, struct sockaddr *addr, int32_t len);
int32_t *function_10880(int32_t *s, int32_t c, int32_t n);
int32_t function_1088c(int32_t fd, int32_t *buf, int32_t n);
void function_10898(int32_t *retval);
int32_t function_108a4(int32_t fd, int32_t how);
int32_t function_108b0(int32_t fd, int32_t n);
int32_t function_108bc(char *s, char *format, ...);
int32_t function_108c8(int32_t domain, int32_t type, int32_t protocol);
int32_t function_108d4(char *cp);
int32_t function_108e0(int32_t ver, char *filename, struct stat64 *stat_buf);
void function_108ec(void);
int32_t function_108f8(int32_t fd, int32_t *buf, int32_t n, int32_t flags);
int32_t function_10904(int32_t fd);
int32_t function_10910(int32_t fd, int32_t *buf, int32_t n, int32_t flags);
int32_t function_1091c(int32_t fd, struct sockaddr *addr, int32_t len);
void function_10928(char *assertion, char *file, int32_t line, char *function);
int32_t function_10934(int32_t i_a1, int32_t i_a2);
int32_t function_10bac(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_10bb8(void);
int32_t function_10bdc(int32_t i_a1, int32_t i_a2, int32_t i_a3, char i_a4);
int32_t function_10c30(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4,
                       int32_t i_a5);
int32_t function_10c44(void);
int32_t function_10c48(char *p_a1);
int32_t function_10c94(int32_t i_a1);
int32_t function_10ec4(int32_t i_a1);
int32_t function_10fe0(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_1101c(void);
int32_t function_11020(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t unknown_240(void);

// --------------------- Global Variables ---------------------

int32_t i_g1 = -0x1cae0000;   // 0x10bc8
int32_t i_g2 = 114;           // 0x11438
int32_t i_g3 = 0x10c45;       // 0x21f08
struct _IO_FILE *p_g4 = NULL; // 0x22098
int32_t i_g5;

// ------- Dynamically Linked Functions Without Header --------

void __gmon_start__(void);
int32_t __libc_start_main(int32_t i_a1, int32_t i_a2, char **p_a3,
                          void (*p_a4)(), void (*p_a5)(), void (*p_a6)());
int32_t __xstat64(int32_t i_a1, char *p_a2, struct stat64 *p_a3);

// ------------------------ Functions -------------------------

// Address range: 0x107a0 - 0x107ac
int32_t function_107a0(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x107a0
    return function_10bb8();
}

// Address range: 0x107c0 - 0x107cc
char *function_107c0(char *haystack, char *needle) {
    // 0x107c0
    return strstr(haystack, needle);
}

// Address range: 0x107cc - 0x107d8
int32_t function_107cc(char *format, ...) {
    // 0x107cc
    return printf(format);
}

// Address range: 0x107d8 - 0x107e4
int32_t function_107d8(int32_t fd, int32_t *buf, int32_t nbytes) {
    // 0x107d8
    return read(fd, buf, nbytes);
}

// Address range: 0x107e4 - 0x107f0
void function_107e4(char *s) {
    // 0x107e4
    perror(s);
}

// Address range: 0x107f0 - 0x107fc
int32_t function_107f0(int32_t fd, struct sockaddr *addr, int32_t *addr_len) {
    // 0x107f0
    return accept(fd, addr, addr_len);
}

// Address range: 0x107fc - 0x10808
int32_t function_107fc(int32_t *ptr, int32_t size, int32_t n,
                       struct _IO_FILE *s) {
    // 0x107fc
    return fwrite(ptr, size, n, s);
}

// Address range: 0x10808 - 0x10814
char *function_10808(char *dest, char *src) {
    // 0x10808
    return strcpy(dest, src);
}

// Address range: 0x10814 - 0x10820
int32_t function_10814(int32_t *newthread, int32_t *attr,
                       int32_t *(*start_routine)(int32_t *), int32_t *arg) {
    // 0x10814
    return pthread_create(newthread, attr, start_routine, arg);
}

// Address range: 0x10820 - 0x1082c
int32_t function_10820(char *s) {
    // 0x10820
    return puts(s);
}

// Address range: 0x1082c - 0x10838
int32_t function_1082c(int32_t main, int32_t argc, char **ubp_av,
                       void (*init)(), void (*fini)(), void (*rtld_fini)()) {
    // 0x1082c
    return __libc_start_main(main, argc, ubp_av, init, fini, rtld_fini);
}

// Address range: 0x10838 - 0x10844
int32_t function_10838(char *command) {
    // 0x10838
    return system(command);
}

// Address range: 0x10844 - 0x10850
void function_10844(void) {
    // 0x10844
    __gmon_start__();
}

// Address range: 0x10850 - 0x1085c
int16_t **function_10850(void) {
    // 0x10850
    return __ctype_b_loc();
}

// Address range: 0x1085c - 0x10868
void function_1085c(int32_t status) {
    // 0x1085c
    exit(status);
}

// Address range: 0x10868 - 0x10874
int32_t function_10868(char *s) {
    // 0x10868
    return strlen(s);
}

// Address range: 0x10874 - 0x10880
int32_t function_10874(int32_t fd, struct sockaddr *addr, int32_t len) {
    // 0x10874
    return bind(fd, addr, len);
}

// Address range: 0x10880 - 0x1088c
int32_t *function_10880(int32_t *s, int32_t c, int32_t n) {
    // 0x10880
    return memset(s, c, n);
}

// Address range: 0x1088c - 0x10898
int32_t function_1088c(int32_t fd, int32_t *buf, int32_t n) {
    // 0x1088c
    return write(fd, buf, n);
}

// Address range: 0x10898 - 0x108a4
void function_10898(int32_t *retval) {
    // 0x10898
    pthread_exit(retval);
}

// Address range: 0x108a4 - 0x108b0
int32_t function_108a4(int32_t fd, int32_t how) {
    // 0x108a4
    return shutdown(fd, how);
}

// Address range: 0x108b0 - 0x108bc
int32_t function_108b0(int32_t fd, int32_t n) {
    // 0x108b0
    return listen(fd, n);
}

// Address range: 0x108bc - 0x108c8
int32_t function_108bc(char *s, char *format, ...) {
    // 0x108bc
    return sprintf(s, format);
}

// Address range: 0x108c8 - 0x108d4
int32_t function_108c8(int32_t domain, int32_t type, int32_t protocol) {
    // 0x108c8
    return socket(domain, type, protocol);
}

// Address range: 0x108d4 - 0x108e0
int32_t function_108d4(char *cp) {
    // 0x108d4
    return inet_addr(cp);
}

// Address range: 0x108e0 - 0x108ec
int32_t function_108e0(int32_t ver, char *filename, struct stat64 *stat_buf) {
    // 0x108e0
    return __xstat64(ver, filename, stat_buf);
}

// Address range: 0x108ec - 0x108f8
void function_108ec(void) {
    // 0x108ec
    abort();
}

// Address range: 0x108f8 - 0x10904
int32_t function_108f8(int32_t fd, int32_t *buf, int32_t n, int32_t flags) {
    // 0x108f8
    return recv(fd, buf, n, flags);
}

// Address range: 0x10904 - 0x10910
int32_t function_10904(int32_t fd) {
    // 0x10904
    return close(fd);
}

// Address range: 0x10910 - 0x1091c
int32_t function_10910(int32_t fd, int32_t *buf, int32_t n, int32_t flags) {
    // 0x10910
    return send(fd, buf, n, flags);
}

// Address range: 0x1091c - 0x10928
int32_t function_1091c(int32_t fd, struct sockaddr *addr, int32_t len) {
    // 0x1091c
    return connect(fd, addr, len);
}

// Address range: 0x10928 - 0x10934
void function_10928(char *assertion, char *file, int32_t line, char *function) {
    // 0x10928
    __assert_fail(assertion, file, line, function);
}

// Address range: 0x10934 - 0x10b84
int32_t function_10934(int32_t i_a1, int32_t i_a2) {
    char *p_v1 = (char *)i_a2;            // 0x10950
    char *p_v2 = strstr(p_v1, "daemonc"); // 0x10950
    if (p_v2 != NULL) {
        // 0x10ab8
        return function_10ec4(*(int32_t *)(i_a2 + 4));
    }
    // 0x1095c
    if (strstr(p_v1, "daemons") == NULL) {
        // 0x10ae8
        puts("Cannot Find Command!\r");
        // 0x10ab8
        return -1;
    }
    int32_t i_v3 = socket(AF_INET, SOCK_STREAM, (int32_t)p_v2); // 0x10980
    if (i_v3 == -1) {
        // 0x10b18
        __assert_fail("sockfd_server != -1", "update-daemon.c", 166,
                      "ProcessServer");
        // 0x10b34
        fwrite((int32_t *)"listen error!\n", 1, 14, p_g4);
        exit(1);
        // UNREACHABLE
    }
    float64_t f_v4 = __asm_vmov_i32(0); // 0x10990
    int16_t i_v5 = 2;                   // bp-56, 0x1099c
    int32_t i_v6;                       // 0x10934
    __asm_vst1_8(f_v4, i_v6);
    __asm_vst1_8(f_v4, i_v6);
    inet_addr("127.0.0.1");
    printf("Will Listening To Port[%d]\r\n", function_10c48("22322"));
    if (bind(i_v3, (struct sockaddr *)&i_v5, 16) == -1) {
        // 0x10b5c
        fwrite((int32_t *)"bind error!\n", 1, 12, p_g4);
        exit(1);
        return &i_g5;
    }
    // 0x109f8
    if (listen(i_v3, 512) == -1) {
        // 0x10b34
        fwrite((int32_t *)"listen error!\n", 1, 14, p_g4);
        exit(1);
        // UNREACHABLE
    }
    while (true) {
        // 0x10a2c
        puts("waiting for new connection...");
        int32_t i_v7 = 16; // bp-64, 0x10a44
        int32_t i_v8;      // bp-40, 0x10934
        int32_t i_v9 = accept(i_v3, (struct sockaddr *)&i_v8, &i_v7); // 0x10a48
        int32_t i_v10 = i_v9; // bp-68, 0x10a50
        if (i_v9 == -1) {
            // 0x10acc
            fwrite((int32_t *)"Accept error!\n", 1, 14, p_g4);
        } else {
            // 0x10a58
            puts("A new connection occurs!");
            int32_t i_v11; // bp-60, 0x10934
            if (pthread_create(&i_v11, NULL, (int32_t * (*)(int32_t *))0x10c94,
                               &i_v10) == -1) {
                // break -> 0x10a7c
                break;
            }
        }
    }
    // 0x10a7c
    fwrite((int32_t *)"pthread_create error!\n", 1, 22, p_g4);
    if (shutdown(i_v3, SHUT_WR) != -1) {
        // 0x10aa8
        puts("Server shuts down");
        // 0x10ab8
        return 0;
    }
    // 0x10afc
    __assert_fail("ret != -1", "update-daemon.c", 208, "ProcessServer");
    // 0x10b18
    __assert_fail("sockfd_server != -1", "update-daemon.c", 166,
                  "ProcessServer");
    // 0x10b34
    fwrite((int32_t *)"listen error!\n", 1, 14, p_g4);
    exit(1);
    // UNREACHABLE
}

// Address range: 0x10b88 - 0x10bac
int32_t entry_point(int32_t i_a1, int32_t i_a2) {
    // 0x10b88
    int32_t i_v1; // 0x10b88
    __libc_start_main(0x10934, i_a2, (char **)&i_v1, (void (*)())0x10fe1,
                      (void (*)())0x10934, (void (*)())i_a1);
    abort();
    // UNREACHABLE
}

// Address range: 0x10bac - 0x10bb0
int32_t function_10bac(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x10bac
    return i_a1;
}

// Address range: 0x10bb8 - 0x10bd4
int32_t function_10bb8(void) {
    int32_t i_v1 =
        *(int32_t *)((int32_t)&i_g1 + (int32_t)&i_g2 + 136); // 0x10bc4
    if (i_v1 == 0) {
        int32_t i_v2; // 0x10bb8
        return i_v2;
    }
    // 0x10bd0
    __gmon_start__();
    return &i_g5;
}

// Address range: 0x10bdc - 0x10c30
int32_t function_10bdc(int32_t i_a1, int32_t i_a2, int32_t i_a3, char i_a4) {
    // 0x10bdc
    int32_t i_v1; // 0x10bdc
    int32_t i_v2 = i_v1;
    bool i_v3; // 0x10bdc
    if (i_v3) {
        return i_a1;
    }
    bool i_v4; // 0x10bdc
    if (!i_v3) {
        int32_t i_v5 = 0x100001 * i_v2 & -1 - 0x400000 * i_v2; // 0x10c14
        i_v4 = i_v5 < 0;
        if (i_v5 == 0) {
            return unknown_240();
        }
    }
    // 0x10c24
    if (i_v4 != i_v3) {
        __asm_svclt(0x4770);
    }
    float64_t f_v6; // 0x10bdc
    __asm_vqrshl_s8(f_v6, f_v6);
    return i_a1;
}

// Address range: 0x10c30 - 0x10c44
int32_t function_10c30(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4,
                       int32_t i_a5) {
    char *p_v1 = (char *)(0x40000 * i_a4 | 0x20000); // 0x10c36
    int32_t i_v2 = i_a1;                             // 0x10c38
    if (*p_v1 == 0) {
        // 0x10c3a
        i_v2 = function_10bdc(i_a1, i_a2, i_a3, 0);
        *p_v1 = 1;
    }
    // 0x10c42
    return i_v2;
}

// Address range: 0x10c44 - 0x10c46
int32_t function_10c44(void) {
    // 0x10c44
    int32_t i_v1; // 0x10c44
    return i_v1;
}

// Address range: 0x10c48 - 0x10c94
int32_t function_10c48(char *p_a1) {
    int32_t i_v1 = (int32_t)p_a1;
    int32_t i_v2 = strlen(p_a1); // 0x10c50
    int32_t i_v3 = i_v1 - 1;
    int32_t i_v4 = i_v1 - 2 + i_v2; // 0x10c68
    int32_t i_v5 = -48;             // 0x10c84
    if (i_v3 == i_v4) {
        // 0x10c88
        return (int32_t) * (char *)(i_v2 + i_v3) - 48;
    }
    int32_t i_v6 = i_v3; // 0x10c84
    i_v6++;
    i_v5 = 10 * (i_v5 + (int32_t) * (char *)i_v6) - 48;
    while (i_v6 != i_v4) {
        // 0x10c70
        i_v6++;
        i_v5 = 10 * (i_v5 + (int32_t) * (char *)i_v6) - 48;
    }
    // 0x10c88
    return i_v5 + (int32_t) * (char *)(i_v2 + i_v3);
}

// Address range: 0x10c94 - 0x10ec4
int32_t function_10c94(int32_t i_a1) {
    // 0x10c94
    puts("New Thread!\r");
    int32_t i_v1 = 0;                               // bp-2064, 0x10cbc
    int32_t i_v2;                                   // bp-2060, 0x10c94
    int32_t i_v3 = (int32_t)memset(&i_v2, 0, 1020); // 0x10cc0
    read(i_v3, &i_v1, 1024);
    printf("Recv:'%s'\r\n", &i_v1);
    char *p_v4; // bp-1040, 0x10c94
    int32_t i_v5 =
        __xstat64(3, (char *)&i_v1, (struct stat64 *)&p_v4); // 0x10cf4
    int32_t i_v6 = 0;                                        // 0x10cfc
    int32_t i_v7 = i_a1;                                     // 0x10cfc
    int32_t i_v8;                                            // 0x10c94
    int32_t i_v9;                                            // 0x10c94
    int32_t i_v10;                                           // bp-2080, 0x10c94
    if (i_v5 == 0) {
        int32_t i_v11 = i_v1 % 256; // 0x10d00
        int32_t i_v12 = i_a1;       // 0x10d08
        if (i_v11 != 0) {
            int32_t i_v13 = (int32_t)*__ctype_b_loc(); // 0x10d14
            int32_t i_v14 = &i_v1;                     // 0x10d14
            uint16_t i_v15 = *(int16_t *)(2 * i_v11 + i_v13) & 8;
            int32_t i_v16 = i_v15; // 0x10d20
            uint32_t i_v17;        // 0x10d30
            if (i_v11 != 95 && i_v15 == 0) {
                // 0x10d30
                i_v17 = i_v11 - 45;
                if (i_v17 != 2 && i_v17 >= 2) {
                    // 0x10d3c
                    puts("Invalid client content.");
                    close(i_v3);
                    pthread_exit((int32_t *)i_v16);
                }
            }
            // 0x10d58
            i_v14++;
            unsigned char i_v18 = *(char *)i_v14; // 0x10d58
            i_v12 = i_v16;
            while (i_v18 != 0) {
                int32_t i_v19 = i_v18;
                i_v15 = *(int16_t *)(2 * i_v19 + i_v13) & 8;
                i_v16 = i_v15;
                if (i_v19 != 95 && i_v15 == 0) {
                    // 0x10d30
                    i_v17 = i_v19 - 45;
                    if (i_v17 != 2 && i_v17 >= 2) {
                        // 0x10d3c
                        puts("Invalid client content.");
                        close(i_v3);
                        pthread_exit((int32_t *)i_v16);
                    }
                }
                // 0x10d58
                i_v14++;
                i_v18 = *(char *)i_v14;
                i_v12 = i_v16;
            }
        }
        // 0x10d64
        p_v4 = (char *)0x7273752f;
        char i_v20 = 0; // bp-1016, 0x10d84
        int32_t i_v21;  // bp-1015, 0x10c94
        memset(&i_v21, 0, 999);
        strcpy(&i_v20, (char *)&i_v1);
        i_v10 = 0x656d6f43;
        int32_t i_v22 = system((char *)&p_v4); // 0x10dc4
        if (i_v22 == -1) {
            // 0x10e80
            puts("system err!\r");
            i_v10 = 0x303035;
            i_v6 = -1;
            i_v7 = i_v12;
            goto lab_0x10e10;
        } else {
            int32_t i_v23 = __asm_ubfx(i_v22, 8, 8); // 0x10de0
            printf("system status:[%d]\r\n");
            i_v8 = i_v22;
            i_v9 = i_v23;
            if (i_v22 % 128 == 0) {
                if (i_v23 == 0) {
                    // 0x10df8
                    puts("Shell Exec Successfully!\r");
                    i_v10 = 0x303032;
                    i_v6 = i_v22;
                    i_v7 = 0;
                } else {
                    // 0x10e9c
                    printf("Shell Execute Failed, Ret[%d]\r\n", i_v23);
                    sprintf((char *)&i_v10, "%d", i_v23);
                    i_v6 = i_v22;
                    i_v7 = i_v23;
                }
                goto lab_0x10e10;
            } else {
                goto lab_0x10e58;
            }
        }
    } else {
        goto lab_0x10e38;
    }
lab_0x10e38:
    // 0x10e38
    printf("File does not exist: %s\n", &i_v1);
    close(i_v3);
    pthread_exit((int32_t *)i_v6);
    i_v8 = i_v6;
    i_v9 = i_v7;
    goto lab_0x10e58;
lab_0x10e58:
    // 0x10e58
    printf("Other Exit Ret[%d]\r\n", i_v9);
    sprintf((char *)&i_v10, "6%d", i_v9);
    i_v6 = i_v8;
    i_v7 = i_v9;
    goto lab_0x10e10;
lab_0x10e10:
    // 0x10e10
    write(i_v3, &i_v10, strlen((char *)&i_v10) + 1);
    close(i_v3);
    pthread_exit(NULL);
    goto lab_0x10e38;
}

// Address range: 0x10ec4 - 0x10fe0
int32_t function_10ec4(int32_t i_a1) {
    // 0x10ec4
    if (i_a1 == 0) {
        // 0x10fa8
        return -3;
    }
    float64_t f_v1 = __asm_vmov_i32(0); // 0x10ed4
    int32_t i_v2;                       // 0x10ec4
    __asm_vst1_8(f_v1, i_v2);
    int32_t i_v3 = 2; // bp-1056, 0x10ef0
    __asm_vst1_8(f_v1, i_v2);
    inet_addr("127.0.0.1");
    function_10c48("22322");
    int32_t i_v4 = socket(AF_INET, SOCK_STREAM, IPPROTO_IP); // 0x10f1c
    if (i_v4 < 0) {
        // 0x10fb8
        perror("socket err:");
        // 0x10fa8
        return -1;
    }
    // 0x10f28
    if (connect(i_v4, (struct sockaddr *)&i_v3, 16) < 0) {
        // 0x10fcc
        perror("connect err:");
        // 0x10fa8
        return -2;
    }
    // 0x10f3c
    send(i_v4, (int32_t *)i_a1, strlen((char *)i_a1) + 1, 0);
    int32_t i_v5 = 0; // bp-1040, 0x10f68
    int32_t i_v6;     // bp-1036, 0x10ec4
    memset(&i_v6, 0, 1020);
    int32_t i_v7 = recv(i_v4, &i_v5, 1024, 0); // 0x10f80
    if (i_v7 < 1) {
        // 0x10fa8
        return -3;
    }
    // 0x10f8c
    int32_t i_v8; // bp-16, 0x10ec4
    *(char *)((int32_t)&i_v8 - 1024 + i_v7) = 0;
    int32_t i_v9 = function_10c48((char *)&i_v5); // 0x10f9c
    return i_v9 == 200 ? 0 : i_v9;
}

// Address range: 0x10fe0 - 0x11014
int32_t function_10fe0(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    int32_t i_v1 = function_107a0(i_a1, i_a2, i_a3, i_a4); // 0x10ff0
    return 0x21f0a - (int32_t)&i_g3 >> 2 == 0 ? i_v1 : i_a1;
}

// Address range: 0x1101c - 0x1101e
int32_t function_1101c(void) {
    // 0x1101c
    int32_t i_v1; // 0x1101c
    return i_v1;
}

// Address range: 0x11020 - 0x11028
int32_t function_11020(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x11020
    return i_a1;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.4.3)
// Detected functions: 45
