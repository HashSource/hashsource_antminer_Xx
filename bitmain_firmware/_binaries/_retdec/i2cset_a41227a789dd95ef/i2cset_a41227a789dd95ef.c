//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stropts.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct __dirstream {
    int32_t e0;
};

struct dirent {
    int32_t e0;
    int32_t e1;
    int16_t e2;
    char e3;
    char e4[256];
};

// ------------------- Function Prototypes --------------------

int32_t *__errno_location2(void);
int32_t __libc_start_main2(int32_t main, int32_t argc, char **ubp_av,
                           void (*init)(), void (*fini)(), void (*rtld_fini)());
char *__strdup2(char *string);
void abort2(void);
int32_t *calloc2(int32_t nmemb, int32_t size);
int32_t close2(int32_t fd);
int32_t closedir2(struct __dirstream *dirp);
int32_t entry_point(int32_t i_a1, int32_t i_a2);
void exit2(int32_t status);
int32_t fclose2(struct _IO_FILE *stream);
int32_t fflush2(struct _IO_FILE *stream);
int32_t fgetc2(struct _IO_FILE *stream);
char *fgets2(char *s, int32_t n, struct _IO_FILE *stream);
struct _IO_FILE *fopen2(char *filename, char *modes);
int32_t fprintf2(struct _IO_FILE *stream, char *format, ...);
void free2(int32_t *ptr);
int32_t function_8960(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
void function_8a58(void);
int32_t function_8b54(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4,
                      int32_t *p_a5);
int32_t function_8b84(void);
int32_t function_8bb8(int32_t i_a1, int32_t i_a2);
int32_t function_9a70(void);
int32_t function_9a94(int32_t i_a1, int32_t i_a2, int32_t i_a3, char i_a4);
int32_t function_9acc(int32_t *p_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_9b0c(void);
int32_t function_9b34(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_9b68(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_9b94(int32_t i_a1);
int32_t function_9bf8(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_9c30(int32_t i_a1, int32_t i_a2);
int32_t function_9c74(int32_t i_a1);
int32_t function_9d08(int32_t i_a1, int32_t *p_a2, int32_t i_a3, uint32_t i_a4);
int32_t function_9e38(void);
int32_t function_a38c(int32_t i_a1);
int32_t function_a4d4(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t function_a544(int32_t i_a1);
int32_t function_a5e4(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_a648(void);
int32_t function_a64c(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t fwrite2(int32_t *ptr, int32_t size, int32_t n, struct _IO_FILE *s);
int32_t ioctl2(int32_t fd, int32_t request, ...);
int32_t *malloc2(int32_t size);
int32_t *memset2(int32_t *s, int32_t c, int32_t n);
int32_t open2(char *file, int32_t oflag, ...);
struct __dirstream *opendir2(char *name);
int32_t printf2(char *format, ...);
int32_t puts2(char *s);
struct dirent *readdir2(struct __dirstream *dirp);
int32_t *realloc2(int32_t *ptr, int32_t size);
int32_t snprintf2(char *s, int32_t maxlen, char *format, ...);
int32_t sprintf2(char *s, char *format, ...);
int32_t sscanf2(char *s, char *format, ...);
int32_t strcasecmp2(char *s1, char *s2);
char *strchr2(char *s, int32_t c);
int32_t strcmp2(char *s1, char *s2);
char *strcpy2(char *dest, char *src);
char *strerror2(int32_t errnum);
int32_t strlen2(char *s);
int32_t strncmp2(char *s1, char *s2, int32_t n);
char *strrchr2(char *s, int32_t c);
int32_t strtol2(char *nptr, char **endptr, int32_t base);
int32_t strtoul2(char *nptr, char **endptr, int32_t base);

// --------------------- Global Variables ---------------------

int32_t i_g1 = 0x9b34;                       // 0x13024
int32_t i_g2 = 0x9b0c;                       // 0x13028
int32_t i_g3 = 0;                            // 0x1302c
struct _IO_FILE *p_g4 = NULL;                // 0x131d0
struct _IO_FILE *p_g5 = NULL;                // 0x131d8
char *p_g6;                                  // 0x131dc
int32_t i_g7 = -0x45ffffb1;                  // 0x9698
int32_t i_g8 = -0x1cae0000;                  // 0x9a80
void (*p_g9)() = (void (*)()) - 0x16d2ba08;  // 0xa5e4
void (*p_g10)() = (void (*)()) - 0x1ed000e2; // 0xa648
char *p_g11;                                 // 0xa7ec
char *x_g12[10] = {"dummy",   "Dummy bus",   "isa",   "ISA bus",
                   "i2c",     "I2C adapter", "smbus", "SMBus adapter",
                   "unknown", "N/A"}; // 0xad38
int32_t i_g13;
int32_t i_g14;
int32_t i_g15;
int32_t i_g16;
int32_t i_g17;

// ------- Dynamically Linked Functions Without Header --------

void __gmon_start__(void);
int32_t __libc_start_main(int32_t i_a1, int32_t i_a2, char **p_a3,
                          void (*p_a4)(), void (*p_a5)(), void (*p_a6)());
char *__strdup(char *p_a1);

// ------------------------ Functions -------------------------

// Address range: 0x8960 - 0x896c
int32_t function_8960(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x8960
    return function_9a70();
}

// Address range: 0x8980 - 0x898c
int32_t *calloc2(int32_t nmemb, int32_t size) {
    // 0x8980
    return calloc(nmemb, size);
}

// Address range: 0x898c - 0x8998
int32_t strcmp2(char *s1, char *s2) {
    // 0x898c
    return strcmp(s1, s2);
}

// Address range: 0x8998 - 0x89a4
int32_t strtol2(char *nptr, char **endptr, int32_t base) {
    // 0x8998
    return strtol(nptr, endptr, base);
}

// Address range: 0x89a4 - 0x89b0
int32_t printf2(char *format, ...) {
    // 0x89a4
    return printf(format);
}

// Address range: 0x89b0 - 0x89bc
struct _IO_FILE *fopen2(char *filename, char *modes) {
    // 0x89b0
    return fopen(filename, modes);
}

// Address range: 0x89bc - 0x89c8
int32_t fflush2(struct _IO_FILE *stream) {
    // 0x89bc
    return fflush(stream);
}

// Address range: 0x89c8 - 0x89d4
void free2(int32_t *ptr) {
    // 0x89c8
    free(ptr);
}

// Address range: 0x89d4 - 0x89e0
char *fgets2(char *s, int32_t n, struct _IO_FILE *stream) {
    // 0x89d4
    return fgets(s, n, stream);
}

// Address range: 0x89e0 - 0x89ec
int32_t *realloc2(int32_t *ptr, int32_t size) {
    // 0x89e0
    return realloc(ptr, size);
}

// Address range: 0x89ec - 0x89f8
int32_t strcasecmp2(char *s1, char *s2) {
    // 0x89ec
    return strcasecmp(s1, s2);
}

// Address range: 0x89f8 - 0x8a04
int32_t fwrite2(int32_t *ptr, int32_t size, int32_t n, struct _IO_FILE *s) {
    // 0x89f8
    return fwrite(ptr, size, n, s);
}

// Address range: 0x8a04 - 0x8a10
int32_t ioctl2(int32_t fd, int32_t request, ...) {
    // 0x8a04
    return ioctl(fd, request);
}

// Address range: 0x8a10 - 0x8a1c
char *strcpy2(char *dest, char *src) {
    // 0x8a10
    return strcpy(dest, src);
}

// Address range: 0x8a1c - 0x8a28
struct __dirstream *opendir2(char *name) {
    // 0x8a1c
    return opendir(name);
}

// Address range: 0x8a28 - 0x8a34
int32_t puts2(char *s) {
    // 0x8a28
    return puts(s);
}

// Address range: 0x8a34 - 0x8a40
int32_t *malloc2(int32_t size) {
    // 0x8a34
    return malloc(size);
}

// Address range: 0x8a40 - 0x8a4c
int32_t __libc_start_main2(int32_t main, int32_t argc, char **ubp_av,
                           void (*init)(), void (*fini)(),
                           void (*rtld_fini)()) {
    // 0x8a40
    return __libc_start_main(main, argc, ubp_av, init, fini, rtld_fini);
}

// Address range: 0x8a4c - 0x8a58
char *strerror2(int32_t errnum) {
    // 0x8a4c
    return strerror(errnum);
}

// Address range: 0x8a58 - 0x8a64
void function_8a58(void) {
    // 0x8a58
    __gmon_start__();
}

// Address range: 0x8a64 - 0x8a70
int32_t open2(char *file, int32_t oflag, ...) {
    // 0x8a64
    return open(file, oflag);
}

// Address range: 0x8a70 - 0x8a7c
void exit2(int32_t status) {
    // 0x8a70
    exit(status);
}

// Address range: 0x8a7c - 0x8a88
int32_t strtoul2(char *nptr, char **endptr, int32_t base) {
    // 0x8a7c
    return strtoul(nptr, endptr, base);
}

// Address range: 0x8a88 - 0x8a94
int32_t strlen2(char *s) {
    // 0x8a88
    return strlen(s);
}

// Address range: 0x8a94 - 0x8aa0
char *strchr2(char *s, int32_t c) {
    // 0x8a94
    return strchr(s, c);
}

// Address range: 0x8aa0 - 0x8aac
int32_t fprintf2(struct _IO_FILE *stream, char *format, ...) {
    // 0x8aa0
    return fprintf(stream, format);
}

// Address range: 0x8aac - 0x8ab8
int32_t *__errno_location2(void) {
    // 0x8aac
    return __errno_location();
}

// Address range: 0x8ab8 - 0x8ac4
int32_t snprintf2(char *s, int32_t maxlen, char *format, ...) {
    // 0x8ab8
    return snprintf(s, maxlen, format);
}

// Address range: 0x8ac4 - 0x8ad0
int32_t sscanf2(char *s, char *format, ...) {
    // 0x8ac4
    return sscanf(s, format);
}

// Address range: 0x8ad0 - 0x8adc
char *__strdup2(char *string) {
    // 0x8ad0
    return __strdup(string);
}

// Address range: 0x8adc - 0x8ae8
int32_t *memset2(int32_t *s, int32_t c, int32_t n) {
    // 0x8adc
    return memset(s, c, n);
}

// Address range: 0x8ae8 - 0x8af4
int32_t fgetc2(struct _IO_FILE *stream) {
    // 0x8ae8
    return fgetc(stream);
}

// Address range: 0x8af4 - 0x8b00
int32_t fclose2(struct _IO_FILE *stream) {
    // 0x8af4
    return fclose(stream);
}

// Address range: 0x8b00 - 0x8b0c
struct dirent *readdir2(struct __dirstream *dirp) {
    // 0x8b00
    return readdir(dirp);
}

// Address range: 0x8b0c - 0x8b18
char *strrchr2(char *s, int32_t c) {
    // 0x8b0c
    return strrchr(s, c);
}

// Address range: 0x8b18 - 0x8b24
int32_t sprintf2(char *s, char *format, ...) {
    // 0x8b18
    return sprintf(s, format);
}

// Address range: 0x8b24 - 0x8b30
int32_t strncmp2(char *s1, char *s2, int32_t n) {
    // 0x8b24
    return strncmp(s1, s2, n);
}

// Address range: 0x8b30 - 0x8b3c
void abort2(void) {
    // 0x8b30
    abort();
}

// Address range: 0x8b3c - 0x8b48
int32_t close2(int32_t fd) {
    // 0x8b3c
    return close(fd);
}

// Address range: 0x8b48 - 0x8b54
int32_t closedir2(struct __dirstream *dirp) {
    // 0x8b48
    return closedir(dirp);
}

// Address range: 0x8b54 - 0x8b84
int32_t function_8b54(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4,
                      int32_t *p_a5) {
    // 0x8b54
    return ioctl(i_a1, 1824);
}

// Address range: 0x8b84 - 0x8bb8
int32_t function_8b84(void) {
    // 0x8b84
    int32_t i_v1; // bp-44, 0x8b84
    int32_t i_v2; // 0x8b84
    return function_8b54(i_v2, 1, 0, 1, &i_v1) == 0 ? i_v1 % 256 : -1;
}

// Address range: 0x8bb8 - 0x9970
int32_t function_8bb8(int32_t i_a1, int32_t i_a2) {
    int32_t i_v1 = i_a1; // 0x8bcc
    int32_t i_v2 = i_a2; // 0x8bcc
    int32_t i_v3;        // 0x8bb8
    int32_t i_v4;        // 0x8bb8
    int32_t i_v5;        // 0x8bb8
    int32_t i_v6;        // 0x8bb8
    int32_t i_v7;        // 0x8bb8
    int32_t i_v8;        // 0x8bb8
    int32_t i_v9;        // 0x8bb8
    int32_t i_v10;       // 0x8bb8
    int32_t i_v11;       // 0x8bb8
    int32_t i_v12;       // 0x8bb8
    int32_t i_v13;       // 0x8bb8
    int32_t i_v14;       // 0x8bb8
    int32_t i_v15;       // 0x8bb8
    int32_t i_v16;       // 0x8bb8
    int32_t i_v17;       // 0x8bb8
    int32_t i_v18;       // 0x8cac
    int32_t i_v19;       // 0x8ca8
    if (i_a1 < 2) {
        goto lab_0x8e24;
    } else {
        int32_t i_v20 = *(int32_t *)(i_a2 + 4); // 0x8bd0
        unsigned char i_v21 = *(char *)i_v20;   // 0x8bd4
        if (i_v21 == 45) {
            int32_t i_v22; // 0x8bb8
            int32_t i_v23; // 0x8de8
            while (true) {
                // 0x8bfc
                int32_t i_v24; // 0x8bb8
                int32_t i_v25 = i_v24;
                int32_t i_v26; // 0x8bb8
                int32_t i_v27 = i_v26;
                int32_t i_v28; // 0x8bb8
                int32_t i_v29 = i_v28;
                int32_t i_v30; // 0x8bb8
                int32_t i_v31 = i_v30;
                int32_t i_v32; // 0x8bb8
                int32_t i_v33 = i_v32;
                int32_t i_v34; // 0x8bb8
                i_v22 = i_v34;
                int32_t i_v35; // 0x8bb8
                int32_t i_v36 = i_v35;
                unsigned char i_v37 = *(char *)(i_v22 + 1); // 0x8bfc
                int32_t i_v38 = (int32_t)i_v37 - 86;        // 0x8c00
                i_g13 = i_v38;
                int32_t i_v39 = i_v36; // 0x8c08
                int32_t i_v40 = i_v33; // 0x8c08
                int32_t i_v41 = i_v31; // 0x8c08
                int32_t i_v42 = 1;     // 0x8c08
                int32_t i_v43 = i_v27; // 0x8c08
                int32_t i_v44 = i_v25; // 0x8c08
                int32_t i_v45;         // 0x8bb8
                switch (i_v37) {
                case 86: {
                    // 0x8dd0
                    i_v39 = 1;
                    i_v40 = i_v33;
                    i_v41 = i_v31;
                    i_v42 = i_v29;
                    i_v43 = i_v27;
                    i_v44 = i_v25;
                }
                case 121: {
                lab_0x8ca8:
                    // 0x8ca8
                    i_v16 = i_v44;
                    i_v14 = i_v43;
                    i_v12 = i_v42;
                    i_v10 = i_v41;
                    i_v3 = i_v39;
                    i_v19 = i_v40 + 1;
                    i_v18 = i_v40 + 2;
                    i_v5 = i_v22;
                    i_v7 = i_v38;
                    if (i_v18 >= i_a1) {
                        goto lab_0x8cc8;
                    }
                    // break -> 0x8cb8
                    break;
                }
                case 114: {
                    // 0x8da8
                    i_v39 = i_v36;
                    i_v40 = i_v33;
                    i_v41 = 1;
                    i_v42 = i_v29;
                    i_v43 = i_v27;
                    i_v44 = i_v25;
                    // branch (via goto) -> 0x8ca8
                    goto lab_0x8ca8;
                }
                case 109: {
                    int32_t i_v46 = i_v45;
                    int32_t i_v47 = i_v33 + 2; // 0x8db4
                    i_v39 = i_v36;
                    i_v40 = i_v46;
                    i_v41 = i_v31;
                    i_v42 = i_v29;
                    i_v43 = i_v27;
                    i_v44 = i_v25;
                    if (i_v47 < i_a1) {
                        i_v39 = i_v36;
                        i_v40 = i_v46;
                        i_v41 = i_v31;
                        i_v42 = i_v29;
                        i_v43 = i_v27;
                        i_v44 = *(int32_t *)(4 * i_v47 + i_a2);
                    }
                    // branch (via goto) -> 0x8ca8
                    goto lab_0x8ca8;
                }
                case 102: {
                    // 0x8dc4
                    i_v39 = i_v36;
                    i_v40 = i_v33;
                    i_v41 = i_v31;
                    i_v42 = i_v29;
                    i_v43 = 1;
                    i_v44 = i_v25;
                    // branch (via goto) -> 0x8ca8
                    goto lab_0x8ca8;
                }
                default: {
                    // 0x8ddc
                    i_v23 = fprintf(p_g4, "Error: Unsupported option \"%s\"!\n",
                                    (char *)i_v22);
                    function_9b68(
                        i_v23, (int32_t) "Error: Unsupported option \"%s\"!\n",
                        i_v22, (int32_t)&p_g4);
                    // UNREACHABLE
                }
                }
                int32_t i_v48 = *(int32_t *)(4 * i_v18 + i_a2); // 0x8cb8
                unsigned char i_v49 = *(char *)i_v48;           // 0x8cbc
                i_v35 = i_v3;
                i_v45 = i_v18;
                i_v34 = i_v48;
                i_v32 = i_v19;
                i_v30 = i_v10;
                i_v28 = i_v12;
                i_v26 = i_v14;
                i_v24 = i_v16;
                if (i_v49 != 45) {
                    // 0x8cc8
                    i_v5 = i_v48;
                    i_v7 = i_v49;
                    goto lab_0x8cc8;
                }
            }
            // 0x8ddc
            i_v23 = fprintf(p_g4, "Error: Unsupported option \"%s\"!\n",
                            (char *)i_v22);
            function_9b68(i_v23,
                          (int32_t) "Error: Unsupported option \"%s\"!\n",
                          i_v22, (int32_t)&p_g4);
            // UNREACHABLE
        }
        // 0x8e28
        i_v4 = i_a2;
        i_v6 = i_v20;
        i_v8 = i_v21;
        i_v9 = 0;
        i_v11 = 0;
        i_v13 = 0;
        i_v15 = 0;
        i_v17 = 0;
        goto lab_0x8cd0;
    }
lab_0x8cc8:
    // 0x8cc8
    i_v4 = i_v18;
    i_v6 = i_v5;
    i_v8 = i_v7;
    i_v9 = i_v19;
    i_v11 = i_v10;
    i_v13 = i_v12;
    i_v15 = i_v14;
    i_v17 = i_v16;
    if (i_v3 != 0) {
        // 0x8df0
        fprintf(p_g4, "i2cset version %s\n", "3.1.0");
        exit(0);
        // UNREACHABLE
    }
    goto lab_0x8cd0;
lab_0x8e54:;
    // 0x8e54
    int32_t i_v68; // 0x8bb8
    int32_t i_v81 = i_v68;
    int32_t i_v118 = 0; // 0x8e58
    char *p_v66;        // bp-388, 0x8bb8
    if (i_v17 != 0) {
        int32_t i_v119 = strtol((char *)i_v17, &p_v66, 0); // 0x8e68
        if (i_v119 == 0 | *p_v66 != 0) {
            struct _IO_FILE *p_v120 = p_g4; // 0x8f10
            function_9b68(fwrite((int32_t *)"Error: Data value mask invalid!\n",
                                 1, 32, p_v120),
                          1, 32, (int32_t)p_v120);
            // UNREACHABLE
        }
        int32_t i_v121 = i_v81 - 1; // 0x8e8c
        int32_t i_v122;             // 0x8eb4
        if (i_v121 == 1 || i_v121 == 0) {
            // 0x9360
            i_v118 = i_v119;
            if (i_v119 > 255) {
                // 0x8ea0
                i_v122 =
                    fwrite((int32_t *)"Error: Data value mask out of range!\n",
                           1, 37, p_g4);
                function_9b68(i_v122, 1, 37, (int32_t)p_g4);
                // UNREACHABLE
            }
        } else {
            // 0x8e98
            i_v118 = i_v119;
            if (i_v119 >= 0x10000) {
                // 0x8ea0
                i_v122 =
                    fwrite((int32_t *)"Error: Data value mask out of range!\n",
                           1, 37, p_g4);
                function_9b68(i_v122, 1, 37, (int32_t)p_g4);
                // UNREACHABLE
            }
        }
    }
    // 0x9028
    int32_t i_v123;                                       // bp-380, 0x8bb8
    int32_t i_v62;                                        // 0x8ce4
    int32_t i_v83 = function_9d08(i_v62, &i_v123, 20, 0); // 0x9038
    if (i_v83 < 0) {
        // 0x917c
        exit(1);
        // UNREACHABLE
    }
    // 0x9044
    if (ioctl(i_v83, 1797) < 0) {
        int32_t i_v124 = *__errno_location(); // 0x938c
        fprintf(p_g4,
                "Error: Could not get the adapter functionality matrix: %s\n",
                strerror(i_v124));
        // 0x917c
        exit(1);
        // UNREACHABLE
    }
    int32_t i_v125 = i_v118;
    int32_t i_v77 = i_v81 - 1; // 0x905c
    i_g14 = i_v77;
    int32_t i_v126; // 0x8bb8
    switch (i_v81) {
    case 1: {
        if ((i_v126 & 0x40000) == 0) {
            // 0x9928
            fprintf(p_g4, "Error: Adapter does not have %s capability\n",
                    "SMBus send byte");
            // 0x917c
            exit(1);
            // UNREACHABLE
        }
        // break -> 0x9208
        break;
    }
    case 2: {
        if ((i_v126 & 0x100000) == 0) {
            // 0x9654
            fprintf(p_g4, "Error: Adapter does not have %s capability\n",
                    "SMBus write byte");
            // 0x917c
            exit(1);
            // UNREACHABLE
        }
        // break -> 0x9208
        break;
    }
    case 3: {
        if ((i_v126 & 0x400000) == 0) {
            // 0x9630
            fprintf(p_g4, "Error: Adapter does not have %s capability\n",
                    "SMBus write word");
            // 0x917c
            exit(1);
            // UNREACHABLE
        }
        // break -> 0x9208
        break;
    }
    case 8: {
        if ((i_v126 & 0x8000000) == 0) {
            // 0x95e8
            fprintf(p_g4, "Error: Adapter does not have %s capability\n",
                    "I2C block write");
            // 0x917c
            exit(1);
            // UNREACHABLE
        }
        // break -> 0x9208
        break;
    }
    case 5: {
        if ((i_v126 & 0x2000000) == 0) {
            // 0x960c
            fprintf(p_g4, "Error: Adapter does not have %s capability\n",
                    "SMBus block write");
            // 0x917c
            exit(1);
            // UNREACHABLE
        }
        // break -> 0x9208
        break;
    }
    }
    int32_t i_v67; // 0x8bb8
    if ((i_v126 & 9) == 0 == (i_v67 != 0)) {
        // 0x9220
        fwrite((int32_t *)"Warning: Adapter does not seem to support PEC\n", 1,
               46, p_g4);
    }
    // 0x9238
    int32_t i_v64; // 0x8cfc
    if (function_a4d4(i_v83, i_v64, i_v15) != 0) {
        // 0x917c
        exit(1);
        // UNREACHABLE
    }
    int32_t i_v70;  // 0x8bb8
    int32_t i_v69;  // 0x8bb8
    int32_t i_v127; // bp-360, 0x8bb8
    uint32_t i_v65; // 0x8d18
    if (i_v13 == 0) {
        // 0x93a8
        fwrite((int32_t *)"WARNING! This program can confuse your I2C bus, "
                          "cause data loss and worse!\n",
               1, 75, p_g4);
        uint32_t i_v128 = i_v64 - 80; // 0x93c4
        int32_t i_v129 = 0;           // 0x93d0
        if (i_v128 >= 7 != i_v128 != 7) {
            // 0x93d4
            fwrite((int32_t *)"DANGEROUS! Writing to a serial EEPROM on a "
                              "memory DIMM\nmay render your memory USELESS and "
                              "make your system UNBOOTABLE!\n",
                   1, 119, p_g4);
            i_v129 = 1;
        }
        // 0x93ec
        fprintf(p_g4,
                "I will write to device file %s, chip address 0x%02x, data "
                "address\n0x%02x, ",
                &i_v123, i_v64, i_v65);
        if (i_v81 == 1) {
            // 0x953c
            fwrite((int32_t *)"no data.\n", 1, 9, p_g4);
        } else {
            // 0x9418
            switch (i_v81) {
            case 8: {
            }
            case 5: {
                // 0x94e8
                fwrite((int32_t *)"data", 1, 4, p_g4);
                if (i_v69 > 0) {
                    int32_t i_v130 = 0; // 0x9528
                    unsigned char i_v131 =
                        *(char *)(i_v130 + (int32_t)&i_v127); // 0x9524
                    i_v130++;
                    fprintf(p_g4, " 0x%02x", (int32_t)i_v131);
                    while (i_v69 > i_v130) {
                        // 0x9518
                        i_v131 = *(char *)(i_v130 + (int32_t)&i_v127);
                        i_v130++;
                        fprintf(p_g4, " 0x%02x", (int32_t)i_v131);
                    }
                }
                // 0x9940
                fprintf(p_g4, ", mode %s.\n",
                        i_v81 != 5 ? "i2c block" : "smbus block");
                // break -> 0x9474
                break;
            }
            default: {
                int32_t i_v132 =
                    i_v81 == 2 ? (int32_t) "byte" : (int32_t) "word";
                int32_t i_v133 =
                    i_v125 == 0 ? (int32_t)&p_g11 : (int32_t) " (masked)";
                fprintf(p_g4, "data 0x%02x%s, mode %s.\n", i_v70,
                        (char *)i_v133, (char *)i_v132);
                // break -> 0x9474
                break;
            }
            }
        }
        if (i_v67 != 0) {
            // 0x9480
            fwrite((int32_t *)"PEC checking enabled.\n", 1, 22, p_g4);
        }
        int32_t i_v134 = i_v129 == 0 ? (int32_t) "Y/n" : (int32_t) "y/N";
        fprintf(p_g4, "Continue? [%s] ", (char *)i_v134);
        fflush(p_g4);
        if (function_a544(i_v129 ^ 1) == 0) {
            // 0x94cc
            fwrite((int32_t *)"Aborting on user request.\n", 1, 26, p_g4);
            exit(0);
            // UNREACHABLE
        }
    }
    int32_t i_v135 = i_v70; // 0x925c
    if (i_v125 != 0) {
        int32_t i_v136; // 0x8bb8
        switch (i_v81) {
        case 1: {
            int32_t i_v137 = function_8b84(); // 0x95d0
            i_v136 = i_v137;
            if (i_v137 < 0) {
                // 0x9570
                fwrite((int32_t *)"Error: Failed to read old value\n", 1, 32,
                       p_g4);
                exit(1);
                // UNREACHABLE
            }
            // break -> 0x92a8
            break;
        }
        case 3: {
            // 0x9590
            int32_t i_v138; // bp-328, 0x8bb8
            if (function_8b54(i_v83, 1, i_v65 % 256, 3, &i_v138) != 0) {
                // 0x9570
                fwrite((int32_t *)"Error: Failed to read old value\n", 1, 32,
                       p_g4);
                exit(1);
                // UNREACHABLE
            }
            // 0x95b8
            i_v136 = i_v138 % 0x10000;
            // break -> 0x92a8
            break;
        }
        default: {
            // 0x9274
            int32_t i_v139; // bp-292, 0x8bb8
            if (function_8b54(i_v83, 1, i_v65 % 256, 2, &i_v139) != 0) {
                // 0x9570
                fwrite((int32_t *)"Error: Failed to read old value\n", 1, 32,
                       p_g4);
                exit(1);
                // UNREACHABLE
            }
            // 0x929c
            i_v136 = i_v139 % 256;
            // break -> 0x92a8
            break;
        }
        }
        int32_t i_v140 = i_v136 & -1 - i_v125 | i_v125 & i_v70; // 0x92b4
        i_v135 = i_v140;
        if (i_v13 == 0) {
            int32_t i_v141 = i_v81 == 3 ? 4 : 2;
            fprintf(p_g4,
                    "Old value 0x%0*x, write mask 0x%0*x: Will write 0x%0*x to "
                    "register 0x%02x\n",
                    i_v141, i_v136, i_v141, i_v125, i_v141, i_v140, i_v65);
            fwrite((int32_t *)"Continue? [Y/n] ", 1, 16, p_g4);
            fflush(p_g4);
            i_v135 = i_v140;
            if (function_a544(1) == 0) {
                // 0x9554
                fwrite((int32_t *)"Aborting on user request.\n", 1, 26, p_g4);
                exit(0);
                // UNREACHABLE
            }
        }
    }
    int32_t i_v93 = i_v135;
    struct _IO_FILE *p_v108; // 0x8bb8
    char *p_v107;            // 0x8bb8
    int32_t i_v106;          // 0x8bb8
    if (i_v67 == 0) {
        goto lab_0x9330;
    } else {
        // 0x9830
        if (ioctl(i_v83, 1800) < 0) {
            int32_t i_v142 = *__errno_location(); // 0x9854
            i_v106 = (int32_t) "Error: Could not set PEC: %s\n";
            p_v107 = strerror(i_v142);
            p_v108 = p_g4;
            goto lab_0x9170;
        } else {
            goto lab_0x9330;
        }
    }
lab_0x8e24:;
    // 0x8e24
    int32_t i_v51; // 0x8bb8
    int32_t i_v52; // 0x8bb8
    function_9b68(i_v1, i_v2, i_v51, i_v52);
    // UNREACHABLE
lab_0x8cd0:;
    int32_t i_v50 = i_v9 + 3; // 0x8cd0
    i_v1 = i_a1;
    i_v2 = i_v4;
    i_v51 = i_v6;
    i_v52 = i_v8;
    bool i_v53;    // 0x8bb8
    int32_t i_v54; // 0x8bb8
    int32_t i_v55; // 0x8bb8
    int32_t i_v56; // 0x8bb8
    int32_t i_v57; // 0x8d38
    int32_t i_v58; // 0x8d44
    int32_t i_v59; // 0x8d54
    char i_v60;    // 0x8ecc
    if (i_v50 < i_a1) {
        int32_t i_v61 = i_v9 + 1; // 0x8cdc
        i_v62 = function_a38c(*(int32_t *)(4 * i_v61 + i_a2));
        i_v1 = i_v62;
        i_v2 = i_v4;
        i_v51 = i_v61;
        i_v52 = i_v8;
        if (i_v62 < 0) {
            goto lab_0x8e24;
        } else {
            int32_t i_v63 = i_v9 + 2; // 0x8cf4
            i_v64 = function_9c74(*(int32_t *)(4 * i_v63 + i_a2));
            i_v1 = i_v64;
            i_v2 = i_v4;
            i_v51 = i_v63;
            i_v52 = i_v8;
            if (i_v64 < 0) {
                goto lab_0x8e24;
            } else {
                // 0x8d0c
                i_v65 =
                    strtol((char *)*(int32_t *)(4 * i_v50 + i_a2), &p_v66, 0);
                if (*p_v66 == 0) {
                    if (i_v65 >= 255 == (i_v65 != 255)) {
                        goto lab_0x8e0c;
                    } else {
                        // 0x8d38
                        i_v57 = i_v9 + 4;
                        i_v67 = 0;
                        i_v68 = 1;
                        i_v69 = 0;
                        i_v70 = -1;
                        if (i_v57 == i_a1) {
                            goto lab_0x8e54;
                        } else {
                            // 0x8d44
                            i_v58 = i_v9 + 5;
                            if (i_v58 == i_a1) {
                                int32_t i_v71 =
                                    *(int32_t *)(4 * i_v57 + i_a2); // 0x8ebc
                                i_v54 = 0;
                                i_v55 = 2;
                                if (*(char *)i_v71 == 99) {
                                    // 0x8ecc
                                    i_v60 = *(char *)(i_v71 + 1);
                                    i_v54 = 0;
                                    i_v55 = 2;
                                    switch (i_v60) {
                                    case 0: {
                                        goto lab_0x8eec;
                                    }
                                    case 112: {
                                        // 0x8ee0
                                        i_v54 = 0;
                                        i_v55 = 2;
                                        if (*(char *)(i_v71 + 2) == 0) {
                                            goto lab_0x8eec;
                                        } else {
                                            goto lab_0x8f8c;
                                        }
                                    }
                                    default: {
                                        goto lab_0x8f8c;
                                    }
                                    }
                                } else {
                                    goto lab_0x8f8c;
                                }
                            } else {
                                // 0x8d50
                                i_v59 = *(int32_t *)(4 * i_a1 - 4 + i_a2);
                                char *p_v72 = (char *)i_v59;    // 0x8d64
                                uint32_t i_v73 = strlen(p_v72); // 0x8d64
                                int32_t i_v74;                  // 0x8da0
                                if (i_v73 >= 2 == (i_v73 != 2)) {
                                    // 0x8d94
                                    i_v74 = fprintf(
                                        p_g4, "Error: Invalid mode '%s'!\n",
                                        p_v72);
                                    function_9b68(
                                        i_v74,
                                        (int32_t) "Error: Invalid mode '%s'!\n",
                                        i_v59, (int32_t)&p_g4);
                                    // UNREACHABLE
                                }
                                if (i_v73 == 2) {
                                    // 0x8f70
                                    if (*(char *)(i_v59 + 1) != 112) {
                                        // 0x8d94
                                        i_v74 = fprintf(
                                            p_g4, "Error: Invalid mode '%s'!\n",
                                            p_v72);
                                        function_9b68(
                                            i_v74,
                                            (int32_t) "Error: Invalid mode "
                                                      "'%s'!\n",
                                            i_v59, (int32_t)&p_g4);
                                        // UNREACHABLE
                                    }
                                }
                                unsigned char i_v75 = *p_v72; // 0x8d7c
                                if (i_v75 == 105) {
                                    // 0x91cc
                                    i_v56 = 8;
                                    i_v53 = false;
                                    if (*(char *)(i_v59 + 1) == 112) {
                                        struct _IO_FILE *p_v76 = p_g4; // 0x91fc
                                        function_9b68(
                                            fwrite(
                                                (int32_t *)"Error: PEC not "
                                                           "supported for I2C "
                                                           "block writes!\n",
                                                1, 47, p_v76),
                                            1, 47, (int32_t)p_v76);
                                        // UNREACHABLE
                                    }
                                    goto lab_0x919c;
                                } else {
                                    if (i_v75 < 105) {
                                        // 0x8d8c
                                        if (i_v75 != 98) {
                                        lab_0x8d94:
                                            // 0x8d94
                                            i_v74 = fprintf(
                                                p_g4,
                                                "Error: Invalid mode '%s'!\n",
                                                p_v72);
                                            function_9b68(
                                                i_v74,
                                                (int32_t) "Error: Invalid mode "
                                                          "'%s'!\n",
                                                i_v59, (int32_t)&p_g4);
                                            // UNREACHABLE
                                        }
                                        goto lab_0x8f34;
                                    } else {
                                        // 0x8f1c
                                        switch (i_v75) {
                                        case 115: {
                                            // 0x9184
                                            i_v56 = 5;
                                            i_v53 = *(char *)(i_v59 + 1) == 112;
                                            goto lab_0x919c;
                                        }
                                        case 119: {
                                            goto lab_0x8f34;
                                        }
                                        default: {
                                            goto lab_0x8d94;
                                        }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    goto lab_0x8e0c;
                }
            }
        }
    } else {
        goto lab_0x8e24;
    }
lab_0x8e0c:
    // 0x8e0c
    i_v1 = fwrite((int32_t *)"Error: Data address invalid!\n", 1, 29, p_g4);
    i_v2 = 1;
    i_v51 = 29;
    i_v52 = (int32_t)p_g4;
    goto lab_0x8e24;
lab_0x9330:
    // 0x9330
    i_g16 = i_v77;
    int32_t i_v78; // 0x8bb8
    int32_t i_v79; // 0x8bb8
    int32_t i_v80; // bp-361, 0x8bb8
    switch (i_v81) {
    case 1: {
        int32_t i_v82 = i_v65 % 256; // 0x9748
        i_v78 = function_8b54(i_v83, 0, i_v82, 1, NULL);
        i_v79 = i_v82;
        // break -> 0x9694
        break;
    }
    case 8: {
        uint32_t i_v84 = i_v69 % 256; // 0x9870
        uint32_t i_v85 = i_v84 < 32 ? i_v84 : 32;
        int32_t i_v86; // bp-184, 0x8bb8
        if (i_v85 >= 1) {
            int32_t i_v87 = &i_v80; // 0x9890
            uint32_t i_v88 = 1;
            i_v87++;
            char i_v89 = *(char *)i_v87; // 0x9890
            *(char *)(i_v88 + (int32_t)&i_v86) = i_v89;
            int32_t i_v90 = i_v88 + 1; // 0x98a0
            while (i_v88 < i_v85) {
                // 0x9890
                i_v88 = i_v90;
                i_v87++;
                i_v89 = *(char *)i_v87;
                *(char *)(i_v88 + (int32_t)&i_v86) = i_v89;
                i_v90 = i_v88 + 1;
            }
        }
        int32_t i_v91 = i_v65 % 256; // 0x9884
        i_v86 = i_v85;
        i_v78 = function_8b54(i_v83, 0, i_v91, 6, &i_v86);
        i_v79 = i_v91;
        // break -> 0x9694
        break;
    }
    case 3: {
        int16_t i_v92 = i_v93;       // bp-256, 0x967c
        int32_t i_v94 = i_v65 % 256; // 0x9680
        i_v78 = function_8b54(i_v83, 0, i_v94, 3, (int32_t *)&i_v92);
        i_v79 = i_v94;
        // break -> 0x9694
        break;
    }
    case 5: {
        uint32_t i_v95 = i_v69 % 256; // 0x98c8
        uint32_t i_v96 = i_v95 < 32 ? i_v95 : 32;
        int32_t i_v97; // bp-220, 0x8bb8
        if (i_v96 >= 1) {
            int32_t i_v98 = &i_v80; // 0x98e8
            uint32_t i_v99 = 1;
            i_v98++;
            char i_v100 = *(char *)i_v98; // 0x98e8
            *(char *)(i_v99 + (int32_t)&i_v97) = i_v100;
            int32_t i_v101 = i_v99 + 1; // 0x98f8
            while (i_v99 < i_v96) {
                // 0x98e8
                i_v99 = i_v101;
                i_v98++;
                i_v100 = *(char *)i_v98;
                *(char *)(i_v99 + (int32_t)&i_v97) = i_v100;
                i_v101 = i_v99 + 1;
            }
        }
        int32_t i_v102 = i_v65 % 256; // 0x98e0
        i_v97 = i_v96;
        i_v78 = function_8b54(i_v83, 0, i_v102, 5, &i_v97);
        i_v79 = i_v102;
        // break -> 0x9694
        break;
    }
    default: {
        char i_v103 = i_v93;          // bp-148, 0x9814
        int32_t i_v104 = i_v65 % 256; // 0x9818
        i_v78 = function_8b54(i_v83, 0, i_v104, 2, (int32_t *)&i_v103);
        i_v79 = i_v104;
        // break -> 0x9694
        break;
    }
    }
    // 0x9694
    if (i_v78 < 0) {
        // 0x97dc
        fwrite((int32_t *)"Error: Write failed\n", 1, 20, p_g4);
        close(i_v83);
        exit(1);
        // UNREACHABLE
    }
    // 0x969c
    if (i_v67 == 0) {
        goto lab_0x96a8;
    } else {
        // 0x9138
        if (ioctl(i_v83, 1800) < 0) {
            int32_t i_v105 = *__errno_location(); // 0x915c
            i_v106 = (int32_t) "Error: Could not clear PEC: %s\n";
            p_v107 = strerror(i_v105);
            p_v108 = p_g4;
            goto lab_0x9170;
        } else {
            goto lab_0x96a8;
        }
    }
lab_0x96a8:
    if (i_v11 == 0) {
        // 0x97cc
        close(i_v83);
        exit(0);
        // UNREACHABLE
    }
    int32_t i_v109; // 0x8bb8
    int32_t i_v110; // 0x8bb8
    int32_t i_v111; // 0x8bb8
    switch (i_v81) {
    case 1: {
        int32_t i_v112 = function_8b84(); // 0x97c0
        close(i_v83);
        i_v109 = i_v65;
        i_v110 = i_v112;
        if (i_v112 < 0) {
            // 0x9774
            puts("Warning - readback failed");
            // 0x9728
            exit(0);
            // UNREACHABLE
        }
        goto lab_0x96fc;
    }
    case 3: {
        // 0x9788
        int32_t i_v113; // bp-112, 0x8bb8
        if (function_8b54(i_v83, 1, i_v79, 3, &i_v113) != 0) {
            // 0x96ec
            close(i_v83);
            // 0x9774
            puts("Warning - readback failed");
            // 0x9728
            exit(0);
            // UNREACHABLE
        }
        // 0x97ac
        i_v111 = i_v113 % 0x10000;
        goto lab_0x96ec_2;
    }
    default: {
        // 0x96c4
        int32_t i_v114; // bp-76, 0x8bb8
        if (function_8b54(i_v83, 1, i_v79, 2, &i_v114) != 0) {
            // 0x96ec
            close(i_v83);
            // 0x9774
            puts("Warning - readback failed");
            // 0x9728
            exit(0);
            // UNREACHABLE
        }
        // 0x96e8
        i_v111 = i_v114 % 256;
        goto lab_0x96ec_2;
    }
    }
lab_0x8f8c:;
    int32_t i_v115 =
        strtol((char *)*(int32_t *)(4 * i_v57 + i_a2), &p_v66, 0); // 0x8f98
    int32_t i_v116;                                                // 0x901c
    if (i_v115 < 0 | *p_v66 != 0) {
        // 0x9008
        i_v116 = fwrite((int32_t *)"Error: Data value invalid!\n", 1, 27, p_g4);
        function_9b68(i_v116, 1, 27, (int32_t)p_g4);
        // UNREACHABLE
    }
    // 0x8fb8
    int32_t i_v117; // 0x9000
    if (i_v55 == 2 && i_v115 >= 256) {
        // 0x8fec
        i_v117 =
            fwrite((int32_t *)"Error: Data value out of range!\n", 1, 32, p_g4);
        function_9b68(i_v117, 1, 32, (int32_t)p_g4);
        // UNREACHABLE
    }
    // 0x8fd8
    i_v67 = i_v54;
    i_v68 = i_v55;
    i_v69 = 0;
    i_v70 = i_v115;
    if (i_v115 > 0xffff ? i_v55 == 3 : i_v115 == 0x10000) {
        // 0x8fec
        i_v117 =
            fwrite((int32_t *)"Error: Data value out of range!\n", 1, 32, p_g4);
        function_9b68(i_v117, 1, 32, (int32_t)p_g4);
        // UNREACHABLE
    }
    goto lab_0x8e54;
lab_0x9170:
    // 0x9170
    fprintf(p_v108, (char *)i_v106, p_v107);
    close(i_v83);
    // 0x917c
    exit(1);
    // UNREACHABLE
lab_0x8eec:
    // 0x8eec
    i_v67 = i_v60 == 112;
    i_v68 = 1;
    i_v69 = 0;
    i_v70 = -1;
    goto lab_0x8e54;
lab_0x919c:
    if (i_v17 != 0) {
        struct _IO_FILE *p_v143 = p_g4; // 0x91b4
        function_9b68(
            fwrite((int32_t *)"Error: Mask not supported for block writes!\n",
                   1, 44, p_v143),
            1, 44, (int32_t)p_v143);
        // UNREACHABLE
    }
    bool i_v144 = i_v53;    // 0x909c
    int32_t i_v145 = i_v56; // 0x909c
    int32_t i_v146;         // 0x8f68
    if (i_v9 + 37 < i_a1) {
        // 0x8f54
        i_v146 = fwrite((int32_t *)"Error: Too many arguments!\n", 1, 27, p_g4);
        function_9b68(i_v146, 1, 27, (int32_t)p_g4);
        // UNREACHABLE
    }
    goto lab_0x90a0;
lab_0x96ec_2:
    // 0x96ec
    close(i_v83);
    i_v109 = i_v93;
    i_v110 = i_v111;
    goto lab_0x96fc;
lab_0x96fc:;
    int32_t i_v151 = i_v81 == 3 ? 4 : 2;
    if (i_v110 == i_v109) {
        // 0x9758
        printf("Value 0x%0*x written, readback matched\n", i_v151, i_v109);
    } else {
        // 0x9708
        printf("Warning - data mismatch - wrote 0x%0*x, read back 0x%0*x\n",
               i_v151, i_v109, i_v151, i_v110);
    }
    // 0x9728
    exit(0);
    // UNREACHABLE
lab_0x90a0:;
    int32_t i_v147 = i_v144;
    i_g15 = i_v145 - 2;
    i_v67 = i_v147;
    i_v68 = i_v145;
    i_v69 = 0;
    i_v70 = -1;
    i_v54 = i_v147;
    i_v55 = i_v145;
    switch (i_v145) {
    case 2: {
        goto lab_0x8f8c;
    }
    case 3: {
        goto lab_0x8f8c;
    }
    case 8: {
        goto lab_0x90d0;
    }
    case 5: {
        goto lab_0x90d0;
    }
    default: {
        goto lab_0x8e54;
    }
    }
lab_0x8f34:
    // 0x8f34
    i_v144 = *(char *)(i_v59 + 1) == 112;
    i_v145 = 3;
    if (i_v9 + 6 != i_a1) {
        // 0x8f54
        i_v146 = fwrite((int32_t *)"Error: Too many arguments!\n", 1, 27, p_g4);
        function_9b68(i_v146, 1, 27, (int32_t)p_g4);
        // UNREACHABLE
    }
    goto lab_0x90a0;
lab_0x90d0:
    // 0x90d0
    i_v67 = i_v147;
    i_v68 = i_v145;
    i_v69 = 0;
    i_v70 = -1;
    if (i_v58 < i_a1) {
        int32_t i_v148 = 0;               // 0x9118
        int32_t i_v149 = 4 * i_v9 + i_a2; // 0x8bb8
        int32_t i_v150 =
            strtol((char *)*(int32_t *)(i_v149 + 16), &p_v66, 0); // 0x90e8
        while (!((i_v150 < 0 | *p_v66 != 0))) {
            if (i_v150 > 255) {
                // 0x8fec
                i_v117 = fwrite((int32_t *)"Error: Data value out of range!\n",
                                1, 32, p_g4);
                function_9b68(i_v117, 1, 32, (int32_t)p_g4);
                // UNREACHABLE
            }
            // 0x9110
            *(char *)(i_v148 + (int32_t)&i_v127) = (char)i_v150;
            i_v148++;
            i_v67 = i_v147;
            i_v68 = i_v145;
            i_v69 = i_v148;
            i_v70 = -1;
            i_v149 += 4;
            if (i_v148 + i_v58 >= i_a1) {
                goto lab_0x8e54;
            }
            i_v150 = strtol((char *)*(int32_t *)(i_v149 + 16), &p_v66, 0);
        }
        // 0x9008
        i_v116 = fwrite((int32_t *)"Error: Data value invalid!\n", 1, 27, p_g4);
        function_9b68(i_v116, 1, 27, (int32_t)p_g4);
        // UNREACHABLE
    }
    goto lab_0x8e54;
}

// Address range: 0x9a34 - 0x9a64
int32_t entry_point(int32_t i_a1, int32_t i_a2) {
    // 0x9a34
    int32_t i_v1; // 0x9a34
    __libc_start_main(0x8bb8, i_a2, (char **)&i_v1, (void (*)()) & p_g9,
                      (void (*)()) & p_g10, (void (*)())i_a1);
    abort();
    return &i_g17;
}

// Address range: 0x9a70 - 0x9a8c
int32_t function_9a70(void) {
    int32_t i_v1 =
        *(int32_t *)((int32_t)&i_g8 + (int32_t)&i_g7 + 168); // 0x9a7c
    if (i_v1 == 0) {
        int32_t i_v2; // 0x9a70
        return i_v2;
    }
    // 0x9a88
    __gmon_start__();
    return &i_g17;
}

// Address range: 0x9a94 - 0x9ac0
int32_t function_9a94(int32_t i_a1, int32_t i_a2, int32_t i_a3, char i_a4) {
    // 0x9a94
    return 0x131cc;
}

// Address range: 0x9acc - 0x9b00
int32_t function_9acc(int32_t *p_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x9acc
    return 0x131cc;
}

// Address range: 0x9b0c - 0x9b30
int32_t function_9b0c(void) {
    // 0x9b0c
    int32_t i_v1; // 0x9b0c
    if (*(char *)&p_g6 != 0) {
        return i_v1;
    }
    int32_t i_v2 = function_9a94(i_v1, i_v1, i_v1, 0); // 0x9b20
    *(char *)&p_g6 = 1;
    return i_v2;
}

// Address range: 0x9b34 - 0x9b60
int32_t function_9b34(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x9b34
    return function_9acc(&i_g3, i_a2, i_a3, i_a4);
}

// Address range: 0x9b68 - 0x9b94
int32_t function_9b68(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x9b68
    fwrite(
        (int32_t
             *)((int32_t) "Usage: i2cset [-f] [-y] [-m MASK] I2CBUS "
                          "CHIP-ADDRESS DATA-ADDRESS [VALUE] ... [MODE]\n  "
                          "I2CBUS is an integer or an I2C bus name\n  ADDRESS "
                          "is an integer (0x03 - 0x77)\n  MODE is one of:\n    "
                          "c (byte, no value)\n    b (byte data, default)\n    "
                          "w (word data)\n    i (I2C block data)\n    s (SMBus "
                          "block data)\n    Append p for SMBus PEC\n" &
                0xffff),
        1, 327, p_g4);
    exit(1);
    // UNREACHABLE
}

// Address range: 0x9b94 - 0x9bf8
int32_t function_9b94(int32_t i_a1) {
    int32_t i_v1 = strlen((char *)i_a1); // 0x9b9c
    int32_t i_v2 = i_v1 - 1;             // 0x9ba0
    if (i_v2 < 0) {
        // 0x9bf0
        return i_v2 + 2;
    }
    char *p_v3 = (char *)(i_v2 + i_a1);
    int32_t i_v4 = i_v2; // 0x9b94
    int32_t i_v5;        // 0x9b94
    int32_t i_v6;        // 0x9b94
    switch (*p_v3) {
    case 32: {
    }
    case 10: {
        // 0x9bbc
        *p_v3 = 0;
        if (i_v2 == 0) {
            // 0x9bf0
            return 1;
        }
        int32_t i_v7 = i_v1 - 2;
        i_v5 = i_v7;
        i_v6 = i_v7 + i_a1;
        // break -> 0x9bcc
        break;
    }
    default: {
        // 0x9bf0
        return i_v4 + 2;
    }
    }
    int32_t i_v8; // 0x9b94
    char *p_v9;   // 0x9b94
    while (true) {
    lab_0x9bcc:
        // 0x9bcc
        i_v8 = i_v5;
        p_v9 = (char *)i_v6;
        i_v4 = i_v8;
        switch (*p_v9) {
        case 32: {
            goto lab_0x9bdc;
        }
        case 10: {
            goto lab_0x9bdc;
        }
        default: {
            return i_v4 + 2;
        }
        }
    }
    // 0x9bf0
    return i_v4 + 2;
lab_0x9bdc:
    // 0x9bdc
    *p_v9 = 0;
    i_v5 = i_v8 - 1;
    i_v6--;
    i_v4 = -1;
    if (i_v8 == 0) {
        return i_v4 + 2;
    }
    goto lab_0x9bcc;
}

// Address range: 0x9bf8 - 0x9c30
int32_t function_9bf8(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    int32_t i_v1 = *(int32_t *)(i_a1 + 4); // 0x9c00
    int32_t i_v2 = i_a1;                   // 0x9c0c
    if (i_v1 == 0) {
        // 0x9c24
        free((int32_t *)i_a1);
        return &i_g17;
    }
    free((int32_t *)i_v1);
    int32_t i_v3 = *(int32_t *)(i_v2 + 20); // 0x9c18
    i_v2 += 16;
    while (i_v3 != 0) {
        // 0x9c10
        free((int32_t *)i_v3);
        i_v3 = *(int32_t *)(i_v2 + 20);
        i_v2 += 16;
    }
    // 0x9c24
    free((int32_t *)i_a1);
    return &i_g17;
}

// Address range: 0x9c30 - 0x9c74
int32_t function_9c30(int32_t i_a1, int32_t i_a2) {
    int32_t i_v1 = 16 * i_a2;                       // 0x9c38
    int32_t i_v2 = i_v1 + 128;                      // 0x9c40
    int32_t *p_v3 = realloc((int32_t *)i_a1, i_v2); // 0x9c44
    int32_t i_v4 = (int32_t)p_v3;                   // 0x9c44
    if (p_v3 == NULL) {
        // 0x9c68
        int32_t i_v5; // 0x9c30
        function_9bf8(i_a1, i_v2, i_v5, i_v5);
    } else {
        // 0x9c50
        memset((int32_t *)(i_v1 + i_v4), 0, 128);
    }
    // 0x9c60
    return i_v4;
}

// Address range: 0x9c74 - 0x9cfc
int32_t function_9c74(int32_t i_a1) {
    // 0x9c74
    char *p_v1;                                    // bp-12, 0x9c74
    int32_t i_v2 = strtol((char *)i_a1, &p_v1, 0); // 0x9c88
    if ((char)i_v2 == 0 | *p_v1 != 0) {
        // 0x9cbc
        fwrite((int32_t *)"Error: Chip address is not a number!\n", 1, 37,
               p_g4);
        // 0x9cb4
        return -1;
    }
    uint32_t i_v3 = i_v2 - 3; // 0x9ca8
    int32_t i_v4 = i_v2;      // 0x9cb0
    if (i_v3 >= 116 == (i_v3 != 116)) {
        // 0x9cdc
        fwrite((int32_t *)"Error: Chip address out of range (0x03-0x77)!\n", 1,
               46, p_g4);
        i_v4 = -2;
    }
    // 0x9cb4
    return i_v4;
}

// Address range: 0x9d08 - 0x9e20
int32_t function_9d08(int32_t i_a1, int32_t *p_a2, int32_t i_a3,
                      uint32_t i_a4) {
    // 0x9d08
    snprintf((char *)p_a2, i_a3, "/dev/i2c/%d", i_a1);
    *(char *)(i_a3 - 1 + (int32_t)p_a2) = 0;
    int32_t i_v1 = open((char *)p_a2, O_RDWR); // 0x9d48
    if (i_v1 >= 0) {
        // 0x9d54
        return i_v1;
    }
    int32_t *p_v2 = __errno_location(); // 0x9d60
    int32_t i_v3 = i_v1;                // 0x9d08
    switch (*p_v2) {
    case 20: {
    }
    case 2: {
        // 0x9dd4
        sprintf((char *)p_a2, "/dev/i2c-%d", i_a1);
        i_v3 = open((char *)p_a2, O_RDWR);
        // break -> 0x9d78
        break;
    }
    }
    // 0x9d78
    if (((i_a4 > 1 ? i_a4 : 1) - i_a4 & (int32_t)(i_v3 < 0)) == 0) {
        // 0x9d54
        return i_v3;
    }
    int32_t i_v4 = *p_v2; // 0x9d88
    char *p_v5 = strerror(i_v4);
    if (i_v4 == 2) {
        // 0x9df8
        fprintf(
            p_g4,
            "Error: Could not open file `/dev/i2c-%d' or `/dev/i2c/%d': %s\n",
            i_a1, i_a1, p_v5);
        // 0x9d54
        return i_v3;
    }
    // 0x9d94
    fprintf(p_g4, "Error: Could not open file `%s': %s\n", p_a2, p_v5);
    if (*p_v2 == 13) {
        // 0x9dc0
        fwrite((int32_t *)"Run as root?\n", 1, 13, p_g4);
    }
    // 0x9d54
    return i_v3;
}

// Address range: 0x9e38 - 0xa34c
int32_t function_9e38(void) {
    // 0x9e38
    int32_t i_v1; // 0x9e38
    uint32_t i_v2 = i_v1;
    int32_t *p_v3 = calloc(8, 16); // 0x9e48
    int32_t i_v4 = (int32_t)p_v3;  // 0x9e48
    if (p_v3 == NULL) {
        // 0x9fac
        return i_v4;
    }
    struct _IO_FILE *p_v5 = fopen("/proc/bus/i2c", "r"); // 0x9e60
    struct dirent *p_v6;                                 // 0x9e38
    int32_t i_v7;                                        // 0x9e38
    int32_t i_v8;                                        // bp-296, 0x9e38
    int32_t i_v9;                                        // bp-552, 0x9e38
    int32_t i_v10;                                       // 0x9e38
    int32_t i_v11;                                       // 0x9e38
    int32_t i_v12;                                       // 0x9e38
    struct __dirstream *p_v13;                           // 0xa084
    if (p_v5 == NULL) {
        struct _IO_FILE *p_v14 = fopen("/proc/mounts", "r"); // 0x9fec
        if (p_v14 == NULL) {
            // 0x9fac
            return i_v4;
        }
        while (fgets((char *)&i_v8, 255, p_v14) != NULL) {
            // 0xa020
            int32_t i_v15; // bp-808, 0x9e38
            sscanf((char *)&i_v8, "%*[^ ] %[^ ] %[^ ] %*s\n", &i_v9, &i_v15);
            if (strcasecmp((char *)&i_v15, "sysfs") == 0) {
                // 0xa038
                fclose(p_v14);
                int32_t i_v16 =
                    strlen((char *)&i_v9) + (int32_t)&i_v9; // 0xa058
                *(int32_t *)i_v16 = 0x616c632f;
                *(int16_t *)(i_v16 + 12) = 0x7665;
                *(int32_t *)(i_v16 + 4) = 0x692f7373;
                *(int32_t *)(i_v16 + 8) = 0x642d6332;
                *(char *)(i_v16 + 14) = 0;
                p_v13 = opendir((char *)&i_v9);
                i_v10 = i_v4;
                if (p_v13 == NULL) {
                    return i_v10;
                } else {
                    struct dirent *p_v17 = readdir(p_v13); // 0xa09c
                    i_v12 = i_v4;
                    if (p_v17 == NULL) {
                        goto lab_0xa1c4;
                    } else {
                        // 0xa0a8
                        p_v6 = p_v17;
                        i_v7 = 0;
                        i_v11 = i_v4;
                        goto lab_0xa0a8_2;
                    }
                }
            }
        }
        // 0xa1f4
        fclose(p_v14);
        // 0x9fac
        return i_v4;
    }
    // 0x9f7c
    int32_t i_v18;                                  // bp-928, 0x9e38
    char *p_v19 = fgets((char *)&i_v18, 120, p_v5); // 0x9f8c
    int32_t i_v20 = 1;                              // 0x9f9c
    int32_t i_v21 = 0;                              // 0x9f9c
    int32_t i_v22 = i_v4;                           // 0x9f9c
    if (p_v19 == NULL) {
        // 0x9fa0
        fclose(p_v5);
        // 0x9fac
        return i_v4;
    }
    int32_t i_v23; // bp-956, 0x9e38
    while (true) {
        int32_t i_v24 = i_v22;
        uint32_t i_v25 = i_v20;
        char *p_v26 = strrchr((char *)&i_v18, 9); // 0x9e84
        *p_v26 = 0;
        char *p_v27 = strrchr((char *)&i_v18, 9); // 0x9ea8
        *p_v27 = 0;
        char *p_v28 = strrchr((char *)&i_v18, 9); // 0x9ecc
        *p_v28 = 0;
        sscanf((char *)&i_v18, "i2c-%d", &i_v23);
        int32_t i_v29 = i_v24; // 0x9f10
        if (i_v25 % 8 == 0) {
            // 0x9f14
            i_v29 = function_9c30(i_v24, i_v25);
            i_v10 = 0;
            if (i_v29 == 0) {
                // break -> 0x9fac
                break;
            }
        }
        int32_t i_v30 = (int32_t)p_v26 + 1; // 0x9e90
        int32_t i_v31 = (int32_t)p_v27 + 1; // 0x9eb4
        int32_t i_v32 = (int32_t)p_v28 + 1; // 0x9ed8
        int32_t i_v33 = i_v32 + i_v31;      // 0x9ef4
        i_v22 = i_v29;
        int32_t *p_v34 = malloc(i_v33 + i_v30); // 0x9f30
        if (p_v34 == NULL) {
            // 0x9fcc
            function_9bf8(i_v22, i_v31, i_v30, i_v33);
            i_v10 = 0;
            return i_v10;
        }
        int32_t i_v35 = i_v22 + i_v21;  // 0x9f24
        int32_t i_v36 = (int32_t)p_v34; // 0x9f30
        *(int32_t *)i_v35 = i_v23;
        char *p_v37 = strcpy((char *)p_v34, (char *)i_v31); // 0x9f4c
        *(int32_t *)(i_v35 + 4) = (int32_t)p_v37;
        char *p_v38 = strcpy((char *)(i_v31 + i_v36), (char *)i_v32); // 0x9f60
        *(int32_t *)(i_v35 + 8) = (int32_t)p_v38;
        char *p_v39 = strcpy((char *)(i_v33 + i_v36), (char *)i_v30); // 0x9f74
        *(int32_t *)(i_v35 + 12) = (int32_t)p_v39;
        char *p_v40 = fgets((char *)&i_v18, 120, p_v5); // 0x9f8c
        i_v20 = i_v25 + 1;
        i_v21 += 16;
        int32_t i_v41 = i_v22; // 0x9f9c
        if (p_v40 == NULL) {
            // 0x9fa0
            fclose(p_v5);
            // 0x9fac
            return i_v41;
        }
    }
lab_0x9fac:
    // 0x9fac
    return i_v10;
lab_0xa1c4:
    // 0xa1c4
    closedir(p_v13);
    i_v10 = i_v12;
    return i_v10;
lab_0xa0a8_2:;
    int32_t i_v42 = i_v11;       // 0x9e38
    struct dirent *p_v43 = p_v6; // 0x9e38
    int32_t i_v44 = i_v7;        // 0x9e38
    goto lab_0xa0a8_3;
lab_0xa0a8_3:;
    int32_t i_v45 = i_v44;
    int32_t i_v46 = i_v42;
    int32_t i_v47 = (int32_t)p_v43;
    char *p_v48 = (char *)(i_v47 + 11); // 0xa0a8
    if (*p_v48 == 46) {
        // 0xa1d0
        switch (*(char *)(i_v47 + 12)) {
        case 0: {
            goto lab_0xa098_2;
        }
        case 46: {
            // 0xa1e4
            if (*(char *)(i_v47 + 13) == 0) {
                goto lab_0xa098_2;
            } else {
                goto lab_0xa0b4;
            }
        }
        default: {
            goto lab_0xa0b4;
        }
        }
    } else {
        goto lab_0xa0b4;
    }
lab_0xa0b4:
    // 0xa0b4
    sprintf((char *)&i_v8, "%s/%s/name", &i_v9, p_v48);
    struct _IO_FILE *p_v49 = fopen((char *)&i_v8, "r"); // 0xa0d4
    struct _IO_FILE *p_v50 = p_v49;                     // 0xa0dc
    struct dirent *p_v51;                               // 0x9e38
    struct __dirstream *p_v52;                          // 0xa2a0
    if (p_v49 == NULL) {
        // 0xa260
        sprintf((char *)&i_v8, "%s/%s/device/name", &i_v9, p_v48);
        struct _IO_FILE *p_v53 = fopen((char *)&i_v8, "r"); // 0xa27c
        p_v50 = p_v53;
        if (p_v53 == NULL) {
            // 0xa288
            sprintf((char *)&i_v8, "%s/%s/device", &i_v9, p_v48);
            p_v52 = opendir((char *)&i_v8);
            if (p_v52 == NULL) {
                goto lab_0xa098_2;
            } else {
                struct dirent *p_v54 = readdir(p_v52); // 0xa2b0
                p_v51 = p_v54;
                if (p_v54 == NULL) {
                    goto lab_0xa098_2;
                } else {
                    goto lab_0xa2c8;
                }
            }
        } else {
            goto lab_0xa0e0;
        }
    } else {
        goto lab_0xa0e0;
    }
lab_0xa098_2:;
    struct dirent *p_v55 = readdir(p_v13); // 0xa09c
    p_v6 = p_v55;
    i_v7 = i_v45;
    i_v11 = i_v46;
    i_v12 = i_v46;
    if (p_v55 == NULL) {
        goto lab_0xa1c4;
    } else {
        goto lab_0xa0a8_2;
    }
lab_0xa0e0:;
    char *p_v56 = fgets((char *)&i_v18, 120, p_v50); // 0xa0f0
    fclose(p_v50);
    if (p_v56 == NULL) {
        // 0xa338
        fprintf(p_g4, "%s: read error\n", &i_v8);
        goto lab_0xa098_2;
    } else {
        char *p_v57 = strchr((char *)&i_v18, 10); // 0xa110
        if (p_v57 == NULL) {
            goto lab_dec_label_pc_0xa12c;
        } else {
            *p_v57 = 0;
            goto lab_dec_label_pc_0xa12c;
        }
    }
lab_dec_label_pc_0xa12c:;
    int32_t i_v58; // 0x9e38
    int32_t i_v59; // 0x9e38
    if (sscanf(p_v48, "i2c-%d", &i_v23) == 0) {
        goto lab_0xa098_2;
    } else {
        int32_t i_v60 = strncmp((char *)&i_v18, "ISA ", 4); // 0xa144
        i_v58 = (int32_t) "ISA ";
        i_v59 = 8;
        if (i_v60 == 0) {
            goto lab_0xa154;
        } else {
            // 0xa200
            int32_t i_v61; // bp-948, 0x9e38
            int32_t i_v62 = function_9d08(i_v23, &i_v61, 20, 1); // 0xa210
            i_v58 = &i_v61;
            i_v59 = 32;
            if (i_v62 >= 0) {
                int32_t i_v63 =
                    ioctl(i_v62, 1797) >= 0
                        ? i_v2 % 2 == 0 ? (i_v2 & 0x7e0000) == 0 ? 0 : 24 : 16
                        : 32;
                close(i_v62);
                i_v58 = 1797;
                i_v59 = i_v63;
                goto lab_0xa154;
            } else {
                goto lab_0xa154;
            }
        }
    }
lab_0xa2c8:;
    int32_t i_v64 = (int32_t)p_v51;
    char *p_v65 = (char *)(i_v64 + 11); // 0xa2c8
    if (*p_v65 == 46) {
        // 0xa314
        switch (*(char *)(i_v64 + 12)) {
        case 0: {
            goto lab_0xa2ac_2;
        }
        case 46: {
            // 0xa328
            if (*(char *)(i_v64 + 13) == 0) {
                goto lab_0xa2ac_2;
            } else {
                goto lab_0xa2d8;
            }
        }
        default: {
            goto lab_0xa2d8;
        }
        }
    } else {
        goto lab_0xa2d8;
    }
lab_0xa2d8:
    // 0xa2d8
    if (strncmp(p_v65, "i2c-", 4) == 0) {
        // 0xa2e4
        sprintf((char *)&i_v8, "%s/%s/device/%s/name", &i_v9, p_v48, p_v65);
        struct _IO_FILE *p_v66 = fopen((char *)&i_v8, "r"); // 0xa304
        p_v50 = p_v66;
        if (p_v66 == NULL) {
            goto lab_0xa2ac_2;
        } else {
            goto lab_0xa0e0;
        }
    } else {
        goto lab_0xa2ac_2;
    }
lab_0xa154:;
    int32_t i_v67 = i_v45 + 1; // 0xa154
    int32_t i_v68 = i_v46;     // 0xa15c
    int32_t i_v69 = i_v58;     // 0xa15c
    if (i_v67 % 8 == 0) {
        int32_t i_v70 = function_9c30(i_v46, i_v67); // 0xa168
        i_v10 = 0;
        i_v68 = i_v70;
        i_v69 = i_v67;
        if (i_v70 == 0) {
            goto lab_0x9fac;
        } else {
            goto lab_0xa178;
        }
    } else {
        goto lab_0xa178;
    }
lab_0xa2ac_2:;
    struct dirent *p_v71 = readdir(p_v52); // 0xa2b0
    p_v51 = p_v71;
    if (p_v71 == NULL) {
        goto lab_0xa098_2;
    } else {
        goto lab_0xa2c8;
    }
lab_0xa178:;
    int32_t i_v72 = i_v69;
    int32_t i_v73 = i_v68;
    int32_t i_v74 = i_v73 + 16 * i_v45; // 0xa184
    *(int32_t *)i_v74 = i_v23;
    char *p_v75 = __strdup((char *)&i_v18); // 0xa18c
    *(int32_t *)(i_v74 + 4) = (int32_t)p_v75;
    if (p_v75 == NULL) {
        // 0x9fb8
        function_9bf8(i_v73, i_v72, i_v73, i_v23);
        i_v10 = 0;
        goto lab_0x9fac;
    } else {
        int32_t i_v76 = *(int32_t *)(i_v59 + (int32_t)&x_g12);     // 0xa1a0
        int32_t i_v77 = *(int32_t *)(i_v59 + (int32_t)&x_g12 + 4); // 0xa1ac
        *(int32_t *)(i_v74 + 8) = i_v76;
        *(int32_t *)(i_v74 + 12) = i_v77;
        struct dirent *p_v78 = readdir(p_v13); // 0xa1b8
        i_v42 = i_v73;
        p_v43 = p_v78;
        i_v44 = i_v67;
        i_v12 = i_v73;
        if (p_v78 == NULL) {
            goto lab_0xa1c4;
        } else {
            goto lab_0xa0a8_3;
        }
    }
}

// Address range: 0xa38c - 0xa4c0
int32_t function_a38c(int32_t i_a1) {
    char *p_v1 = (char *)i_a1;              // 0xa3a0
    char *p_v2;                             // bp-28, 0xa38c
    int32_t i_v3 = strtoul(p_v1, &p_v2, 0); // 0xa3a0
    unsigned char i_v4 = *p_v2;             // 0xa3a8
    if ((char)i_v3 != 0 && i_v4 == 0) {
        int32_t i_v5 = i_v3; // 0xa3c8
        if (i_v3 >= 0x100000) {
            // 0xa480
            fwrite((int32_t *)"Error: I2C bus out of range!\n", 1, 29, p_g4);
            i_v5 = -2;
        }
        // 0xa3cc
        return i_v5;
    }
    int32_t i_v6 = function_9e38(); // 0xa3d8
    if (i_v6 == 0) {
        // 0xa4a0
        fwrite((int32_t *)"Error: Out of memory!\n", 1, 22, p_g4);
        // 0xa3cc
        return -3;
    }
    int32_t i_v7 = *(int32_t *)(i_v6 + 4); // 0xa3e4
    int32_t i_v8 = i_v7;                   // 0xa3f8
    int32_t i_v9 = i_v6;                   // 0xa3f8
    int32_t i_v10 = -1;                    // 0xa3f8
    int32_t i_v11;                         // 0xa38c
    int32_t i_v12;                         // 0xa38c
    int32_t i_v13;                         // 0xa38c
    int32_t i_v14;                         // 0xa38c
    if (i_v7 == 0) {
        goto lab_0xa460;
    } else {
        while (true) {
            int32_t i_v15 = i_v10;
            int32_t i_v16 = i_v9;
            int32_t i_v17 = i_v15; // 0xa408
            if (strcmp((char *)i_v8, p_v1) == 0) {
                if (i_v15 >= 0) {
                    // break -> 0xa440
                    break;
                }
                // 0xa414
                i_v17 = *(int32_t *)i_v16;
            }
            // 0xa418
            i_v10 = i_v17;
            i_v8 = *(int32_t *)(i_v16 + 20);
            i_v9 = i_v16 + 16;
            if (i_v8 == 0) {
                // 0xa42c
                i_v11 = i_a1;
                i_v12 = 0;
                i_v13 = i_v4;
                i_v14 = i_v10;
                if (i_v10 == -1) {
                    goto lab_0xa460;
                } else {
                    goto lab_0xa434;
                }
            }
        }
        // 0xa440
        fwrite((int32_t *)"Error: I2C bus name is not unique!\n", 1, 35, p_g4);
        i_v11 = 1;
        i_v12 = 35;
        i_v13 = (int32_t)p_g4;
        i_v14 = -4;
        goto lab_0xa434;
    }
lab_0xa460:
    // 0xa460
    fwrite((int32_t *)"Error: I2C bus name doesn't match any bus present!\n", 1,
           51, p_g4);
    i_v11 = 1;
    i_v12 = 51;
    i_v13 = (int32_t)p_g4;
    i_v14 = -1;
    goto lab_0xa434;
lab_0xa434:
    // 0xa434
    function_9bf8(i_v6, i_v11, i_v12, i_v13);
    // 0xa3cc
    return i_v14;
}

// Address range: 0xa4d4 - 0xa53c
int32_t function_a4d4(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    // 0xa4d4
    if (ioctl(i_a1, i_a3 == 0 ? 1795 : 1798) >= 0) {
        // 0xa4fc
        return 0;
    }
    int32_t *p_v1 = __errno_location(); // 0xa50c
    fprintf(p_g4, "Error: Could not set address to 0x%02x: %s\n", i_a2,
            strerror(*p_v1));
    return -*p_v1;
}

// Address range: 0xa544 - 0xa5e0
int32_t function_a544(int32_t i_a1) {
    // 0xa544
    int32_t i_v1; // bp-20, 0xa544
    if (fgets((char *)&i_v1, 2, p_g5) == NULL) {
        // 0xa5b4
        return 0;
    }
    uint32_t i_v2 = i_v1;       // 0xa56c
    uint32_t i_v3 = i_v2 % 256; // 0xa56c
    int32_t i_v4;               // 0xa544
    int32_t i_v5;               // 0xa544
    if (i_v3 == 89) {
        // 0xa5d0
        i_v4 = 1;
        goto lab_0xa59c;
    } else {
        char i_v6 = i_v2;
        if (i_v3 < 89) {
            // 0xa57c
            i_v4 = i_a1;
            i_v5 = i_a1;
            switch (i_v6) {
            case 78: {
                // 0xa5d8
                i_v4 = 0;
                goto lab_0xa59c;
            }
            case 10: {
                return i_v5;
            }
            default: {
                goto lab_0xa59c;
            }
            }
        } else {
            // 0xa5c0
            i_v4 = i_a1;
            i_v5 = i_a1;
            switch (i_v6) {
            case 110: {
                // 0xa5d8
                i_v4 = 0;
                goto lab_0xa59c;
            }
            case 121: {
                // 0xa5d0
                i_v4 = 1;
                goto lab_0xa59c;
            }
            case 10: {
                return i_v5;
            }
            default: {
                goto lab_0xa59c;
            }
            }
        }
    }
lab_0xa59c:
    // 0xa59c
    while (true) {
        uint32_t i_v7 = fgetc(p_g5); // 0xa5a0
        i_v5 = 0;
        if (i_v7 == -1) {
            // break -> 0xa5b4
            break;
        }
        // 0xa590
        i_v1 = 0x1000000 * i_v7 / 0x1000000;
        i_v5 = i_v4;
        if (i_v7 % 256 == 10) {
            // break -> 0xa5b4
            break;
        }
    }
    // 0xa5b4
    return i_v5;
}

// Address range: 0xa5e4 - 0xa640
int32_t function_a5e4(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    int32_t i_v1 = function_8960(i_a1, i_a2, i_a3, i_a4); // 0xa600
    int32_t i_v2 = (int32_t)&i_g2 - (int32_t)&i_g1 >> 2 == 0 ? i_v1 : i_a1;
    return i_v2;
}

// Address range: 0xa648 - 0xa64c
int32_t function_a648(void) {
    // 0xa648
    int32_t i_v1; // 0xa648
    return i_v1;
}

// Address range: 0xa64c - 0xa654
int32_t function_a64c(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0xa64c
    return i_a1;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.8.x)
// Detected functions: 62
